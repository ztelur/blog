<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">

<head>
  <meta charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <title>Spring Cloud Netflix Feign 基础应用实战 | 程序员历小冰</title>
  <meta name="description" content="remcarpediem" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="&amp;emsp;微服务是软件系统架构上的一种设计风格，它倡导将一个原本独立的服务系统分成多个小型服务，这些小型服务都在独立的进程中运行，通过各个小型服务之间的协作来实现原本独立系统的所有业务功能。小型服务基于多种跨进程的方式进行通信协作，而在Spring Cloud架构中比较常见的跨进程的方式是RESTful HTTP请求和RPC调用。 &amp;emsp;RPC就是远程过程调用，它是一种通过网络从远程计算机">
<meta name="keywords" content="spring-cloud">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Cloud Netflix Feign 基础应用实战">
<meta property="og:url" content="http://remcarpediem.net/article/6fc98a53/index.html">
<meta property="og:site_name" content="程序员历小冰">
<meta property="og:description" content="&amp;emsp;微服务是软件系统架构上的一种设计风格，它倡导将一个原本独立的服务系统分成多个小型服务，这些小型服务都在独立的进程中运行，通过各个小型服务之间的协作来实现原本独立系统的所有业务功能。小型服务基于多种跨进程的方式进行通信协作，而在Spring Cloud架构中比较常见的跨进程的方式是RESTful HTTP请求和RPC调用。 &amp;emsp;RPC就是远程过程调用，它是一种通过网络从远程计算机">
<meta property="og:locale" content="Chinese">
<meta property="og:image" content="http://remcarpediem.net/images/19_109/image1.png">
<meta property="og:image" content="http://remcarpediem.net/images/19_109/image2.png">
<meta property="og:image" content="http://remcarpediem.net/images/logo.png">
<meta property="og:updated_time" content="2019-10-09T13:45:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring Cloud Netflix Feign 基础应用实战">
<meta name="twitter:description" content="&amp;emsp;微服务是软件系统架构上的一种设计风格，它倡导将一个原本独立的服务系统分成多个小型服务，这些小型服务都在独立的进程中运行，通过各个小型服务之间的协作来实现原本独立系统的所有业务功能。小型服务基于多种跨进程的方式进行通信协作，而在Spring Cloud架构中比较常见的跨进程的方式是RESTful HTTP请求和RPC调用。 &amp;emsp;RPC就是远程过程调用，它是一种通过网络从远程计算机">
<meta name="twitter:image" content="http://remcarpediem.net/images/19_109/image1.png">
  <!-- build:css css/screen.css -->

  <link rel="stylesheet" href="/css/screen.css">
  <link rel="stylesheet" href="/css/prism.css">
  
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  
  <!-- endbuild -->
  
  <!-- build:css fancybox/jquery.fancybox.css -->
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <!-- endbuild -->
  
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
  <meta name="generator" content="程序员历小冰">
  
  
  
<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>


<body class="post-template">

  <div class="nav">
  <h3 class="nav-title">Home</h3>
  <a href="#" class="nav-close">
    <span class="hidden">Close</span>
  </a>
  <ul>
    <li class="nav-home" role="presentation"><a href="/">Home</a></li>
    <!-- <li class="nav-about {% if page.current == 'about' %} nav-current{% endif %}" role="presentation"><a href="{{ site.baseurl }}about">About</a></li>
    <li class="nav-author {% if page.current == 'author' %} nav-current{% endif %}" role="presentation"><a href="{{ site.baseurl }}author/casper">Author</a></li> -->
    <li class="nav-ios" role="presentation"><a href="/archives">Archives</a></li>
  </ul>
  <a class="subscribe-button icon-feed" href="{{ site.baseurl }}feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>

  <div class="site-wrapper">
  <header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        <a class="back-button icon-arrow-left" href="/">Home</a>
        <!-- <a class="subscribe-button icon-feed" href="/atom.xml">Subscribe</a> -->
        <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
    </nav>
    
    <a class="scroll-down icon-arrow-left" href="#content" data-offset="-45"><span class="hidden">Scroll Down</span></a>
</header>

  

<main id="content" class="content" role="main">
  <article class="post" itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting">
    <header class="post-header">
      <h1 class="post-title" itemprop="name">Spring Cloud Netflix Feign 基础应用实战</h1>
      <section class="post-meta">
  <time datetime="2019-10-09T13:40:45.000Z" itemprop="datePublished" class="post-date">
      2019-10-09
  </time>
  
  
  
  <a href="/tags/spring-cloud/">spring-cloud</a>
  
  
</section>

    </header>
    <section class="post-content" itemprop="description articleBody">
      

      <!--  -->
      <p>&emsp;微服务是软件系统架构上的一种设计风格，它倡导将一个原本独立的服务系统分成多个小型服务，这些小型服务都在独立的进程中运行，通过各个小型服务之间的协作来实现原本独立系统的所有业务功能。小型服务基于多种跨进程的方式进行通信协作，而在<code>Spring Cloud</code>架构中比较常见的跨进程的方式是RESTful HTTP请求和RPC调用。</p>
<p>&emsp;RPC就是远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如说，计算机 A 上的进程调用另外一台计算机 B 上的进程，其中 A 上的调用进程被挂起，而 B 上的被调用进程开始执行，当值返回给 A 时，A 进程继续执行。调用方可以通过使用参数将信息传送给被调用方，而后可以通过传回的结果得到信息。而这一过程，对于开发人员来说是透明的。</p>
<p><img src="/images/19_109/image1.png" alt="RPC示意图"></p>
<p>&emsp;REST是Representational State Transfer的缩写,是表现层状态转移的含义。</p>
<p>&emsp;Resource是资源，所谓“资源”就是网络上的一个实体，或者说网上的一个具体信息。它可以是一段文本，一首歌曲，一种服务，总之就是一个具体的存在。你可以使用一个URI指向它，每种”资源“对应一个URI。</p>
<p>&emsp;Representational是”表现层“的意思，”资源“是一种消息实体，它可以有多种外在的表现形式，我们把”资源“的具体呈现出来的形式叫做它的”表现层“。比如说，文本可以用txt格式进行表现，也可以使用xml格式，JSON格式和二进制格式；视频可以以MP4格式表现，也可以以AVI格式表现。URI只代表资源的实体，不代表它的形式。它的具体表现形式，应该在HTTP请求的头信息Accept和Content-Type字段指定，这两个字段才是对”表现层“的描述。</p>
<p>&emsp;State Transfer是指状态转化。客户端访问服务的过程中必然涉及到数据和状态的转化。如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化“。而这种转化是建立在表现层之上的，所以就是”表现层状态转化“。客户端通过使用HTTP协议中的四个动词来实现上述操作，它们分别：用来获取资源的GET，用来新建或更新资源的POST，用来更新资源的PUT，用来删除资源的DELETE。</p>
<p>&emsp;REST是Web Service的一种实现方式，另外一种实现方式为SOAP。REST致力于通过HTTP协议中的POST/GET/PUT/DELETE等方法和一个可读性较强的URL来提供一个HTTP请求；而SOAP致力于通过wsdl数据格式来实现通信。二者的使用场景和设计目标不同。SOAP一般作为应用层协议来进行服务间的消息调用。</p>
<p>&emsp;RPC和REST之间的最大差别在于RPC调用可以不依赖HTTP协议，底层直接使用TPC/IP协议进行传输，传输效率相比于REST会有一定的提升。</p>
<h3 id="Feign简介"><a href="#Feign简介" class="headerlink" title="Feign简介"></a>Feign简介</h3><p>&emsp;<code>Feign</code>是一个声明式RESTful HTTP请求客户端，它使得编写Web服务客户端更加方便和快捷。使用Feign创建一个接口并使用Feign提供的注解修饰该接口，然后就可以使用该接口进行RESTful HTTP请求的发送。<code>Feign</code>还可以集成Ribbon和Eureka来为自己提供负载均衡和断路器的机制。</p>
<p>&emsp;<code>Feign</code>会将带有注解的函数接口信息转化为网络请求模板，在发送网络请求之前，函数的参数值会以一定的方式设置到这些请求模板中。虽然这样的模式使得<code>Feign</code>只能支持基于文本的网络请求，但是它可以简化网络请求的实现，方便编程人员快速构建自己的网络请求架构。<br><img src="/images/19_109/image2.png" alt="Feign架构示意图"></p>
<p>&emsp;如图5.2所示，使用<code>Feign</code>的程序的架构一般分为三个部分，分别为服务注册中心，服务提供者和服务消费者。服务提供者向服务注册中心注册自己，然后服务消费者通过<code>Feign</code>发送请求时，<code>Feign</code>会向去服务注册中心获取关于服务提供者的信息，然后再向服务提供者发送网络请求。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h4><p>&emsp;<code>Feign</code>可以配合<code>eureka</code>等服务注册中心同时使用。<code>eureka</code>来作为服务注册中心，为<code>Feign</code>提供关于服务端信息的获取，比如说IP地址。关于<code>eureka</code>的具体使用可以参考第四章中关于<code>eureka</code>的快速入门介绍。</p>
<h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h4><p>&emsp;<code>Spring Cloud Feign</code>是声明式RESTful请求客户端，所以它不会侵入服务提供者程序的实现。也就是说，服务提供者只需要提供Web Service的API接口，至于具体实现既可以是<code>Spring Controler</code>也可以是<code>Jersey</code>。我们只需要确保该服务提供者被注册到服务注册中心上。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">@RestController
@RequestMapping(&quot;&#x2F;feign-service&quot;)
public class FeignServiceController {

    private static final Logger logger = LoggerFactory.getLogger(FeignServiceController.class);

    private static String DEFAULT_SERVICE_ID = &quot;application&quot;;
    private static String DEFAULT_HOST = &quot;localhost&quot;;
    private static int DEFAULT_PORT = 8080;

    @RequestMapping(value = &quot;&#x2F;instance&#x2F;{serviceId}&quot;, method = RequestMethod.GET)
    public Instance getInstanceByServiceId(@PathVariable(&quot;serviceId&quot;) String serviceId){
        logger.info(&quot;Get Instance by serviceId {}&quot;, serviceId);
        return new Instance(serviceId, DEFAULT_HOST, DEFAULT_PORT);
    }

    @RequestMapping(value = &quot;&#x2F;instance&#x2F;{serviceId}&quot;, method = RequestMethod.DELETE)
    public String deleteInstanceByServiceId(@PathVariable(&quot;serviceId&quot;) String serviceId){

        logger.info(&quot;Delete Instance by serviceId {}&quot;, serviceId);
        return &quot;Instance whose serviceId is &quot; + serviceId + &quot; is deleted&quot;;

    }

    @RequestMapping(value = &quot;&#x2F;instance&quot;, method = RequestMethod.POST)
    public String createInstance(@RequestBody Instance instance){

        logger.info(&quot;Create Instance whose serviceId is {}&quot;, instance.getServiceId());
        return &quot;Instance whose serviceId is&quot; + instance.getServiceId() + &quot; is created&quot;;
    }

    @RequestMapping(value = &quot;&#x2F;instance&#x2F;{serviceId}&quot;, method = RequestMethod.PUT)
    public String updateInstanceByServiceId(@RequestBody Instance instance, @PathVariable(&quot;serviceId&quot;) String serviceId){
        logger.info(&quot;Update Instance whose serviceId is {}&quot;, serviceId);
        return &quot;Instance whose serviceId is &quot; + serviceId + &quot; is updated&quot;;
    }
}
</code></pre>
<p>&emsp;上述代码中通过<code>@RestController</code>和<code>@RequestMapping</code>声明了四个网络API接口，分别是对<code>Instance</code>资源的增删改查操作。</p>
<p>&emsp;除了实现网络API接口之外，还需要将该service注册到<code>eureka</code>上。如下列代码所示，需要在<code>application.yml</code>文件中设置服务注册中心的相关信息和代表该应用的名称。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-yml">eureka:
  instance:
    instance-id: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}
  client:
    service-url:
      default-zone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;
spring:
  application:
    name: feign-service
server:
  port: 0
</code></pre>
<h4 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h4><p>&emsp;<code>Feign</code>是声明式RESTful客户端，所以构建<code>Feign</code>项目的关键在于构建服务消费者。通过下面六步可以创建一个<code>Spring Cloud Feign</code>的服务消费者。</p>
<p>&emsp;首先创建一个普通的<code>Spring Boot</code>工程，取名为<code>chapter-feign-client</code>。<br>&emsp;然后在pom文件中添加<code>eureka</code>和<code>feign</code>相关的依赖。其中<code>spring-cloud-starter-eureka</code>是<code>eureka</code>的starter依赖包，<code>spring-cloud-starter-feign</code>是<code>feign</code>的starter依赖包。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;
    &lt;&#x2F;dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-feign&lt;&#x2F;artifactId&gt;
    &lt;&#x2F;dependency&gt;
&lt;&#x2F;dependencies&gt;
</code></pre>
<p>&emsp;接着在工程的入口类上添加<code>@EnableFeignClients</code>注解表示开启<code>Spring Cloud Feign</code>的支持功能，代码如下所示。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">@SpringBootApplication
@EnableFeignClients()
public class ChapterFeignClientApplication {
	public static void main(String[] args) {
		SpringApplication.run(ChapterFeignClientApplication.class, args);
	}
}
</code></pre>
<p>&emsp;<code>@EnableFeignClients</code>就像是一个开关，如果你使用了该注解，那么<code>Feign</code>相关的组件和处理机制才会生效，否则不会生效。<code>@EnableFeignClients</code>还可以对<code>Feign</code>相关组件进行自定义配置，它的方法和原理会在本章的源码分析章节在做具体的讲解。</p>
<p>&emsp;接下来我们定义一个<code>FeignServiceClient</code>接口，通过<code>@FeignClient</code>注解来指定服务名进而绑定服务。这一类被<code>@FeignClient</code>修饰的接口类一般被称为FeignClient。我们可以通过<code>@RequestMapping</code>来修饰相应的方法来定义调用函数。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">@FeignClient(&quot;feign-service&quot;)
@RequestMapping(&quot;&#x2F;feign-service&quot;)
public interface FeignServiceClient {

    @RequestMapping(value = &quot;&#x2F;instance&#x2F;{serviceId}&quot;, method = RequestMethod.GET)
    public Instance getInstanceByServiceId(@PathVariable(&quot;serviceId&quot;) String serviceId);

    @RequestMapping(value = &quot;&#x2F;instance&#x2F;{serviceId}&quot;, method = RequestMethod.DELETE)
    public String deleteInstanceByServiceId(@PathVariable(&quot;serviceId&quot;) String serviceId);

    @RequestMapping(value = &quot;&#x2F;instance&quot;, method = RequestMethod.POST)
    public String createInstance(@RequestBody Instance instance);

    @RequestMapping(value = &quot;&#x2F;instance&#x2F;{serviceId}&quot;, method = RequestMethod.PUT)
    public String updateInstanceByServiceId(@RequestBody Instance instance, @PathVariable(&quot;serviceId&quot;) String serviceId);
}
</code></pre>
<p>&emsp;如上面代码片段所显示的，如果你调用<code>FeignServiceClient</code>对象的<code>getInstanceByServiceId</code>函数，那么<code>Feign</code>就会向<code>feign-service</code>服务的<code>/feign-service/instance/{serviceId}</code>接口发送网络请求。</p>
<p>&emsp;创建一个<code>Controller</code>来调用上边的服务，通过<code>@Autowired</code>来自动装载<code>FeignServiceClient</code>示例。代码如下：</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">@RestController
@RequestMapping(&quot;&#x2F;feign-client&quot;)
public class FeignClientController {

    @Autowired
    FeignServiceClient feignServiceClient;

    @RequestMapping(value = &quot;&#x2F;instance&#x2F;{serviceId}&quot;, method = RequestMethod.GET)
    public Instance getInstanceByServiceId(@PathVariable(&quot;serviceId&quot;) String serviceId){
        return feignServiceClient.getInstanceByServiceId(serviceId);
    }

    @RequestMapping(value = &quot;&#x2F;instance&#x2F;{serviceId}&quot;, method = RequestMethod.DELETE)
    public String deleteInstanceByServiceId(@PathVariable(&quot;serviceId&quot;) String serviceId){
        return feignServiceClient.deleteInstanceByServiceId(serviceId);
    }

    @RequestMapping(value = &quot;&#x2F;instance&quot;, method = RequestMethod.POST)
    public String createInstance(@RequestBody Instance instance){
        return feignServiceClient.createInstance(instance);
    }

    @RequestMapping(value = &quot;&#x2F;instance&#x2F;{serviceId}&quot;, method = RequestMethod.PUT)
    public String updateInstanceByServiceId(@RequestBody Instance instance, @PathVariable(&quot;serviceId&quot;) String serviceId){
        return feignServiceClient.updateInstanceByServiceId(instance, serviceId);
    }
}
</code></pre>
<p>&emsp;最后，<code>application.yml</code>中需要配置<code>eureka</code>服务注册中心的相关配置，具体配置如下所示：<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-yml">eureka:
  instance:
    instance-id: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}
  client:
    service-url:
      default-zone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;

spring:
  application:
    name: feign-client
server:
  port: 8770
</code></pre></p>
<p>&emsp;相信读者通过搭建<code>Feign</code>的项目，已经对<code>Feign</code>的相关使用原理有了一定的了解，相信这个过程将对于理解<code>Feign</code>相关的工作原理大有裨益。</p>
<p><img src="/images/logo.png" alt=""></p>

      <h3>关于图片和转载</h3>

      <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png"></a><br>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。

      转载时请注明原文链接，图片在使用时请保留图片中的全部内容，可适当缩放并在引用处附上图片所在的文章链接。

      <h3>关于评论和留言</h3>

      如果对本文 <a href="http://remcarpediem.net/article/6fc98a53/">Spring Cloud Netflix Feign 基础应用实战</a> 的内容有疑问，请在下面的评论系统中留言，谢谢。

      <blockquote>
        <p>原文链接：<a href="http://remcarpediem.net/article/6fc98a53/">Spring Cloud Netflix Feign 基础应用实战</a></p>

        <p>Follow: <a href="https://github.com/ztelur">Ztelur · GitHub</a></p>
      </blockquote>

    </section>
    <footer class="post-footer">
     
        <figure class="author-image">
          <a class="img" href="https://github.com/ztelur" style="background-image: url(https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1543337069412&di=609213db44c3240a091b26f82707da85&imgtype=0&src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F65b2fd9d9a84c14f4a712ed0d71b0fbb67dcbf2d.jpg)"><span class="hidden">历小冰's Picture</span></a>
        </figure>
     
      <section class="author">
        <h4><a href="https://github.com/ztelur">历小冰</a></h4>
        
        <p> 君子不器</p>
         
        <div class="author-meta">
          <span class="author-location icon-location"> NanJing</span> 
          <span class="author-link icon-link"><a href="http://remcarpediem.net"> 程序员历小冰</a></span> 
        </div>
</section>
      <!--<section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" href="http://twitter.com/share?url=http://remcarpediem.net/article/6fc98a53/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://remcarpediem.net/article/6fc98a53/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=http://remcarpediem.net/article/6fc98a53/" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section>-->
      
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<script>
    const gitalk = new Gitalk({
    clientID: 'ece2d2cd7c5f768a4c22',
    clientSecret: '1ad562557353b888b4b622239d45150c5df6d5ee',
    repo: 'blog-comments',
    owner: 'ztelur',
    admin: ['ztelur'],
    // labels: ['Gitalk', 'gitment'].concat(["{{ page.tags | join: '","'}}"]),
    // id: location.origin + location.pathname,
    id: md5("http://remcarpediem.net/article/6fc98a53/"),
    // facebook-like distraction free mode
    distractionFreeMode: false
});

gitalk.render('gitalk-container')
</script>

    </footer>
  </article>
</main>
<aside class="read-next">
 
    
    <a class="read-next-story no-cover" href="http://remcarpediem.net/article/eb2e63e2/">
      <section class="post">
        <h2>Redis 复制过程详解</h2>
        <p>
            
              Redis 的复制功能分为同步( sync )和命令传播( command propagate )两个步骤：

同步用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。
命令传播则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。

同步Redis 使用 psync 命令完成主从数据同步，同步过程分为：全量复制和部分复制。
全量复制：一般用于初次复制场景，它会把主节 ......
            
          </p>
      </section>
    </a>
    
  


  
</aside>


  <footer class="site-footer clearfix">
 <section class="copyright"><a href="/">程序员历小冰</a> &copy; 2015 &bull; All rights reserved.</section>
 <section class="poweredby">Proudly published with <a class="icon-ghost" href="http://zespia.tw/hexo/"> Hexo</a></section>
</footer>

  </div>
  <script type="text/javascript" src="/js/jquery-2.0.3.min.js"></script>
<script>window.jQuery || document.write('<script src="js/jquery-2.0.3.min.js"><\/script>')</script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/prism.js"></script>
<script type="text/javascript" src="/js/toc.js"></script>

<script type="text/javascript">
(function($){
  var $postContent = $(".post-content");
  $postContent.fitVids();
})(jQuery);
</script>

<script type="text/javascript" src="/js/index.js"></script>

<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    var wrapAll = function(q) {
      $(q).each( function() {
        var $img = $(this),
            href = $img.attr('src');
        $img.wrap('<a rel="fancybox" href="' + href + '" title="' + $img.attr('alt') + '" class="link"></a>');
      });
    };
    wrapAll('.post-content img');
    wrapAll('.post-excerpt img');
    $('[rel="fancybox"]').fancybox();
  })(jQuery);
</script>





<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f089a91a688633df563c08899e3d893e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>



</body>
</html>
