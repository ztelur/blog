<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">

<head>
  <meta charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <title>一文了解 Redis 内存监控和内存消耗 | 程序员历小冰</title>
  <meta name="description" content="remcarpediem" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Redis 是一种内存数据库，将数据保存在内存中，读写效率要比传统的将数据保存在磁盘上的数据库要快很多。所以，监控 Redis 的内存消耗并了解 Redis 内存模型对高效并长期稳定使用 Redis 至关重要。  内存使用统计通过 info memory 命令可以获得 Redis 内存相关的指标。较为重要的指标和解释如下所示：   当 mem_fragmentation_ratio &amp;gt; 1">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="一文了解 Redis 内存监控和内存消耗">
<meta property="og:url" content="http://remcarpediem.net/article/516957d3/index.html">
<meta property="og:site_name" content="程序员历小冰">
<meta property="og:description" content="Redis 是一种内存数据库，将数据保存在内存中，读写效率要比传统的将数据保存在磁盘上的数据库要快很多。所以，监控 Redis 的内存消耗并了解 Redis 内存模型对高效并长期稳定使用 Redis 至关重要。  内存使用统计通过 info memory 命令可以获得 Redis 内存相关的指标。较为重要的指标和解释如下所示：   当 mem_fragmentation_ratio &amp;gt; 1">
<meta property="og:locale" content="Chinese">
<meta property="og:image" content="http://remcarpediem.net/images/19_1014/image1.png">
<meta property="og:image" content="http://remcarpediem.net/images/19_1014/image7.jpg">
<meta property="og:image" content="http://remcarpediem.net/images/19_1014/image2.png">
<meta property="og:image" content="http://remcarpediem.net/images/19_1014/image3.png">
<meta property="og:image" content="http://remcarpediem.net/images/19_1014/image4.png">
<meta property="og:image" content="http://remcarpediem.net/images/19_1014/image5.png">
<meta property="og:image" content="http://remcarpediem.net/images/19_1014/image6.png">
<meta property="og:image" content="http://remcarpediem.net/images/logo.png">
<meta property="og:updated_time" content="2019-10-15T14:51:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一文了解 Redis 内存监控和内存消耗">
<meta name="twitter:description" content="Redis 是一种内存数据库，将数据保存在内存中，读写效率要比传统的将数据保存在磁盘上的数据库要快很多。所以，监控 Redis 的内存消耗并了解 Redis 内存模型对高效并长期稳定使用 Redis 至关重要。  内存使用统计通过 info memory 命令可以获得 Redis 内存相关的指标。较为重要的指标和解释如下所示：   当 mem_fragmentation_ratio &amp;gt; 1">
<meta name="twitter:image" content="http://remcarpediem.net/images/19_1014/image1.png">
  <!-- build:css css/screen.css -->

  <link rel="stylesheet" href="/css/screen.css">
  <link rel="stylesheet" href="/css/prism.css">
  
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  
  <!-- endbuild -->
  
  <!-- build:css fancybox/jquery.fancybox.css -->
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <!-- endbuild -->
  
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
  <meta name="generator" content="程序员历小冰">
  
  
  
<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>


<body class="post-template">

  <div class="nav">
  <h3 class="nav-title">Home</h3>
  <a href="#" class="nav-close">
    <span class="hidden">Close</span>
  </a>
  <ul>
    <li class="nav-home" role="presentation"><a href="/">Home</a></li>
    <!-- <li class="nav-about {% if page.current == 'about' %} nav-current{% endif %}" role="presentation"><a href="{{ site.baseurl }}about">About</a></li>
    <li class="nav-author {% if page.current == 'author' %} nav-current{% endif %}" role="presentation"><a href="{{ site.baseurl }}author/casper">Author</a></li> -->
    <li class="nav-ios" role="presentation"><a href="/archives">Archives</a></li>
  </ul>
  <a class="subscribe-button icon-feed" href="{{ site.baseurl }}feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>

  <div class="site-wrapper">
  <header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        <a class="back-button icon-arrow-left" href="/">Home</a>
        <!-- <a class="subscribe-button icon-feed" href="/atom.xml">Subscribe</a> -->
        <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
    </nav>
    
    <a class="scroll-down icon-arrow-left" href="#content" data-offset="-45"><span class="hidden">Scroll Down</span></a>
</header>

  

<main id="content" class="content" role="main">
  <article class="post" itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting">
    <header class="post-header">
      <h1 class="post-title" itemprop="name">一文了解 Redis 内存监控和内存消耗</h1>
      <section class="post-meta">
  <time datetime="2019-10-14T13:06:41.000Z" itemprop="datePublished" class="post-date">
      2019-10-14
  </time>
  
  
  
  <a href="/tags/Redis/">Redis</a>
  
  
</section>

    </header>
    <section class="post-content" itemprop="description articleBody">
      

      <!-- 
      <section class="post-updated">
  Last updated on <time datetime="2019-10-15T14:51:15.000Z" itemprop="dateModified">
      2019-10-15
  </time>
</section>

       -->
      <p>Redis 是一种内存数据库，将数据保存在内存中，读写效率要比传统的将数据保存在磁盘上的数据库要快很多。所以，监控 Redis 的内存消耗并了解 Redis 内存模型对高效并长期稳定使用 Redis 至关重要。</p>
<p><img src="/images/19_1014/image1.png" alt=""></p>
<h3 id="内存使用统计"><a href="#内存使用统计" class="headerlink" title="内存使用统计"></a>内存使用统计</h3><p>通过 info memory 命令可以获得 Redis 内存相关的指标。较为重要的指标和解释如下所示：</p>
<p><img src="/images/19_1014/image7.jpg" alt=""></p>
<p><img src="/images/19_1014/image2.png" alt=""></p>
<p>当 mem_fragmentation_ratio &gt; 1 时，说明有部分内存并没有用于数据存储，而是被内存碎片所消耗，如果该值很大，说明碎片率严重。<br>当 mem_fragmentation_ratio &lt; 1 时，这种情况一般出现在操作系统把 Redis 内存交换 (swap) 到硬盘导致，出现这种情况要格外关注，由于硬盘速度远远慢于内存，Redis 性能会变得很差，甚至僵死。</p>
<p>当 Redis 内存超出可以获得内存时，操作系统会进行 swap，将旧的页写入硬盘。从硬盘读写大概比从内存读写要慢5个数量级。used_memory 指标可以帮助判断 Redis 是否有被swap的风险或者它已经被swap。</p>
<p>在 Redis Administration 一文 (链接在文末) 建议要设置和内存一样大小的交换区，如果没有交换区，一旦 Redis 突然需要的内存大于当前操作系统可用内存时，Redis 会因为 out of memory 而被 Linix Kernel 的 OOM Killer 直接杀死。虽然当 Redis 的数据被换出 (swap out) 时，Redis的性能会变差，但是总比直接被杀死的好。</p>
<p>Redis 使用 maxmemory 参数限制最大可用内存。限制内存的目的主要有:</p>
<ul>
<li>用于缓存场景，当超出内存上限 maxmemory 时使用 LRU 等删除策略释放空间。</li>
<li>防止所用的内存超过服务器物理内存，导致 OOM 后进程被系统杀死。</li>
</ul>
<p>maxmemory 限制的是 Redis 实际使用的内存量，也就是 used_memory 统计项对应的内存。实际消耗的内存可能会比 maxmemory 设置的大，要小心因为这部内存导致 OOM。所以，如果你有 10GB 的内存，最好将 maxmemory 设置为 8 或者 9G</p>
<h3 id="内存消耗划分"><a href="#内存消耗划分" class="headerlink" title="内存消耗划分"></a>内存消耗划分</h3><p>Redis 进程内消耗主要包括：自身内存 + 对象内存 + 缓冲内存 + 内存碎片，其中 Redis 空进程自身内存消耗非常少，通常 used_memory_rss 在 3MB 左右时，used_memory 一般在 800KB 左右，一个空的 Redis 进程消耗内存可以忽略不计。</p>
<p><img src="/images/19_1014/image3.png" alt=""></p>
<h4 id="对象内存"><a href="#对象内存" class="headerlink" title="对象内存"></a>对象内存</h4><p>对象内存是 Redis 内存占用最大的一块，存储着用户所有的数据。Redis 所有的数据都采用 key-value 数据类型，每次创建键值对时，至少创建两个类型对象：key 对象和 value 对象。对象内存消耗可以简单理解为这两个对象的内存消耗之和(还有类似过期之类的信息)。键对象都是字符串，在使用 Redis 时很容易忽略键对内存消耗的影响，应当避免使用过长的键。有关 Redis 对象系统的详细内容，请看我之前的文章<a href="https://mp.weixin.qq.com/s/gQnuynv6XPD_aeIBQBeI2Q" target="_blank" rel="noopener">十二张图带你了解 Redis 的数据结构和对象系统</a>。</p>
<h5 id="缓冲内存"><a href="#缓冲内存" class="headerlink" title="缓冲内存"></a>缓冲内存</h5><p>缓冲内存主要包括：客户端缓冲、复制积压缓冲区和 AOF 缓冲区。</p>
<p>客户端缓冲指的是所有接入到 Redis 服务器 TCP 连接的输入输出缓冲。 </p>
<p><img src="/images/19_1014/image4.png" alt=""></p>
<p>输入缓冲无法控制，最大空间为 1G，如果超过将断开连接。而且输入缓冲区不受 maxmemory 控制，假设一个 Redis 实例设置了 maxmemory 为 4G，已经存储了 2G 数据，但是如果此时输入缓冲区使用了 3G，就已经超出了 maxmemory 限制，可能导致数据丢失、键值淘汰或者 OOM。</p>
<p>输入缓冲区过大主要是因为 Redis 的处理速度跟不上输入缓冲区的输入速度，并且每次进入输入缓冲区的命令包含了大量的 bigkey。</p>
<p>输出缓冲通过参数 client-output-buffer-limit 控制，其格式如下所示。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">client-output-buffer-limit [hard limit] [soft limit] [duration]
</code></pre></p>
<p>hard limit 是指一旦缓冲区大小达到了这个阈值，Redis 就会立刻关闭该连接。而 soft limit 和时间 duration 共同生效，比如说 soft time 为 64mb、duration 为 60，则只有当缓冲区持续 60s 大于 64mb 时，Redis 才会关闭该连接。</p>
<p>普通客户端是除了复制和订阅的客户端之外的所有连接。Reids 对其的默认配置是 client-output-buffer-limit normal 0 0 0 , Redis 并没有对普通客户端的输出缓冲区做限制，一般普通客户端的内存消耗可以忽略不计，但是当有大量慢连接客户端接入时这部分内存消耗就不能忽略，可以设置 maxclients 做限制。特别当使用大量数据输出的命令且数据无法及时推送到客户端时，如 monitor 命令，容易造成 Redis 服务器内存突然飙升。相关案例可以查看这篇文章<a href="https://www.iteye.com/blog/carlosfu-2254571" target="_blank" rel="noopener">美团在Redis上踩过的一些坑-3.redis内存占用飙升</a>。</p>
<p>从客户端用于主从复制，主节点会为每个从节点单独建立一条连接用于命令复制，默认配置为 client-output-buffer-limit slave 256mb 64mb 60。当主从节点之间网络延迟较高或主节点挂载大量从节点时这部分内存消耗将占用很大一部分，建议主节点挂载的从节点不要多于 2 个，主从节点不要部署在较差的网络环境下，如异地跨机房环境，防止复制客户端连接缓慢造成溢出。与主从复制相关的一共有两类缓冲区，一个是从客户端输出缓冲区，另外一个是下面会介绍到的复制积压缓冲区。</p>
<p><img src="/images/19_1014/image5.png" alt=""></p>
<p>订阅客户端用于发布订阅功能，连接客户端使用单独的输出缓冲区，默认配置为 client-output-buffer-limit pubsub 32mb 8mb 60，当订阅服务的消息生产快于消费速度时，输出缓冲区会产生积压造成内存空间溢出。</p>
<p>输入输出缓冲区在大流量场景中容易失控，造成 Redis 内存不稳定，需要重点监控。可以定期执行 client list 命令，监控每个客户端的输入输出缓冲区大小和其他信息。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>qbuf</td>
<td>查询缓冲区的长度（字节为单位， 0 表示没有分配查询缓冲区）</td>
</tr>
<tr>
<td>qbuf-free</td>
<td>查询缓冲区剩余空间的长度（字节为单位， 0 表示没有剩余空间）</td>
</tr>
<tr>
<td>obl</td>
<td>输出缓冲区的长度（字节为单位， 0 表示没有分配输出缓冲区）</td>
</tr>
<tr>
<td>oll</td>
<td>输出列表包含的对象数量（当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里）</td>
</tr>
</tbody>
</table>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">127.0.0.1:6379&gt; client list
id=3 addr=127.0.0.1:58161 fd=8 name= \
age=1408 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 \
qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 \
events=r cmd=client
</code></pre>
<p>client list 命令执行速度慢，客户端较多时频繁执行存在阻塞redis的可能，所以一般可以先使用 info clients 命令获取最大的客户端缓冲区大小。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">127.0.0.1:6379&gt; info clients
# Clients
connected_clients:1
client_recent_max_input_buffer:2
client_recent_max_output_buffer:0
blocked_clients:0
</code></pre>
<p>复制积压缓冲区是Redis 在 2.8 版本后提供的一个可重用的固定大小缓冲区，用于实现部分复制功能。根据 repl-backlog-size 参数控制，默认 1MB。对于复制积压缓冲区整个主节点只有一个，所有的从节点共享此缓冲区。因此可以设置较大的缓冲区空间，比如说 100MB，可以有效避免全量复制。有关复制积压缓冲区的详情可以看我的旧文章 <a href="https://mp.weixin.qq.com/s/0VVYTyAI1egfs2Fxcrme3A" target="_blank" rel="noopener">Redis 复制过程详解</a>。</p>
<p>AOF 重写缓冲区：这部分空间用于在 Redis AOF 重写期间保存最近的写入命令。AOF 重写缓冲区的大小用户无法控制，取决于 AOF 重写时间和写入命令量，不过一般都很小。有关 AOF 持久化的详情可以看我的旧文章 <a href="https://mp.weixin.qq.com/s/SODJ9Bvk-PLUpH0frzsstw" target="_blank" rel="noopener">Redis AOF 持久化详解</a>。</p>
<h4 id="Redis-内存碎片"><a href="#Redis-内存碎片" class="headerlink" title="Redis 内存碎片"></a>Redis 内存碎片</h4><p>Redis 默认的内存分配器采用 jemalloc，可选的分配器还有：glibc、tcmalloc。内存分配器为了更好地管理和重复利用内存，分配内存策略一般采用固定范围的内存块进行分配。具体的分配策略后续会具体讲解，但是 Redis 正常碎片率一般在 1.03 左右(为什么是这个值)。但是当存储的数据长度长度差异较大时，以下场景容易出现高内存碎片问题：</p>
<ul>
<li>频繁做更新操作，例如频繁对已经存在的键执行 append、setrange 等更新操作。</li>
<li>大量过期键删除，键对象过期删除后，释放的空间无法得到重复利用，导致碎片率上升。</li>
</ul>
<p>这部分内容我们后续再详细讲解 jemalloc，因为大量的框架都会使用内存分配器，比如说 Netty 等。</p>
<h3 id="子进程内存消耗"><a href="#子进程内存消耗" class="headerlink" title="子进程内存消耗"></a>子进程内存消耗</h3><p>子进程内存消耗主要指执行 AOF 重写 或者进行 RDB 保存时 Redis 创建的子进程内存消耗。Redis 执行 fork 操作产生的子进程内存占用量表现为与父进程相同，理论上需要一倍的物理内存来完成相应的操作。但是 Linux 具有写时复制技术 (copy-on-write)，父子进程会共享相同的物理内存页，当父进程处理写请求时会对需要修改的页复制出一份副本完成写操作，而子进程依然读取 fork 时整个父进程的内存快照。</p>
<p><img src="/images/19_1014/image6.png" alt=""></p>
<p>如上图所示，fork 时只拷贝 page table，也就是页表。只有等到某一页发生修改时，才真正进行页的复制。</p>
<p>但是 Linux Kernel 在 2.6.38 内存增加了 Transparent Huge Pages (THP) 机制，简单理解，它就是让页大小变大，本来一页为 4KB，开启 THP 机制后，一页大小为 2MB。它虽然可以加快 fork 速度( 要拷贝的页的数量减少 )，但是会导致 copy-on-write 复制内存页的单位从 4KB 增大为 2MB，如果父进程有大量写命令，会加重内存拷贝量，都是修改一个页的内容，但是页单位变大了，从而造成过度内存消耗。例如，以下两个执行 AOF 重写时的内存消耗日志：<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; 开启 THP
C * AOF rewrite: 1039 MB of memory used by copy-on-write
&#x2F;&#x2F; 关闭 THP
C * AOF rewrite: 9MB of memory used by copy-on-write
</code></pre></p>
<p>这两个日志出自同一个 Redis 进程，used_memory 总量是 1.5GB，子进程执行期间每秒写命令量都在 200 左右。当分别开启和关闭 THP 时，子进程内存消耗有天壤之别。所以，在高并发写的场景下开启 THP，子进程内存消耗可能是父进程的数倍，造成机器物理内存溢出。</p>
<p>所以说，Redis 产生的子进程并不需要消耗 1 倍的父进程内存，实际消耗根据期间写入命令量决定，所以需要预留一些内存防止溢出。并且建议关闭系统的 THP，防止 copy-on-write 期间内存过度消耗。不仅是 Redis，部署 MySQL 的机器一般也会关闭 THP。</p>
<p><img src="/images/logo.png" alt=""></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><p><a href="https://www.datadoghq.com/pdf/Understanding-the-Top-5-Redis-Performance-Metrics.pdf" target="_blank" rel="noopener">https://www.datadoghq.com/pdf/Understanding-the-Top-5-Redis-Performance-Metrics.pdf</a></p>
</li>
<li><p>Redis Administration <a href="https://redis.io/topics/admin" target="_blank" rel="noopener">https://redis.io/topics/admin</a></p>
</li>
</ul>

      <h3>关于图片和转载</h3>

      <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png"></a><br>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。

      转载时请注明原文链接，图片在使用时请保留图片中的全部内容，可适当缩放并在引用处附上图片所在的文章链接。

      <h3>关于评论和留言</h3>

      如果对本文 <a href="http://remcarpediem.net/article/516957d3/">一文了解 Redis 内存监控和内存消耗</a> 的内容有疑问，请在下面的评论系统中留言，谢谢。

      <blockquote>
        <p>原文链接：<a href="http://remcarpediem.net/article/516957d3/">一文了解 Redis 内存监控和内存消耗</a></p>

        <p>Follow: <a href="https://github.com/ztelur">Ztelur · GitHub</a></p>
      </blockquote>

    </section>
    <footer class="post-footer">
     
        <figure class="author-image">
          <a class="img" href="https://github.com/ztelur" style="background-image: url(https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1543337069412&di=609213db44c3240a091b26f82707da85&imgtype=0&src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F65b2fd9d9a84c14f4a712ed0d71b0fbb67dcbf2d.jpg)"><span class="hidden">历小冰's Picture</span></a>
        </figure>
     
      <section class="author">
        <h4><a href="https://github.com/ztelur">历小冰</a></h4>
        
        <p> 君子不器</p>
         
        <div class="author-meta">
          <span class="author-location icon-location"> NanJing</span> 
          <span class="author-link icon-link"><a href="http://remcarpediem.net"> 程序员历小冰</a></span> 
        </div>
</section>
      <!--<section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" href="http://twitter.com/share?url=http://remcarpediem.net/article/516957d3/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://remcarpediem.net/article/516957d3/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=http://remcarpediem.net/article/516957d3/" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section>-->
      
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<script>
    const gitalk = new Gitalk({
    clientID: 'ece2d2cd7c5f768a4c22',
    clientSecret: '1ad562557353b888b4b622239d45150c5df6d5ee',
    repo: 'blog-comments',
    owner: 'ztelur',
    admin: ['ztelur'],
    // labels: ['Gitalk', 'gitment'].concat(["{{ page.tags | join: '","'}}"]),
    // id: location.origin + location.pathname,
    id: md5("http://remcarpediem.net/article/516957d3/"),
    // facebook-like distraction free mode
    distractionFreeMode: false
});

gitalk.render('gitalk-container')
</script>

    </footer>
  </article>
</main>
<aside class="read-next">
 
    
    <a class="read-next-story no-cover" href="http://remcarpediem.net/article/6fc98a53/">
      <section class="post">
        <h2>Spring Cloud Netflix Feign 基础应用实战</h2>
        <p>
            
              &emsp;微服务是软件系统架构上的一种设计风格，它倡导将一个原本独立的服务系统分成多个小型服务，这些小型服务都在独立的进程中运行，通过各个小型服务之间的协作来实现原本独立系统的所有业务功能。小型服务基于多种跨进程的方式进行通信协作，而在Spring Cloud架构中比较常见的跨进程的方式是RESTful HTTP请求和RPC调用。
&emsp;RPC就是远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术 ......
            
          </p>
      </section>
    </a>
    
  


  
    
    <a class="read-next-story no-cover" href="http://remcarpediem.net/article/e66f8da0/">
      <section class="post">
        <h2>详解 Redis 内存管理机制和实现</h2>
        <p>
            
              Redis是一个基于内存的键值数据库，其内存管理是非常重要的。本文内存管理的内容包括：过期键的懒性删除和过期删除以及内存溢出控制策略。
最大内存限制Redis使用 maxmemory 参数限制最大可用内存，默认值为0，表示无限制。限制内存的目的主要 有： 

用于缓存场景，当超出内存上限 maxmemory 时使用 LRU 等删除策略释放空间。 
防止所用内存超过服务器物理内存。因为 Redis 默认情况下是会尽可能多使用服务器的内存， ......
            
          </p>
      </section>
    </a>
    
  
</aside>


  <footer class="site-footer clearfix">
 <section class="copyright"><a href="/">程序员历小冰</a> &copy; 2015 &bull; All rights reserved.</section>
 <section class="poweredby">Proudly published with <a class="icon-ghost" href="http://zespia.tw/hexo/"> Hexo</a></section>
</footer>

  </div>
  <script type="text/javascript" src="/js/jquery-2.0.3.min.js"></script>
<script>window.jQuery || document.write('<script src="js/jquery-2.0.3.min.js"><\/script>')</script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/prism.js"></script>
<script type="text/javascript" src="/js/toc.js"></script>

<script type="text/javascript">
(function($){
  var $postContent = $(".post-content");
  $postContent.fitVids();
})(jQuery);
</script>

<script type="text/javascript" src="/js/index.js"></script>

<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    var wrapAll = function(q) {
      $(q).each( function() {
        var $img = $(this),
            href = $img.attr('src');
        $img.wrap('<a rel="fancybox" href="' + href + '" title="' + $img.attr('alt') + '" class="link"></a>');
      });
    };
    wrapAll('.post-content img');
    wrapAll('.post-excerpt img');
    $('[rel="fancybox"]').fancybox();
  })(jQuery);
</script>





<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f089a91a688633df563c08899e3d893e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>



</body>
</html>
