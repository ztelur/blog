<!DOCTYPE html>
<html lang="Ch">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>Carpediem</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta property="og:type" content="website">
<meta property="og:title" content="Carpediem">
<meta property="og:url" content="http://remcarpediem.net/index.html">
<meta property="og:site_name" content="Carpediem">
<meta property="og:locale" content="Chinese">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Carpediem">
    

    
        <link rel="alternate" href="/" title="Carpediem" type="application/atom+xml">
    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Carpediem</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.png">
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile" class="profile-fixed">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.png">
            <h2 id="name">PPOffice</h2>
            <h3 id="title">Web Developer &amp; Designer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Harbin, China</span>
            <a id="follow" target="_blank" href="https://github.com/ppoffice/">FOLLOW</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                68
                <span>posts</span>
            </div>
            <div class="article-info-block">
                58
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="http://github.com/ppoffice/hexo-theme-icarus" target="_blank" title="github" class="tooltip">
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="twitter" class="tooltip">
                            <i class="fa fa-twitter"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="facebook" class="tooltip">
                            <i class="fa fa-facebook"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="dribbble" class="tooltip">
                            <i class="fa fa-dribbble"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="rss" class="tooltip">
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-基于Redis和Lua的分布式限流" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2019/04/06/基于Redis和Lua的分布式限流/">基于Redis和Lua的分布式限流</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2019/04/06/基于Redis和Lua的分布式限流/">
            <time datetime="2019-04-06T02:51:31.000Z" itemprop="datePublished">2019-04-06</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/分布式/">分布式</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/限流/">限流</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;Java单机限流可以使用AtomicInteger，RateLimiter或Semaphore来实现，但是上述方案都不支持集群限流。集群限流的应用场景有两个，一个是网关，常用的方案有Nginx限流和Spring Cloud Gateway，另一个场景是与外部或者下游服务接口的交互，因为接口限制必须进行限流。</p>
<p>&emsp;本文的主要内容为：</p>
<ul>
<li>Redis和Lua的使用场景和注意事项，特别是KEY映射的问题</li>
<li>Spring Cloud Gateway中限流的实现</li>
</ul>
<h3 id="集群限流的难点"><a href="#集群限流的难点" class="headerlink" title="集群限流的难点"></a>集群限流的难点</h3><p>&emsp;在上篇Guava RateLimiter的分析<a href="[https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483781&amp;idx=1&amp;sn=05a2de89cf9b2185292708bcb4431d09&amp;chksm=fc04c5e5cb734cf32b0ea6bc85f58e2b9ddfa78586dd06246089aec01335ab0e205b7d5df08d&amp;token=1485948874&amp;lang=zh_CN#rd](https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483781&amp;idx=1&amp;sn=05a2de89cf9b2185292708bcb4431d09&amp;chksm=fc04c5e5cb734cf32b0ea6bc85f58e2b9ddfa78586dd06246089aec01335ab0e205b7d5df08d&amp;token=1485948874&amp;lang=zh_CN#rd">文章</a><br>)中，我们学习了令牌桶限流算法的原理，下面我们就探讨一下，如果将<code>RateLimiter</code>扩展，让它支持集群限流，会遇到哪些问题。</p>
<p>&emsp;<code>RateLimiter</code>会维护两个关键的参数<code>nextFreeTicketMicros</code>和<code>storedPermits</code>，它们分别是下一次填充时间和当前存储的令牌数。当<code>RateLimiter</code>的<code>acquire</code>函数被调用时，也就是有线程希望获取令牌时，<code>RateLimiter</code>会对比当前时间和<code>nextFreeTicketMicros</code>，根据二者差距，刷新<code>storedPermits</code>，然后再判断更新后的<code>storedPermits</code>是否足够，足够则直接返回，否则需要等待直到令牌足够(Guava RateLimiter的实现比较特殊，并不是当前获取令牌的线程等待，而是下一个获取令牌的线程等待)。</p>
<p>&emsp;由于要支持集群限流，所以<code>nextFreeTicketMicros</code>和<code>storedPermits</code>这两个参数不能只存在JVM的内存中，必须有一个集中式存储的地方。而且，由于算法要先获取两个参数的值，计算后在更新两个数值，这里涉及到竞态限制，必须要处理并发问题。</p>
<p>&emsp;集群限流由于会面对相比单机更大的流量冲击，所以一般不会进行线程等待，而是直接进行丢弃，因为如果让拿不到令牌的线程进行睡眠，会导致大量的线程堆积，线程持有的资源也不会释放，反而容易拖垮服务器。</p>
<h3 id="Redis和Lua"><a href="#Redis和Lua" class="headerlink" title="Redis和Lua"></a>Redis和Lua</h3><p><img src="https://upload-images.jianshu.io/upload_images/623378-d5998d8f9e9ffebd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="redis和lua"></p>
<p>&emsp;分布式限流本质上是一个集群并发问题，Redis单进程单线程的特性，天然可以解决分布式集群的并发问题。所以很多分布式限流都基于Redis，比如说Spring Cloud的网关组件Gateway。</p>
<p>&emsp;Redis执行Lua脚本会以原子性方式进行，单线程的方式执行脚本，在执行脚本时不会再执行其他脚本或命令。并且，Redis只要开始执行Lua脚本，就会一直执行完该脚本再进行其他操作，所以<strong>Lua脚本中不能进行耗时操作</strong>。使用Lua脚本，还可以减少与Redis的交互，减少网络请求的次数。</p>
<p>&emsp;Redis中使用Lua脚本的场景有很多，比如说分布式锁，限流，秒杀等，总结起来，下面两种情况下可以使用Lua脚本:</p>
<ul>
<li>使用 Lua 脚本实现原子性操作的CAS，避免不同客户端先读Redis数据，经过计算后再写数据造成的并发问题。</li>
<li>前后多次请求的结果有依赖时，使用 Lua 脚本将多个请求整合为一个请求。</li>
</ul>
<p>&emsp;但是使用Lua脚本也有一些注意事项：</p>
<ul>
<li>要保证安全性，在 Lua 脚本中不要定义自己的全局变量，以免污染 Redis内嵌的Lua环境。因为Lua脚本中你会使用一些预制的全局变量，比如说<code>redis.call()</code></li>
<li>要注意 Lua 脚本的时间复杂度，Redis 的单线程同样会阻塞在 Lua 脚本的执行中。</li>
<li>使用 Lua 脚本实现原子操作时，要注意如果 Lua 脚本报错，之前的命令无法回滚，这和Redis所谓的事务机制是相同的。</li>
<li>一次发出多个 Redis 请求，但请求前后无依赖时，使用 pipeline，比 Lua 脚本方便。</li>
<li>Redis要求单个Lua脚本操作的key必须在同一个Redis节点上。解决方案可以看下文对Gateway原理的解析。</li>
</ul>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>&emsp;Redis虽然以单进程单线程模型进行操作，但是它的性能却十分优秀。总结来说，主要是因为:</p>
<ul>
<li>绝大部分请求是纯粹的内存操作</li>
<li>采用单线程,避免了不必要的上下文切换和竞争条件</li>
<li>内部实现采用非阻塞IO和epoll，基于epoll自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</li>
</ul>
<p>&emsp;所以，在集群限流时使用Redis和Lua的组合并不会引入过多的性能损耗。我们下面就简单的测试一下，顺便熟悉一下涉及的Redis命令。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike"># test.lua脚本的内容
local test = redis.call(&quot;get&quot;, &quot;test&quot;)
local time = redis.call(&quot;get&quot;, &quot;time&quot;)
redis.call(&quot;setex&quot;, &quot;test&quot;, 10, &quot;xx&quot;)
redis.call(&quot;setex&quot;, &quot;time&quot;, 10, &quot;xx&quot;)
return {test, time}

# 将脚本导入redis，之后调用不需再传递脚本内容
redis-cli -a 082203 script load &quot;$(cat test.lua)&quot;
&quot;b978c97518ae7c1e30f246d920f8e3c321c76907&quot;
# 使用redis-benchmark和evalsha来执行lua脚本
redis-benchmark -a 082203 -n 1000000 evalsha b978c97518ae7c1e30f246d920f8e3c321c76907 0 
======
1000000 requests completed in 20.00 seconds
50 parallel clients
3 bytes payload
keep alive: 1

93.54% &lt;= 1 milliseconds
99.90% &lt;= 2 milliseconds
99.97% &lt;= 3 milliseconds
99.98% &lt;= 4 milliseconds
99.99% &lt;= 5 milliseconds
100.00% &lt;= 6 milliseconds
100.00% &lt;= 7 milliseconds
100.00% &lt;= 7 milliseconds
49997.50 requests per second
</code></pre>
<p>&emsp;通过上述简单的测试，我们可以发现本机情况下，使用Redis执行Lua脚本的性能极其优秀，一百万次执行，99.99%在5毫秒以下。</p>
<p>&emsp;本来想找一下官方的性能数据，但是针对Redis + Lua的性能数据较少，只找到了几篇个人博客，感兴趣的同学可以去探索。<a href="https://www.fuwuqizhijia.com/redis/201704/60935.html" target="_blank" rel="noopener">这篇文章</a>有Lua和zadd的性能比较(具体数据请看原文，链接缺失的话，请看文末)。</p>
<blockquote>
<p>以上lua脚本的性能大概是zadd的70%-80%，但是在可接受的范围内，在生产环境可以使用。负载大概是zadd的1.5-2倍，网络流量相差不大，IO是zadd的3倍，可能是开启了AOF，执行了三次操作。</p>
</blockquote>
<h3 id="Spring-Cloud-Gateway的限流实现"><a href="#Spring-Cloud-Gateway的限流实现" class="headerlink" title="Spring Cloud Gateway的限流实现"></a>Spring Cloud Gateway的限流实现</h3><p><img src="https://upload-images.jianshu.io/upload_images/623378-2aba7e8ececc8639.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Spring Cloud"></p>
<p>&emsp;<code>Gateway</code>是微服务架构<code>Spring Cloud</code>的网关组件，它基于Redis和Lua实现了令牌桶算法的限流功能，下面我们就来看一下它的原理和细节吧。</p>
<p>&emsp;<code>Gateway</code>基于Filter模式，提供了限流过滤器<code>RequestRateLimiterGatewayFilterFactory</code>。只需在其配置文件中进行配置，就可以使用。具体的配置感兴趣的同学自行学习，我们直接来看它的实现。</p>
<p>&emsp;<code>RequestRateLimiterGatewayFilterFactory</code>依赖<code>RedisRateLimiter</code>的<code>isAllowed</code>函数来判断一个请求是否要被限流抛弃。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public Mono&lt;Response&gt; isAllowed(String routeId, String id) {
        &#x2F;&#x2F;routeId是ip地址，id是使用KeyResolver获取的限流维度id，比如说基于uri,IP或者用户等等。
	Config routeConfig = loadConfiguration(routeId);
	&#x2F;&#x2F; 每秒能够通过的请求数
	int replenishRate = routeConfig.getReplenishRate();
	&#x2F;&#x2F; 最大流量
	int burstCapacity = routeConfig.getBurstCapacity();
	try {
	    &#x2F;&#x2F; 组装Lua脚本的KEY
		List&lt;String&gt; keys = getKeys(id);
		&#x2F;&#x2F; 组装Lua脚本需要的参数，1是指一次获取一个令牌
		List&lt;String&gt; scriptArgs = Arrays.asList(replenishRate + &quot;&quot;,
				burstCapacity + &quot;&quot;, Instant.now().getEpochSecond() + &quot;&quot;, &quot;1&quot;);
		&#x2F;&#x2F; 调用Redis，tokens_left = redis.eval(SCRIPT, keys, args)
		Flux&lt;List&lt;Long&gt;&gt; flux = this.redisTemplate.execute(this.script, keys,
				scriptArgs);
	..... &#x2F;&#x2F; 省略			
}
static List&lt;String&gt; getKeys(String id) {
	String prefix = &quot;request_rate_limiter.{&quot; + id;
	String tokenKey = prefix + &quot;}.tokens&quot;;
	String timestampKey = prefix + &quot;}.timestamp&quot;;
	return Arrays.asList(tokenKey, timestampKey);
}				
</code></pre>
<p>&emsp;需要注意的是<code>getKeys</code>函数的prefix包含了”{id}”，这是为了解决Redis集群键值映射问题。Redis的KeySlot算法中，如果key包含{}，就会使用第一个{}内部的字符串作为hash key，这样就可以保证拥有同样{}内部字符串的key就会拥有相同slot。Redis要求单个Lua脚本操作的key必须在同一个节点上，但是Cluster会将数据自动分布到不同的节点，使用这种方法就解决了上述的问题。</p>
<p>&emsp;然后我们来看一下Lua脚本的实现，该脚本就在Gateway项目的resource文件夹下。它就是如同<code>Guava</code>的<code>RateLimiter</code>一样，实现了令牌桶算法，只不过不在需要进行线程休眠，而是直接返回是否能够获取。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">local tokens_key = KEYS[1]   -- request_rate_limiter.${id}.tokens 令牌桶剩余令牌数的KEY值
local timestamp_key = KEYS[2] -- 令牌桶最后填充令牌时间的KEY值

local rate = tonumber(ARGV[1])  -- replenishRate 令令牌桶填充平均速率
local capacity = tonumber(ARGV[2]) -- burstCapacity 令牌桶上限
local now = tonumber(ARGV[3]) -- 得到从 1970-01-01 00:00:00 开始的秒数
local requested = tonumber(ARGV[4]) -- 消耗令牌数量，默认 1 

local fill_time = capacity&#x2F;rate   -- 计算令牌桶填充满令牌需要多久时间
local ttl = math.floor(fill_time*2)  -- *2 保证时间充足


local last_tokens = tonumber(redis.call(&quot;get&quot;, tokens_key)) 
-- 获得令牌桶剩余令牌数
if last_tokens == nil then  -- 第一次时，没有数值，所以桶时满的
  last_tokens = capacity
end

local last_refreshed = tonumber(redis.call(&quot;get&quot;, timestamp_key)) 
-- 令牌桶最后填充令牌时间
if last_refreshed == nil then
  last_refreshed = 0
end

local delta = math.max(0, now-last_refreshed)  
-- 获取距离上一次刷新的时间间隔
local filled_tokens = math.min(capacity, last_tokens+(delta*rate)) 
-- 填充令牌，计算新的令牌桶剩余令牌数 填充不超过令牌桶令牌上限。

local allowed = filled_tokens &gt;= requested      
local new_tokens = filled_tokens
local allowed_num = 0
if allowed then
-- 若成功，令牌桶剩余令牌数(new_tokens) 减消耗令牌数( requested )，并设置获取成功( allowed_num = 1 ) 。
  new_tokens = filled_tokens - requested
  allowed_num = 1
end       

-- 设置令牌桶剩余令牌数( new_tokens ) ，令牌桶最后填充令牌时间(now) ttl是超时时间？
redis.call(&quot;setex&quot;, tokens_key, ttl, new_tokens)
redis.call(&quot;setex&quot;, timestamp_key, ttl, now)

-- 返回数组结果
return { allowed_num, new_tokens }
</code></pre>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;Redis的主从异步复制机制可能丢失数据，出现限流流量计算不准确的情况，当然限流毕竟不同于分布式锁这种场景，对于结果的精确性要求不是很高，即使多流入一些流量，也不会影响太大。<br>&emsp;正如Martin在他质疑Redis分布式锁RedLock文章中说的，Redis的数据丢弃了也无所谓时再使用Redis存储数据。</p>
<blockquote>
<p>I think it’s a good fit in situations where you want to share some transient, approximate, fast-changing data between servers, and where it’s not a big deal if you occasionally lose that data for whatever reason</p>
</blockquote>
<p>&emsp;接下来我们回来学习阿里开源的分布式限流组件<code>sentinel</code>，希望大家持续关注。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-7d960275042f309d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.cnblogs.com/itrena/p/5926878.html" target="_blank" rel="noopener">https://www.cnblogs.com/itrena/p/5926878.html</a></li>
<li>压测的文章：<a href="https://www.fuwuqizhijia.com/redis/201704/60935.html" target="_blank" rel="noopener">https://www.fuwuqizhijia.com/redis/201704/60935.html</a></li>
<li><a href="https://blog.csdn.net/forezp/article/details/85081162" target="_blank" rel="noopener">https://blog.csdn.net/forezp/article/details/85081162</a></li>
<li><a href="https://blog.csdn.net/xixingzhe2/article/details/86167859" target="_blank" rel="noopener">https://blog.csdn.net/xixingzhe2/article/details/86167859</a></li>
<li>Matin RedLock <a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a></li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/2019/04/06/基于Redis和Lua的分布式限流/" data-id="cju4wk8dx004zez669cpawvlg" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-超详细的Guava-RateLimiter限流原理解析" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2019/03/30/超详细的Guava-RateLimiter限流原理解析/">超详细的Guava RateLimiter限流原理解析</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2019/03/30/超详细的Guava-RateLimiter限流原理解析/">
            <time datetime="2019-03-30T05:33:07.000Z" itemprop="datePublished">2019-03-30</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/限流/">限流</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;限流是保护高并发系统的三把利器之一，另外两个是缓存和降级。限流在很多场景中用来限制并发和请求量，比如说秒杀抢购，保护自身系统和下游系统不被巨型流量冲垮等。</p>
<p>&emsp;限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务或进行流量整形。</p>
<p>&emsp;常用的限流方式和场景有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数，Java的Semaphore也可以实现）、限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</p>
<p>&emsp;比如说，我们需要限制方法被调用的并发数不能超过100（同一时间并发数），则我们可以用信号量<code>Semaphore</code>实现。可如果我们要限制方法在一段时间内平均被调用次数不超过100，则需要使用<code>RateLimiter</code>。</p>
<h3 id="限流的基础算法"><a href="#限流的基础算法" class="headerlink" title="限流的基础算法"></a>限流的基础算法</h3><p>&emsp;我们先来讲解一下两个限流相关的基本算法：漏桶算法和令牌桶算法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-1a91321c15f084d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="漏桶算法"></p>
<p>&emsp;从上图中，我们可以看到，就像一个漏斗一样，进来的水量就好像访问流量一样，而出去的水量就像是我们的系统处理请求一样。当访问流量过大时，这个漏斗中就会积水，如果水太多了就会溢出。</p>
<p>&emsp;漏桶算法的实现往往依赖于队列，请求到达如果队列未满则直接放入队列，然后有一个处理器按照固定频率从队列头取出请求进行处理。如果请求量大，则会导致队列满，那么新来的请求就会被抛弃。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-d8ca6373e1fbddae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="漏桶算法示意图"></p>
<p>令牌桶算法则是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。桶中存放的令牌数有最大上限，超出之后就被丢弃或者拒绝。当流量或者网络请求到达时，每个请求都要获取一个令牌，如果能够获取到，则直接处理，并且令牌桶删除一个令牌。如果获取不同，该请求就要被限流，要么直接丢弃，要么在缓冲区等待。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-992f9c0b0ab82143.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="令牌桶算法示意图"></p>
<p>令牌桶和漏桶对比：</p>
<ul>
<li><p>令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求；漏桶则是按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝；</p>
</li>
<li><p>令牌桶限制的是平均流入速率，允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌；漏桶限制的是常量流出速率，即流出速率是一个固定常量值，比如都是1的速率流出，而不能一次是1，下次又是2，从而平滑突发流入速率；</p>
</li>
<li><p>令牌桶允许一定程度的突发，而漏桶主要目的是平滑流出速率；</p>
</li>
</ul>
<h3 id="Guava-RateLimiter"><a href="#Guava-RateLimiter" class="headerlink" title="Guava RateLimiter"></a>Guava RateLimiter</h3><p>&emsp;<code>Guava</code>是Java领域优秀的开源项目，它包含了Google在Java项目中使用一些核心库，包含集合(Collections)，缓存(Caching)，并发编程库(Concurrency)，常用注解(Common annotations)，String操作，I/O操作方面的众多非常实用的函数。<br>&emsp;Guava的<code>RateLimiter</code>提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-44407d9b565e50f7.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类图"></p>
<p>&emsp;<code>RateLimiter</code>的类图如上所示，其中<code>RateLimiter</code>是入口类，它提供了两套工厂方法来创建出两个子类。这很符合《Effective Java》中的用静态工厂方法代替构造函数的建议，毕竟该书的作者也正是Guava库的主要维护者，二者配合”食用”更佳。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; RateLimiter提供了两个工厂方法，最终会调用下面两个函数，生成RateLimiter的两个子类。
static RateLimiter create(SleepingStopwatch stopwatch, double permitsPerSecond) {
    RateLimiter rateLimiter = new SmoothBursty(stopwatch, 1.0 &#x2F;* maxBurstSeconds *&#x2F;);
    rateLimiter.setRate(permitsPerSecond);
    return rateLimiter;
}
static RateLimiter create(
    SleepingStopwatch stopwatch, double permitsPerSecond, long warmupPeriod, TimeUnit unit,
    double coldFactor) {
    RateLimiter rateLimiter = new SmoothWarmingUp(stopwatch, warmupPeriod, unit, coldFactor);
    rateLimiter.setRate(permitsPerSecond);
    return rateLimiter;
}
</code></pre>
<h4 id="平滑突发限流"><a href="#平滑突发限流" class="headerlink" title="平滑突发限流"></a>平滑突发限流</h4><p>&emsp;使用<code>RateLimiter</code>的静态方法创建一个限流器，设置每秒放置的令牌数为5个。返回的RateLimiter对象可以保证1秒内不会给超过5个令牌，并且以固定速率进行放置，达到平滑输出的效果。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public void testSmoothBursty() {
    RateLimiter r = RateLimiter.create(5);
    while (true) {
      System.out.println(&quot;get 1 tokens: &quot; + r.acquire() + &quot;s&quot;);
    }
    &#x2F;**
     * output: 基本上都是0.2s执行一次，符合一秒发放5个令牌的设定。
     * get 1 tokens: 0.0s 
     * get 1 tokens: 0.182014s
     * get 1 tokens: 0.188464s
     * get 1 tokens: 0.198072s
     * get 1 tokens: 0.196048s
     * get 1 tokens: 0.197538s
     * get 1 tokens: 0.196049s
     *&#x2F;
}
</code></pre></p>
<p>&emsp;<code>RateLimiter</code>使用令牌桶算法，会进行令牌的累积，如果获取令牌的频率比较低，则不会导致等待，直接获取令牌。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public void testSmoothBursty2() {
    RateLimiter r = RateLimiter.create(2);
    while (true)
    {
      System.out.println(&quot;get 1 tokens: &quot; + r.acquire(1) + &quot;s&quot;);
      try {
        Thread.sleep(2000);
      } catch (Exception e) {}
      System.out.println(&quot;get 1 tokens: &quot; + r.acquire(1) + &quot;s&quot;);
      System.out.println(&quot;get 1 tokens: &quot; + r.acquire(1) + &quot;s&quot;);
      System.out.println(&quot;get 1 tokens: &quot; + r.acquire(1) + &quot;s&quot;);
      System.out.println(&quot;end&quot;);
      &#x2F;**
       * output:
       * get 1 tokens: 0.0s
       * get 1 tokens: 0.0s
       * get 1 tokens: 0.0s
       * get 1 tokens: 0.0s
       * end
       * get 1 tokens: 0.499796s
       * get 1 tokens: 0.0s
       * get 1 tokens: 0.0s
       * get 1 tokens: 0.0s
       *&#x2F;
    }
}
</code></pre>
<p>&emsp;<code>RateLimiter</code>由于会累积令牌，所以可以应对突发流量。在下面代码中，有一个请求会直接请求5个令牌，但是由于此时令牌桶中有累积的令牌，足以快速响应。<br>&emsp;<code>RateLimiter</code>在没有足够令牌发放时，采用滞后处理的方式，也就是前一个请求获取令牌所需等待的时间由下一次请求来承受，也就是代替前一个请求进行等待。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public void testSmoothBursty3() {
    RateLimiter r = RateLimiter.create(5);
    while (true)
    {
      System.out.println(&quot;get 5 tokens: &quot; + r.acquire(5) + &quot;s&quot;);
      System.out.println(&quot;get 1 tokens: &quot; + r.acquire(1) + &quot;s&quot;);
      System.out.println(&quot;get 1 tokens: &quot; + r.acquire(1) + &quot;s&quot;);
      System.out.println(&quot;get 1 tokens: &quot; + r.acquire(1) + &quot;s&quot;);
      System.out.println(&quot;end&quot;);
      &#x2F;**
       * output:
       * get 5 tokens: 0.0s
       * get 1 tokens: 0.996766s 滞后效应，需要替前一个请求进行等待
       * get 1 tokens: 0.194007s
       * get 1 tokens: 0.196267s
       * end
       * get 5 tokens: 0.195756s
       * get 1 tokens: 0.995625s 滞后效应，需要替前一个请求进行等待
       * get 1 tokens: 0.194603s
       * get 1 tokens: 0.196866s
       *&#x2F;
    }
}
</code></pre></p>
<h4 id="平滑预热限流"><a href="#平滑预热限流" class="headerlink" title="平滑预热限流"></a>平滑预热限流</h4><p>&emsp;<code>RateLimiter</code>的<code>SmoothWarmingUp</code>是带有预热期的平滑限流，它启动后会有一段预热期，逐步将分发频率提升到配置的速率。<br>&emsp;比如下面代码中的例子，创建一个平均分发令牌速率为2，预热期为3分钟。由于设置了预热时间是3秒，令牌桶一开始并不会0.5秒发一个令牌，而是形成一个平滑线性下降的坡度，频率越来越高，在3秒钟之内达到原本设置的频率，以后就以固定的频率输出。这种功能适合系统刚启动需要一点时间来“热身”的场景。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public void testSmoothwarmingUp() {
    RateLimiter r = RateLimiter.create(2, 3, TimeUnit.SECONDS);
    while (true)
    {
      System.out.println(&quot;get 1 tokens: &quot; + r.acquire(1) + &quot;s&quot;);
      System.out.println(&quot;get 1 tokens: &quot; + r.acquire(1) + &quot;s&quot;);
      System.out.println(&quot;get 1 tokens: &quot; + r.acquire(1) + &quot;s&quot;);
      System.out.println(&quot;get 1 tokens: &quot; + r.acquire(1) + &quot;s&quot;);
      System.out.println(&quot;end&quot;);
      &#x2F;**
       * output:
       * get 1 tokens: 0.0s
       * get 1 tokens: 1.329289s
       * get 1 tokens: 0.994375s
       * get 1 tokens: 0.662888s  上边三次获取的时间相加正好为3秒
       * end
       * get 1 tokens: 0.49764s  正常速率0.5秒一个令牌
       * get 1 tokens: 0.497828s
       * get 1 tokens: 0.49449s
       * get 1 tokens: 0.497522s
       *&#x2F;
    }
}
</code></pre>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>&emsp;看完了<code>RateLimiter</code>的基本使用示例后，我们来学习一下它的实现原理。先了解一下几个比较重要的成员变量的含义。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F;SmoothRateLimiter.java
&#x2F;&#x2F;当前存储令牌数
double storedPermits;
&#x2F;&#x2F;最大存储令牌数
double maxPermits;
&#x2F;&#x2F;添加令牌时间间隔
double stableIntervalMicros;
&#x2F;**
 * 下一次请求可以获取令牌的起始时间
 * 由于RateLimiter允许预消费，上次请求预消费令牌后
 * 下次请求需要等待相应的时间到nextFreeTicketMicros时刻才可以获取令牌
 *&#x2F;
private long nextFreeTicketMicros = 0L;
</code></pre></p>
<h4 id="平滑突发限流-1"><a href="#平滑突发限流-1" class="headerlink" title="平滑突发限流"></a>平滑突发限流</h4><p>&emsp;<code>RateLimiter</code>的原理就是每次调用<code>acquire</code>时用当前时间和<code>nextFreeTicketMicros</code>进行比较，根据二者的间隔和添加单位令牌的时间间隔<code>stableIntervalMicros</code>来刷新存储令牌数<code>storedPermits</code>。然后acquire会进行休眠，直到<code>nextFreeTicketMicros</code>。</p>
<p>&emsp;<code>acquire</code>函数如下所示，它会调用<code>reserve</code>函数计算获取目标令牌数所需等待的时间，然后使用<code>SleepStopwatch</code>进行休眠，最后返回等待时间。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public double acquire(int permits) {
    &#x2F;&#x2F; 计算获取令牌所需等待的时间
    long microsToWait = reserve(permits);
    &#x2F;&#x2F; 进行线程sleep
    stopwatch.sleepMicrosUninterruptibly(microsToWait);
    return 1.0 * microsToWait &#x2F; SECONDS.toMicros(1L);
}
final long reserve(int permits) {
    checkPermits(permits);
    &#x2F;&#x2F; 由于涉及并发操作，所以使用synchronized进行并发操作
    synchronized (mutex()) {
      return reserveAndGetWaitLength(permits, stopwatch.readMicros());
    }
}
final long reserveAndGetWaitLength(int permits, long nowMicros) {
    &#x2F;&#x2F; 计算从当前时间开始，能够获取到目标数量令牌时的时间
    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);
    &#x2F;&#x2F; 两个时间相减，获得需要等待的时间
    return max(momentAvailable - nowMicros, 0);
}
</code></pre></p>
<p>&emsp;<code>reserveEarliestAvailable</code>是刷新令牌数和下次获取令牌时间<code>nextFreeTicketMicros</code>的关键函数。它有三个步骤，一是调用<code>resync</code>函数增加令牌数，二是计算预支付令牌所需额外等待的时间，三是更新下次获取令牌时间<code>nextFreeTicketMicros</code>和存储令牌数<code>storedPermits</code>。</p>
<p>&emsp;这里涉及<code>RateLimiter</code>的一个特性，也就是可以预先支付令牌，并且所需等待的时间在下次获取令牌时再实际执行。详细的代码逻辑的解释请看注释。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">final long reserveEarliestAvailable(int requiredPermits, long nowMicros) {
    &#x2F;&#x2F; 刷新令牌数，相当于每次acquire时在根据时间进行令牌的刷新
    resync(nowMicros);
    long returnValue = nextFreeTicketMicros;
    &#x2F;&#x2F; 获取当前已有的令牌数和需要获取的目标令牌数进行比较，计算出可以目前即可得到的令牌数。
    double storedPermitsToSpend = min(requiredPermits, this.storedPermits);
    &#x2F;&#x2F; freshPermits是需要预先支付的令牌，也就是目标令牌数减去目前即可得到的令牌数
    double freshPermits = requiredPermits - storedPermitsToSpend;
    &#x2F;&#x2F; 因为会突然涌入大量请求，而现有令牌数又不够用，因此会预先支付一定的令牌数
    &#x2F;&#x2F; waitMicros即是产生预先支付令牌的数量时间，则将下次要添加令牌的时间应该计算时间加上watiMicros
    long waitMicros = storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)
        + (long) (freshPermits * stableIntervalMicros);
    &#x2F;&#x2F; storedPermitsToWaitTime在SmoothWarmingUp和SmoothBuresty的实现不同，用于实现预热缓冲期
    &#x2F;&#x2F; SmoothBuresty的storedPermitsToWaitTime直接返回0，所以watiMicros就是预先支付的令牌所需等待的时间
    try {
      &#x2F;&#x2F; 更新nextFreeTicketMicros,本次预先支付的令牌所需等待的时间让下一次请求来实际等待。
      this.nextFreeTicketMicros = LongMath.checkedAdd(nextFreeTicketMicros, waitMicros);
    } catch (ArithmeticException e) {
      this.nextFreeTicketMicros = Long.MAX_VALUE;
    }
    &#x2F;&#x2F; 更新令牌数，最低数量为0
    this.storedPermits -= storedPermitsToSpend;
    &#x2F;&#x2F; 返回旧的nextFreeTicketMicros数值，无需为预支付的令牌多加等待时间。
    return returnValue;
}
&#x2F;&#x2F; SmoothBurest
long storedPermitsToWaitTime(double storedPermits, double permitsToTake) {
    return 0L;
}
</code></pre></p>
<p>&emsp;<code>resync</code>函数用于增加存储令牌，核心逻辑就是<code>(nowMicros - nextFreeTicketMicros) / stableIntervalMicros</code>。当前时间大于<code>nextFreeTicketMicros</code>时进行刷新，否则直接返回。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">void resync(long nowMicros) {
    &#x2F;&#x2F; 当前时间晚于nextFreeTicketMicros，所以刷新令牌和nextFreeTicketMicros
    if (nowMicros &gt; nextFreeTicketMicros) {
      &#x2F;&#x2F; coolDownIntervalMicros函数获取每机秒生成一个令牌，SmoothWarmingUp和SmoothBuresty的实现不同
      &#x2F;&#x2F; SmoothBuresty的coolDownIntervalMicros直接返回stableIntervalMicros
      &#x2F;&#x2F; 当前时间减去要更新令牌的时间获取时间间隔，再除以添加令牌时间间隔获取这段时间内要添加的令牌数
      storedPermits = min(maxPermits,
          storedPermits
            + (nowMicros - nextFreeTicketMicros) &#x2F; coolDownIntervalMicros());
      nextFreeTicketMicros = nowMicros;
    }
    &#x2F;&#x2F; 如果当前时间早于nextFreeTicketMicros，则获取令牌的线程要一直等待到nextFreeTicketMicros,该线程获取令牌所需
    &#x2F;&#x2F; 额外等待的时间由下一次获取的线程来代替等待。
}
double coolDownIntervalMicros() {
    return stableIntervalMicros;
}
</code></pre>
<p>&emsp;下面我们举个例子，让大家更好的理解<code>resync</code>和<code>reserveEarliestAvailable</code>函数的逻辑。</p>
<p>&emsp;比如<code>RateLimiter</code>的<code>stableIntervalMicros</code>为500，也就是1秒发两个令牌，storedPermits为0，nextFreeTicketMicros为155391849<code>57</code>48。线程一acquire(2)，当前时间为155391849<code>62</code>48，首先<code>resync</code>函数计算，(1553918496248 - 1553918495748)/500 = 1，所以当前可获取令牌数为1，但是由于可以预支付，所以nextFreeTicketMicros= nextFreeTicketMicro + 1 * 500 = 155391849<code>67</code>48。线程一无需等待。</p>
<p>&emsp;紧接着，线程二也来acquire(2)，首先<code>resync</code>函数发现当前时间早于<code>nextFreeTicketMicros</code>，所以无法增加令牌数，所以需要预支付2个令牌，nextFreeTicketMicros= nextFreeTicketMicro + 2 * 500 = 155391849<code>77</code>48。线程二需要等待155391849<code>67</code>48时刻，也就是线程一获取时计算的nextFreeTicketMicros时刻。同样的，线程三获取令牌时也需要等待到线程二计算的nextFreeTicketMicros时刻。</p>
<h4 id="平滑预热限流-1"><a href="#平滑预热限流-1" class="headerlink" title="平滑预热限流"></a>平滑预热限流</h4><p>&emsp;上述就是平滑突发限流RateLimiter的实现，下面我们来看一下加上预热缓冲期的实现原理。<br>&emsp;<code>SmoothWarmingUp</code>实现预热缓冲的关键在于其分发令牌的速率会随时间和令牌数而改变，速率会先慢后快。表现形式如下图所示，令牌刷新的时间间隔由长逐渐变短。等存储令牌数从maxPermits到达thresholdPermits时，发放令牌的时间价格也由coldInterval降低到了正常的stableInterval。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-2a6a0ff51b95cd29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>&emsp;<code>SmoothWarmingUp</code>的相关代码如下所示，相关的逻辑都写在注释中。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; SmoothWarmingUp，等待时间就是计算上图中梯形或者正方形的面积。
long storedPermitsToWaitTime(double storedPermits, double permitsToTake) {
    &#x2F;**
    * 当前permits超出阈值的部分
    *&#x2F;
    double availablePermitsAboveThreshold = storedPermits - thresholdPermits;
    long micros = 0;
    &#x2F;**
    * 如果当前存储的令牌数超出thresholdPermits
    *&#x2F;
    if (availablePermitsAboveThreshold &gt; 0.0) {
    &#x2F;**
     * 在阈值右侧并且需要被消耗的令牌数量
     *&#x2F;
    double permitsAboveThresholdToTake = min(availablePermitsAboveThreshold, permitsToTake);

    &#x2F;**
        * 梯形的面积
        *
        * 高 * (顶 * 底) &#x2F; 2
        *
        * 高是 permitsAboveThresholdToTake 也就是右侧需要消费的令牌数
        * 底 较长 permitsToTime(availablePermitsAboveThreshold)
        * 顶 较短 permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake)
        *&#x2F;
    micros = (long) (permitsAboveThresholdToTake
        * (permitsToTime(availablePermitsAboveThreshold)
        + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake)) &#x2F; 2.0);
    &#x2F;**
        * 减去已经获取的在阈值右侧的令牌数
        *&#x2F;
    permitsToTake -= permitsAboveThresholdToTake;
    }
    &#x2F;**
    * 平稳时期的面积，正好是长乘宽
    *&#x2F;
    micros += (stableIntervalMicros * permitsToTake);
    return micros;
}

double coolDownIntervalMicros() {
    &#x2F;**
    * 每秒增加的令牌数为 warmup时间&#x2F;maxPermits. 这样的话，在warmuptime时间内，就就增张的令牌数量
    * 为 maxPermits
    *&#x2F;
    return warmupPeriodMicros &#x2F; maxPermits;
}
</code></pre></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp; <code>RateLimiter</code>只能用于单机的限流，如果想要集群限流，则需要引入<code>redis</code>或者阿里开源的<code>sentinel</code>中间件，请大家继续关注。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-7d960275042f309d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://jinnianshilongnian.iteye.com/blog/2305117" target="_blank" rel="noopener">https://jinnianshilongnian.iteye.com/blog/2305117</a></li>
<li><a href="https://segmentfault.com/a/1190000012875897" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012875897</a></li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/2019/03/30/超详细的Guava-RateLimiter限流原理解析/" data-id="cju4wk8ed005mez66pihwsxgd" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-TCP-IP的底层队列" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2019/03/09/TCP-IP的底层队列/">TCP/IP的底层队列</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2019/03/09/TCP-IP的底层队列/">
            <time datetime="2019-03-09T15:24:38.000Z" itemprop="datePublished">2019-03-09</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/网络/">网络</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/TCP-IP/">TCP/IP</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;自从上次学习了TCP/IP的拥塞控制算法后，我越发想要更加深入的了解TCP/IP的一些底层原理，搜索了很多网络上的资料，看到了陶辉大神关于高性能网络编程的专栏，收益颇多。今天就总结一下，并且加上自己的一些思考。</p>
<p>&emsp;我自己比较了解Java语言，对Java网络编程的理解就止于Netty框架的使用。<code>Netty</code>的源码贡献者Norman Maurer对于Netty网络开发有过一句建议，”Never block the event loop, reduce context-swtiching”。也就是尽量不要阻塞IO线程，也尽量减少线程切换。我们今天只关注前半句，对这句话感兴趣的同学可以看一下<a href="https://mp.weixin.qq.com/s/JRsbK1Un2av9GKmJ8DK7IQ?" target="_blank" rel="noopener">蚂蚁通信框架实践
</a>。</p>
<p>&emsp;为什么不能阻塞读取网络信息的IO线程呢？这里就要从经典的网络C10K开始理解，服务器如何支持并发1万请求。C10K的根源在于网络的IO模型。Linux 中网络处理都用同步阻塞的方式，也就是每个请求都分配一个进程或者线程，那么要支持1万并发，难道就要使用1万个线程处理请求嘛？这1万个线程的调度、上下文切换乃至它们占用的内存，都会成为瓶颈。解决C10K的通用办法就是使用I/O 多路复用，Netty就是这样。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-778c5e86e4fc9e5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Netty的reactor模型"></p>
<p>&emsp;Netty有负责服务端监听建立连接的线程组(mainReactor)和负责连接读写操作的IO线程组(subReactor)，还可以有专门处理业务逻辑的Worker线程组(ThreadPool)。三者相互独立，这样有很多好处。一是有专门的线程组负责监听和处理网络连接的建立，可以防止TCP/IP的半连接队列(sync)和全连接队列(acceptable)被占满。二是IO线程组和Worker线程分开，双方并行处理网络I/O和业务逻辑，可以避免IO线程被阻塞，防止TCP/IP的接收报文的队列被占满。当然，如果业务逻辑较少，也就是IO 密集型的轻计算业务，可以将业务逻辑放在IO线程中处理，避免线程切换，这也就是Norman Maurer话的后半部分。</p>
<p>&emsp;TCP/IP怎么就这么多队列啊？今天我们就来细看一下TCP/IP的几个队列,包括建立连接时的半连接队列(sync)，全连接队列(accept)和接收报文时的receive、out_of_order、prequeue以及backlog队列。</p>
<h3 id="建立连接时的队列"><a href="#建立连接时的队列" class="headerlink" title="建立连接时的队列"></a>建立连接时的队列</h3><p><img src="https://upload-images.jianshu.io/upload_images/623378-370a716b31ece06c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP三次握手和队列示意图"></p>
<p>&emsp;如上图所示，这里有两个队列：syns queue(半连接队列)和accept queue(全连接队列)。三次握手中，服务端接收到客户端的SYN报文后，把相关信息放到半连接队列中，同时回复SYN+ACK给客户端。<br>&emsp;第三步的时候服务端收到客户端的ACK，如果这时全连接队列没满，那么从半连接队列拿出相关信息放入到全连接队列中，否则按<code>tcp_abort_on_overflow</code>的值来执行相关操作，直接抛弃或者过一段时间在重试。</p>
<h3 id="接收报文时的队列"><a href="#接收报文时的队列" class="headerlink" title="接收报文时的队列"></a>接收报文时的队列</h3><p>&emsp;相比于建立连接，TCP在接收报文时的处理逻辑更为复杂，相关的队列和涉及的配置参数更多。</p>
<p>&emsp;应用程序接收TCP报文和程序所在服务器系统接收网络里发来的TCP报文是两个独立流程。二者都会操控socket实例，但是会通过锁竞争来决定某一时刻由谁来操控，由此产生很多不同的场景。例如，应用程序正在接收报文时，操作系统通过网卡又接收到报文，这时该如何处理？若应用程序没有调用read或者recv读取报文时，操作系统收到报文又会如何处理？</p>
<p>&emsp;我们接下来就以三张图为主，介绍TCP接收报文时的三种场景，并在其中介绍四个接收相关的队列。</p>
<h4 id="接收报文场景一"><a href="#接收报文场景一" class="headerlink" title="接收报文场景一"></a>接收报文场景一</h4><p><img src="https://upload-images.jianshu.io/upload_images/623378-f25d47544e00ea0b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景一"></p>
<p>上图是TCP接收报文场景一的示意图。操作系统首先接收报文，存储到socket的receive队列，然后用户进程再调用recv进行读取。</p>
<p>1) 当网卡接收报文并且判断为TCP协议时，经过层层调用，最终会调用到内核的<code>tcp_v4_rcv</code>方法。由于当前TCP要接收的下一个报文正是S1，所以<code>tcp_v4_rcv</code>函数将其直接加入到<code>receive</code>队列中。<code>receive</code>队列是将已经接收到的TCP报文，去除了TCP头部、排好序放入的、用户进程可以直接按序读取的队列。由于socket不在用户进程上下文中（也就是没有用户进程在读socket），并且我们需要S1序号的报文，而恰好收到了S1报文，因此，它进入了<code>receive</code>队列。</p>
<p>2) 接收到S3报文，由于TCP要接收的下一个报文序号是S2，所以加入到<code>out_of_order</code>队列，所有乱序的报文会放在这里。</p>
<p>3) 接着，收到了TCP期望的S2报文，直接进入<code>recevie</code>队列。由于此时<code>out_of_order</code>队列不为空，需要检查一下。</p>
<p>4) 每次向<code>receive</code>队列插入报文时都会检查<code>out_of_order</code>队列，由于接收到S2报文后，期望的的序号为S3，所以<code>out_of_order</code>队列中的S3报文会被移到<code>receive</code>队列。</p>
<p>5) 用户进程开始读取socket，先在进程中分配一块内存，然后调用<code>read</code>或者<code>recv</code>方法。socket有一系列的具有默认值的配置属性，比如socket默认是阻塞式的，它的<code>SO_RCVLOWAT</code>属性值默认为1。当然，recv这样的方法还会接收一个flag参数，它可以设置为<code>MSG_WAITALL</code>、<code>MSG_PEEK</code>、<code>MSG_TRUNK</code>等等，这里我们假定为最常用的0。进程调用了<code>recv</code>方法。</p>
<p>6) 调用<code>tcp_recvmsg</code>方法</p>
<p>7) <code>tcp_recvmsg</code>方法会首先锁住socket。socket是可以被多线程使用的，而且操作系统也会使用，所以必须处理并发问题。要操控socket，就先获取锁。</p>
<p>8) 此时，<code>receive</code>队列已经有3个报文了，将第一个报文拷贝到用户态内存中，由于第五步中socket的参数并没有带<code>MSG_PEEK</code>，所以将第一个报文从队列中移除，从内核态释放掉。反之，<code>MSG_PEEK</code>标志位会导致<code>receive</code>队列不会删除报文。所以，<code>MSG_PEEK</code>主要用于多进程读取同一套接字的情形。</p>
<p>9) 拷贝第二个报文，当然，执行拷贝前都会检查用户态内存的剩余空间是否足以放下当前这个报文，不够时会直接返回已经拷贝的字节数。<br>10) 拷贝第三个报文。<br>11) <code>receive</code>队列已经为空，此时会检查<code>SO_RCVLOWAT</code>这个最小阈值。如果已经拷贝字节数小于它，进程会休眠，等待更多报文。默认的<code>SO_RCVLOWAT</code>值为1，也就是读取到报文就可以返回。</p>
<p>12) 检查<code>backlog</code>队列，<code>backlog</code>队列是用户进程正在拷贝数据时，网卡收到的报文会进这个队列。如果此时<code>backlog</code>队列有数据，就顺带处理下。<code>backlog</code>队列是没有数据的，因此释放锁，准备返回用户态。</p>
<p>13) 用户进程代码开始执行，此时recv等方法返回的就是从内核拷贝的字节数。</p>
<h4 id="接收报文场景二"><a href="#接收报文场景二" class="headerlink" title="接收报文场景二"></a>接收报文场景二</h4><p>&emsp;第二张图给出了第二个场景，这里涉及了<code>prequeue</code>队列。用户进程调用recv方法时，socket队列中没有任何报文，而socket是阻塞的，所以进程睡眠了。然后操作系统收到了报文，此时<code>prequeue</code>队列开始产生作用。该场景中，<code>tcp_low_latency</code>为默认的0，套接字socket的<code>SO_RCVLOWAT</code>是默认的1，仍然是阻塞socket，如下图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-524a7634fa58fa48.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景二"></p>
<p>&emsp;其中1，2，3步骤的处理和之前一样。我们直接从第四步开始。</p>
<p>4) 由于此时<code>receive</code>,<code>prequeue</code>和<code>backlog</code>队列都为空，所以没有拷贝一个字节到用户内存中。而socket的配置要求至少拷贝<code>SO_RCVLOWAT</code>也就是1字节的报文，因此进入阻塞式套接字的等待流程。最长等待时间为<code>SO_RCVTIMEO</code>指定的时间。socket在进入等待前会释放socket锁，会使第五步中，新来的报文不再只能进入<code>backlog</code>队列。<br>5) 接到S1报文，将其加入<code>prequeue</code>队列中。<br>6) 插入到<code>prequeue</code>队列后，会唤醒在socket上休眠的进程。<br>7) 用户进程被唤醒后，重新获取socket锁，此后再接收到的报文只能进入<code>backlog</code>队列。<br>8) 进程先检查<code>receive</code>队列，当然仍然是空的；再去检查<code>prequeue</code>队列，发现有报文S1，正好是正在等待序号的报文，于是直接从<code>prequeue</code>队列中拷贝到用户内存，再释放内核中的这个报文。<br>9) 目前已经拷贝了一个字节的报文到用户内存，检查这个长度是否超过了最低阈值，也就是len和<code>SO_RCVLOWAT</code>的最小值。<br>10) 由于<code>SO_RCVLOWAT</code>使用了默认值1，拷贝字节数大于最低阈值，准备返回用户态，顺便会查看一下backlog队列中是否有数据，此时没有，所以准备放回，释放socket锁。<br>11) 返回用户已经拷贝的字节数。</p>
<h4 id="接收报文场景三"><a href="#接收报文场景三" class="headerlink" title="接收报文场景三"></a>接收报文场景三</h4><p>&emsp;在第三个场景中，系统参数<code>tcp_low_latency</code>为1，socket上设置了<code>SO_RCVLOWAT</code>属性值。服务器先收到报文S1，但是其长度小于<code>SO_RCVLOWAT</code>。用户进程调用<code>recv</code>方法读取，虽然读取到了一部分，但是没有到达最小阈值，所以进程睡眠了。与此同时，在睡眠前接收的乱序的报文S3直接进入<code>backlog</code>队列。然后，报文S2到达，由于没有使用<code>prequeue</code>队列（因为设置了tcp_low_latency），而它起始序号正是下一个待拷贝的值，所以直接拷贝到用户内存中，总共拷贝字节数已满足<code>SO_RCVLOWAT</code>的要求！最后在返回用户前把<code>backlog</code>队列中S3报文也拷贝给用户。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-2e37fda0937a4a95.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场景三"></p>
<p>1) 接收到报文S1，正是准备接收的报文序号，因此，将它直接加入到有序的<code>receive</code>队列中。<br>2) 将系统属性<code>tcp_low_latency</code>设置为1，表明服务器希望程序能够及时的接收到TCP报文。用户调用的<code>recv</code>接收阻塞socket上的报文，该socket的<code>SO_RCVLOWAT</code>值大于第一个报文的大小，并且用户分配了足够大的长度为len的内存。<br>3) 调用<code>tcp_recvmsg</code>方法来完成接收工作，先锁住socket。<br>4) 准备处理内核各个接收队列中的报文。<br>5) <code>receive</code>队列中有报文可以直接拷贝，其大小小于len，直接拷贝到用户内存。<br>6) 在进行第五步的同时，内核又接收到S3报文，此时socket被锁，报文直接进入<code>backlog</code>队列。这个报文并不是有序的。<br>7) 在第五步时，拷贝报文S1到用户内存，它的大小小于<code>SO_RCVLOWAT</code>的值。由于socket是阻塞型，所以用户进程进入睡眠状态。进入睡眠前，会先处理<code>backlog</code>队列的报文。因为S3报文是失序的，所以进入<code>out_of_order</code>队列。用户进程进入休眠状态前都会先处理一下<code>backlog</code>队列。<br>8) 进程休眠，直到超时或者<code>receive</code>队列不为空。<br>9) 内核接收到报文S2。注意，此时由于打开了<code>tcp_low_latency</code>标志位，所以报文是不会进入<code>prequeue</code>队列等待进程处理。<br>10) 由于报文S2正是要接收的报文，同时，一个用户进程在休眠等待该报文，所以直接将报文S2拷贝到用户内存。<br>11) 每处理完一个有序报文后，无论是拷贝到<code>receive</code>队列还是直接复制到用户内存，都会检查<code>out_of_order</code>队列，看看是否有报文可以处理。报文S3拷贝到用户内存，然后唤醒用户进程。<br>12) 唤醒用户进程。<br>13) 此时会检查已拷贝的字节数是否大于<code>SO_RCVLOWAT</code>，以及<code>backlog</code>队列是否为空。两者皆满足，准备返回。</p>
<p>&emsp;总结一下四个队列的作用。</p>
<ul>
<li>receive队列是真正的接收队列，操作系统收到的TCP数据包经过检查和处理后，就会保存到这个队列中。</li>
<li><code>backlog</code>是“备用队列”。当socket处于用户进程的上下文时（即用户正在对socket进行系统调用，如recv），操作系统收到数据包时会将数据包保存到<code>backlog</code>队列中，然后直接返回。</li>
<li><code>prequeue</code>是“预存队列”。当socket没有正在被用户进程使用时，也就是用户进程调用了read或者recv系统调用，但是进入了睡眠状态时，操作系统直接将收到的报文保存在<code>prequeue</code>中，然后返回。</li>
<li><code>out_of_order</code>是“乱序队列”。队列存储的是乱序的报文，操作系统收到的报文并不是TCP准备接收的下一个序号的报文，则放入<code>out_of_order</code>队列，等待后续处理。</li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;如果你觉得本篇文章对你有帮助，请点个赞。同时欢迎订阅本人的微信公众号。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-7d960275042f309d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.voidcn.com/article/p-gzmjmmna-dn.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-gzmjmmna-dn.html</a></li>
<li><a href="https://blog.csdn.net/russell_tao/article/details/9950615" target="_blank" rel="noopener">https://blog.csdn.net/russell_tao/article/details/9950615</a></li>
<li><a href="https://ylgrgyq.github.io/2017/08/01/linux-receive-packet-3/" target="_blank" rel="noopener">https://ylgrgyq.github.io/2017/08/01/linux-receive-packet-3/</a></li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/2019/03/09/TCP-IP的底层队列/" data-id="cju4wk8d9003fez6687r6qxjc" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-TCP拥塞控制算法简介" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2019/02/27/TCP拥塞控制算法简介/">TCP拥塞控制算法简介</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2019/02/27/TCP拥塞控制算法简介/">
            <time datetime="2019-02-27T15:08:05.000Z" itemprop="datePublished">2019-02-27</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/网络/">网络</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/TCP/">TCP</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;最近花了些时间在学习TCP/IP协议上，首要原因是由于本人长期以来对TCP/IP的认识就只限于三次握手四次分手上，所以希望深入了解一下。再者，TCP/IP和Linux系统层级的很多设计都可以用于中间件系统架构上，比如说TCP 拥塞控制算法也可以用于以响应时间来限流的中件间。更深一层，像TCP/IP协议这种基础知识和原理性的技术，都是经过长时间的考验的，都是前人智慧的结晶，可以给大家很多启示和帮助。</p>
<p>&emsp;本文中会出现一些缩写，因为篇幅问题，无法每个都进行解释，如果你不明白它的含义，请自己去搜索了解，做一个主动寻求知识的人。</p>
<p>&emsp;TCP协议有两个比较重要的控制算法，一个是流量控制，另一个就是阻塞控制。</p>
<p>&emsp;TCP协议通过滑动窗口来进行流量控制，它是控制发送方的发送速度从而使接受者来得及接收并处理。而拥塞控制是作用于网络，它是防止过多的包被发送到网络中，避免出现网络负载过大，网络拥塞的情况。</p>
<p>&emsp;拥塞算法需要掌握其状态机和四种算法。拥塞控制状态机的状态有五种，分别是Open，Disorder，CWR，Recovery和Loss状态。四个算法为慢启动，拥塞避免，拥塞发生时算法和快速恢复。</p>
<h3 id="Congestion-Control-State-Machine"><a href="#Congestion-Control-State-Machine" class="headerlink" title="Congestion Control State Machine"></a>Congestion Control State Machine</h3><p>&emsp;和TCP一样，拥塞控制算法也有其状态机。当发送方收到一个Ack时，Linux TCP通过状态机(state)来决定其接下来的行为，是应该降低拥塞窗口cwnd大小，或者保持cwnd不变，还是继续增加cwnd。如果处理不当，可能会导致丢包或者超时。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-706f6fec39f66d2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="状态机示意图"></p>
<h4 id="1-Open状态"><a href="#1-Open状态" class="headerlink" title="1 Open状态"></a>1 Open状态</h4><p>&emsp;Open状态是拥塞控制状态机的默认状态。这种状态下，当ACK到达时，发送方根据拥塞窗口cwnd(Congestion Window)是小于还是大于慢启动阈值ssthresh(slow start threshold)，来按照慢启动或者拥塞避免算法来调整拥塞窗口。</p>
<h4 id="2-Disorder状态"><a href="#2-Disorder状态" class="headerlink" title="2 Disorder状态"></a>2 Disorder状态</h4><p>&emsp;当发送方检测到DACK(重复确认)或者SACK(选择性确认)时，状态机将转变为Disorder状态。在此状态下，发送方遵循飞行(in-flight)包守恒原则，即一个新包只有在一个老包离开网络后才发送，也就是发送方收到老包的ACK后，才会再发送一个新包。</p>
<h4 id="3-CWR状态"><a href="#3-CWR状态" class="headerlink" title="3 CWR状态"></a>3 CWR状态</h4><p>&emsp;发送方接收到一个拥塞通知时，并不会立刻减少拥塞窗口cwnd，而是每收到两个ACK就减少一个段，直到窗口的大小减半为止。当cwnd正在减小并且网络中有没有重传包时，这个状态就叫CWR(Congestion Window Reduced，拥塞窗口减少)状态。CWR状态可以转变成Recovery或者Loss状态。</p>
<h4 id="4-Recovery状态"><a href="#4-Recovery状态" class="headerlink" title="4 Recovery状态"></a>4 Recovery状态</h4><p>&emsp;当发送方接收到足够(推荐为三个)的DACK(重复确认)后，进入该状态。在该状态下，拥塞窗口cnwd每收到两个ACK就减少一个段(segment)，直到cwnd等于慢启动阈值ssthresh，也就是刚进入Recover状态时cwnd的一半大小。<br>&emsp;发送方保持 Recovery 状态直到所有进入 Recovery状态时正在发送的数据段都成功地被确认，然后发送方恢复成Open状态，重传超时有可能中断 Recovery 状态，进入Loss状态。</p>
<h4 id="5-Loss状态"><a href="#5-Loss状态" class="headerlink" title="5 Loss状态"></a>5 Loss状态</h4><p>&emsp;当一个RTO(重传超时时间)到期后，发送方进入Loss状态。所有正在发送的数据标记为丢失，拥塞窗口cwnd设置为一个段(segment)，发送方再次以慢启动算法增大拥塞窗口cwnd。</p>
<p>&emsp;Loss 和 Recovery 状态的区别是:Loss状态下，拥塞窗口在发送方设置为一个段后增大，而 Recovery 状态下，拥塞窗口只能被减小。Loss 状态不能被其他的状态中断，因此，发送方只有在所有 Loss 开始时正在传输的数据都得到成功确认后，才能退到 Open 状态。</p>
<h3 id="四大算法"><a href="#四大算法" class="headerlink" title="四大算法"></a>四大算法</h3><p>&emsp;拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-b2182a47abfea2fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图"></p>
<h4 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h4><p>&emsp;所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。</p>
<p>&emsp;慢启动算法：</p>
<p>1) 连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。<br>2) 每当收到一个ACK，cwnd大小加一，呈线性上升。<br>3) 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。<br>4) 还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</p>
<h4 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h4><p>&emsp;如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：</p>
<p>1) 收到一个ACK，则cwnd = cwnd + 1 / cwnd<br>2) 每当过了一个往返延迟时间RTT，cwnd大小加一。</p>
<p>&emsp;过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。</p>
<h4 id="拥塞状态时的算法"><a href="#拥塞状态时的算法" class="headerlink" title="拥塞状态时的算法"></a>拥塞状态时的算法</h4><p>&emsp;一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。当丢包时，会有以下两种情况。对于丢包有两种判定方式，一种是超时重传RTO[Retransmission Timeout]超时，另一个是收到三个重复确认ACK。</p>
<p>&emsp;超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止。</p>
<p>&emsp;但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫<br>做快速重传，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。</p>
<p>&emsp;超时重传RTO[Retransmission Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：</p>
<ul>
<li>由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2.</li>
<li>cwnd重置为1</li>
<li>进入慢启动过程</li>
</ul>
<p>&emsp;最为早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。</p>
<p>&emsp;所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：</p>
<ul>
<li>cwnd大小缩小为当前的一半</li>
<li>ssthresh设置为缩小后的cwnd大小</li>
<li>然后进入快速恢复算法Fast Recovery。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-ad5b5b8805eda528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cwnd曲线示意图"></p>
<h4 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h4><p>&emsp;TCP Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一般。快速恢复算法的逻辑如下：</p>
<ul>
<li>cwnd = cwnd + 3 <em> MSS，加3 </em> MSS的原因是因为收到3个重复的ACK。</li>
<li>重传DACKs指定的数据包。</li>
<li>如果再收到DACKs，那么cwnd大小增加一。</li>
<li>如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-5e37364c3cab4943.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="快速重传示意图"></p>
<p>&emsp;如图所示，第五个包发生了丢失，所以导致接收方接收到三次重复ACK，也就是ACK5。所以将ssthresh设置当当时cwnd的一半，也就是6/2 = 3，cwnd设置为3 + 3 = 6。然后重传第五个包。当收到新的ACK时，也就是ACK11，则退出快速恢复阶段，将cwnd重新设置为当前的ssthresh，也就是3，然后进入拥塞避免算法阶段。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;本文为大家大致描述了TCP拥塞控制的一些机制，但是这些拥塞控制还是有很多缺陷和待优化的地方，业界也在不断推出新的拥塞控制算法，比如说谷歌的BBR。这些我们后续也会继续探讨，请大家继续关注。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-7d960275042f309d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p><a href="https://pdfs.semanticscholar.org/0e9c/968d09ab2e53e24c4dca5b2d67c7f7140f8e.pdf" target="_blank" rel="noopener">Congestion Control in Linux TCP</a></p>
</li>
<li><p><a href="https://my.oschina.net/piorcn/blog/806997" target="_blank" rel="noopener">TCP BBR算法与Reno/CUBIC的对比</a></p>
</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/2019/02/27/TCP拥塞控制算法简介/" data-id="cju4wk8db003kez66ww286kvg" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Spring-AOP-二-修饰者模式和JDK-Proxy" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2019/02/17/Spring-AOP-二-修饰者模式和JDK-Proxy/">Spring AOP(二) 修饰者模式和JDK Proxy</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2019/02/17/Spring-AOP-二-修饰者模式和JDK-Proxy/">
            <time datetime="2019-02-17T05:20:37.000Z" itemprop="datePublished">2019-02-17</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/AOP/">AOP</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;在上边一篇<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483735&amp;idx=1&amp;sn=2b526949cc4e69c75d1a96268920da68&amp;chksm=fc04c537cb734c21e84076865259243b4165fa00911920a30fe09d3a75b0cfc002fe66e43d05&amp;token=2009122217&amp;lang=zh_CN#rd" target="_blank" rel="noopener">文章</a>中我们介绍了Spring AOP的基本概念，今天我们就来学习一下与AOP实现相关的修饰者模式和Java Proxy相关的原理，为之后源码分析打下基础。</p>
<h3 id="修饰者模式"><a href="#修饰者模式" class="headerlink" title="修饰者模式"></a>修饰者模式</h3><p>&emsp;Java设计模式中的修饰者模式能动态地给目标对象增加额外的职责(Responsibility)。它使用组合(object composition)，即将目标对象作为修饰者对象(代理)的成员变量，由修饰者对象决定调用目标对象的时机和调用前后所要增强的行为。</p>
<p>&emsp;装饰模式包含如下组成部分：</p>
<ul>
<li>Component: 抽象构件，也就是目标对象所实现的接口，有operation函数</li>
<li>ConcreteComponent: 具体构件，也就是目标对象的类</li>
<li>Decorator: 抽象装饰类，也实现了抽象构件接口，也就是目标类和装饰类都实现了相同的接口</li>
<li>ConcreteDecorator: 具体装饰类，其中addBeavior函数就是增强的行为，装饰类可以自己决定addBeavior函数和目标对象函数operation函数的调用时机。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-8e64b6435042b3b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修饰者模式的类图"></p>
<p>&emsp;修饰者模式调用的时序图如下图所示。程序首先创建目标对象，然后创建修饰者对象，并将目标对象传入作为其成员变量。当程序调用修饰者对象的operation函数时，修饰者对象会先调用目标对象的operation函数，然后再调用自己的addBehavior函数。这就是类似于AOP的后置增强器，在目标对象的行为之后添加新的行为。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-e250659fe563087c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修饰者模式的时序图"></p>
<p>&emsp;Spring AOP的实现原理和修饰者模式类似。在上一篇文章中说到AOP的动态代理有两种实现方式，分别是JDK Proxy和cglib。</p>
<p>&emsp;如下图所示，JDK Proxy的类结构和上文中修饰者的类图结构类似，都是代理对象和目标对象都实现相同的接口，代理对象持有目标对象和切面对象，并且决定目标函数和切面增强函数的调用时机。<br>&emsp;而cglib的实现略有不同，它没有实现实现相同接口，而是代理对象继承目标对象类。<br><img src="https://upload-images.jianshu.io/upload_images/623378-e7fb928a23ea31a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两种动态代理的对标"></p>
<p>&emsp;本文后续就讲解一下JDK Proxy的相关源码分析。</p>
<h3 id="JDK-Proxy"><a href="#JDK-Proxy" class="headerlink" title="JDK Proxy"></a>JDK Proxy</h3><p>&emsp;JDK提供了Proxy类来实现动态代理的，可通过它的newProxyInstance函数来获得代理对象。JDK还提供了InvocationHandler类，代理对象的函数被调用时，会调用它的invoke函数，程序员可以在其中实现所需的逻辑。</p>
<p>&emsp;JDK Proxy的基本语法如下所示。先构造一个<code>InvocationHandler</code>的实现类，然后调用<code>Proxy</code>的<code>newProxyInstance</code>函数生成代理对象，传入类加载器，目标对象的接口和自定义的<code>InvocationHandler</code>实例。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public class CustomInvocationHandler implements InvocationHandler {
    private Object target;

    public CustomInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;Before invocation&quot;);
        Object retVal = method.invoke(target, args);
        System.out.println(&quot;After invocation&quot;);
        return retVal;
    }
}

CustomInvocationHandler customInvocationHandler = new CustomInvocationHandler(
        helloWord);
&#x2F;&#x2F;通过Proxy.newProxyInstance生成代理对象
ProxyTest proxy = (ProxyTest) Proxy.newProxyInstance(
        ProxyTest.class.getClassLoader(),
       proxyObj.getClass().getInterfaces(), customInvocationHandler);
</code></pre>
<h3 id="生成代理对象"><a href="#生成代理对象" class="headerlink" title="生成代理对象"></a>生成代理对象</h3><p>&emsp;我们首先来看一下<code>Proxy</code>的<code>newProxyInstance</code>函数。<code>newProxyInstance</code>函数的逻辑大致如下：</p>
<ul>
<li>首先根据传入的目标对象接口动态生成代理类</li>
<li>然后获取代理类的构造函数实例</li>
<li>最后将<code>InvocationHandler</code>作为参数通过反射调用构造函数实例，生成代理类对象。<br>&emsp;具体源码如下所示。
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public static Object newProxyInstance(ClassLoader loader,
                                        Class&lt;?&gt;[] interfaces,
                                        InvocationHandler h)
    throws IllegalArgumentException
{

    final Class&lt;?&gt;[] intfs = interfaces.clone();
    final SecurityManager sm = System.getSecurityManager();
    if (sm != null) {
        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
    }
    &#x2F;&#x2F; 1 动态生成代理对象的类
    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);

    &#x2F;&#x2F; ... 代码省略，下边代码其实是在try catch中的
    if (sm != null) {
        checkNewProxyPermission(Reflection.getCallerClass(), cl);
    }
    &#x2F;&#x2F; 2 获取代理类的构造函数
    final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
    final InvocationHandler ih = h;
    if (!Modifier.isPublic(cl.getModifiers())) {
        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
            public Void run() {
                cons.setAccessible(true);
                return null;
            }
        });
    }
    &#x2F;&#x2F; 3调用构造函数，传入InvocationHandler对象
    return cons.newInstance(new Object[]{h});
}
</code></pre>
</li>
</ul>
<p>&emsp;<code>getProxyClass0</code>函数的源码如下所示，通过代理类缓存获取代理类信息，如果不存在则会生成代理类。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; 生成代理类
private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,
                                        Class&lt;?&gt;... interfaces) {
    if (interfaces.length &gt; 65535) {
        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);
    }

    &#x2F;&#x2F; 如果已经有Proxy类的缓存则直接返回，否则要进行创建
    return proxyClassCache.get(loader, interfaces);
}
</code></pre>
<h3 id="生成代理类"><a href="#生成代理类" class="headerlink" title="生成代理类"></a>生成代理类</h3><p>&emsp;JDK Proxy通过<code>ProxyClassFactory</code>生成代理类。其<code>apply</code>函数大致逻辑如下：</p>
<ul>
<li>校验接口是否符合规范</li>
<li>生成代理类的名称和包名</li>
<li>生成代理类字节码</li>
<li>根据字节码生成代理类Class</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; 生成代理类的工厂类
private static final class ProxyClassFactory
    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;
{
    &#x2F;&#x2F; 所有代理类名的前缀
    private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;

    &#x2F;&#x2F; 生成唯一类名的原子Long对象
    private static final AtomicLong nextUniqueNumber = new AtomicLong();

    @Override
    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {

        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);
        for (Class&lt;?&gt; intf : interfaces) {
            &#x2F;&#x2F; 通过loader找到接口对应的类信息。
            Class&lt;?&gt; interfaceClass = null;
            try {
                interfaceClass = Class.forName(intf.getName(), false, loader);
            } catch (ClassNotFoundException e) {
            }
            if (interfaceClass != intf) {
                throw new IllegalArgumentException(
                    intf + &quot; is not visible from class loader&quot;);
            }
            &#x2F;&#x2F; 判断找出来的类确实是一个接口
            if (!interfaceClass.isInterface()) {
                throw new IllegalArgumentException(
                    interfaceClass.getName() + &quot; is not an interface&quot;);
            }
            &#x2F;&#x2F; 判断接口是否重复
            if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
                throw new IllegalArgumentException(
                    &quot;repeated interface: &quot; + interfaceClass.getName());
            }
        }
        &#x2F;&#x2F; 代理类的包路径
        String proxyPkg = null;
        int accessFlags = Modifier.PUBLIC | Modifier.FINAL;

        &#x2F;&#x2F; 记录非公开的代理接口，以便于生成的代理类和原来的类在同一个路径下。 
        for (Class&lt;?&gt; intf : interfaces) {
            int flags = intf.getModifiers();
            if (!Modifier.isPublic(flags)) {
                accessFlags = Modifier.FINAL;
                String name = intf.getName();
                int n = name.lastIndexOf(&#39;.&#39;);
                String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));
                if (proxyPkg == null) {
                    proxyPkg = pkg;
                } else if (!pkg.equals(proxyPkg)) {
                    throw new IllegalArgumentException(
                        &quot;non-public interfaces from different packages&quot;);
                }
            }
        }
        &#x2F;&#x2F; 如果没有非公开的Proxy接口，使用com.sun.proxy报名
        if (proxyPkg == null) {
            proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;
        }

        long num = nextUniqueNumber.getAndIncrement();
        &#x2F;&#x2F; 默认情况下，代理类的完全限定名为：com.sun.proxy.$Proxy0，$Proxy1……依次递增  
        String proxyName = proxyPkg + proxyClassNamePrefix + num;

        &#x2F;&#x2F; 生成代理类字节码
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
            proxyName, interfaces, accessFlags);
        try {
            &#x2F;&#x2F; 根据字节码返回相应的Class实例
            return defineClass0(loader, proxyName,
                                proxyClassFile, 0, proxyClassFile.length);
        } catch (ClassFormatError e) {
            throw new IllegalArgumentException(e.toString());
        }
    }
}
</code></pre>
<p>&emsp;其中关于字节码生成的部分逻辑我们就暂时不深入介绍了，感兴趣的同学可以自行研究。</p>
<h3 id="Proxy反编译"><a href="#Proxy反编译" class="headerlink" title="$Proxy反编译"></a>$Proxy反编译</h3><p>&emsp;我们来看一下生成的代理类的反编译代码。代理类实现了<code>Object</code>的基础函数，比如<code>toString</code>、<code>hasCode</code>和<code>equals</code>，也实现了目标接口中定义的函数，比如说<code>ProxyTest</code>接口的<code>test</code>函数。</p>
<p>&emsp; <code>$Proxy</code>中函数的实现都是直接调用了<code>InvocationHandler</code>的<code>invoke</code>函数。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public final class $Proxy0 extends Proxy
  implements ProxyTest 
&#x2F;&#x2F; 会实现目标接口，但是由于集成了Proxy，所以无法再集成其他类
{
  private static Method m1;
  private static Method m0;
  private static Method m3;
  private static Method m2;
  &#x2F;&#x2F; 构造函数要传入一个InvocationHandler对象
  public $Proxy0(InvocationHandler paramInvocationHandler)
    throws 
  {
    super(paramInvocationHandler);
  }
  &#x2F;&#x2F; equal函数
  public final boolean equals(Object paramObject)
    throws 
  {
      try
    {
      return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue();
    }
    catch (RuntimeException localRuntimeException)
    {
      throw localRuntimeException;
    }
    catch (Throwable localThrowable)
    {
    }
    throw new UndeclaredThrowableException(localThrowable);
  }

  public final int hashCode()
    throws 
  {
    try
    {
      return ((Integer)this.h.invoke(this, m0, null)).intValue();
    }
    catch (RuntimeException localRuntimeException)
    {
      throw localRuntimeException;
    }
    catch (Throwable localThrowable)
    {
    }
    throw new UndeclaredThrowableException(localThrowable);
  }
  &#x2F;&#x2F; test函数，也就是ProxyTest接口中定义的函数
  public final void test(String paramString)
    throws 
  {
    try
    {
      &#x2F;&#x2F; 调用InvocationHandler的invoke函数
      this.h.invoke(this, m3, new Object[] { paramString });
      return;
    }
    catch (RuntimeException localRuntimeException)
    {
      throw localRuntimeException;
    }
    catch (Throwable localThrowable)
    {
    }
    throw new UndeclaredThrowableException(localThrowable);
  }

  public final String toString()
    throws 
  {
    try
    {
      return (String)this.h.invoke(this, m2, null);
    }
    catch (RuntimeException localRuntimeException)
    {
      throw localRuntimeException;
    }
    catch (Throwable localThrowable)
    {
    }
    throw new UndeclaredThrowableException(localThrowable);
  }
  &#x2F;&#x2F; 获取各个函数的Method对象
  static
  {
    try
    {
      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] { Class.forName(&quot;java.lang.Object&quot;) });
      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);
      m3 = Class.forName(&quot;com.proxy.test2.HelloTest&quot;).getMethod(&quot;say&quot;, new Class[] { Class.forName(&quot;java.lang.String&quot;) });
      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);
      return;
    }
    catch (NoSuchMethodException localNoSuchMethodException)
    {
      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());
    }
    catch (ClassNotFoundException localClassNotFoundException)
    {
    }
    throw new NoClassDefFoundError(localClassNotFoundException.getMessage());
  }
}
</code></pre>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;下一篇文章就是AOP的源码分析了，希望大家继续关注。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-7d960275042f309d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/2019/02/17/Spring-AOP-二-修饰者模式和JDK-Proxy/" data-id="cju4wk8d60039ez66b042swxr" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Spring-AOP-一-AOP基本概念" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2019/02/08/Spring-AOP-一-AOP基本概念/">Spring AOP(一) AOP基本概念</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2019/02/08/Spring-AOP-一-AOP基本概念/">
            <time datetime="2019-02-08T11:15:32.000Z" itemprop="datePublished">2019-02-08</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/AOP/">AOP</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;Spring框架自诞生之日就拯救我等程序员于水火之中，它有两大法宝，一个是IoC控制反转，另一个便是AOP面向切面编程。今日我们就来破一下它的AOP法宝，以便以后也能自由使出一手AOP大法。</p>
<p>&emsp;AOP全名Aspect-oriented programming面向切面编程大法，它有很多兄弟，分别是经常见的面向对象编程，朴素的面向过程编程和神秘的函数式编程等。所谓AOP的具体解释，以及和OOP的区别不清楚的同学可以自行去了解。</p>
<p>&emsp;AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理。本文就主要讲解AOP的基本术语，然后用一个例子让大家彻底搞懂这些名词，最后介绍一下AOP的两种代理方式：</p>
<ul>
<li>以AspectJ为代表的静态代理。</li>
<li>以Spring AOP为代表的动态代理。</li>
</ul>
<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><h4 id="1-切面-Aspect"><a href="#1-切面-Aspect" class="headerlink" title="(1)切面(Aspect)"></a>(1)切面(Aspect)</h4><p>&emsp;切面是一个横切关注点的模块化，一个切面能够包含同一个类型的不同增强方法，比如说事务处理和日志处理可以理解为两个切面。切面由切入点和通知组成，它既包含了横切逻辑的定义，也包括了切入点的定义。 Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">@Component
@Aspect
public class LogAspect {
}
</code></pre>
<p>&emsp;<strong><em>可以简单地认为, 使用 @Aspect 注解的类就是切面</em></strong></p>
<h4 id="2-目标对象-Target"><a href="#2-目标对象-Target" class="headerlink" title="(2) 目标对象(Target)"></a>(2) 目标对象(Target)</h4><p>&emsp;目标对象指将要被增强的对象，即包含主业务逻辑的类对象。或者说是被一个或者多个切面所通知的对象。</p>
<h4 id="3-连接点-JoinPoint"><a href="#3-连接点-JoinPoint" class="headerlink" title="(3) 连接点(JoinPoint)"></a>(3) 连接点(JoinPoint)</h4><p>&emsp;程序执行过程中明确的点，如方法的调用或特定的异常被抛出。连接点由两个信息确定：</p>
<ul>
<li>方法(表示程序执行点，即在哪个目标方法)</li>
<li>相对点(表示方位，即目标方法的什么位置，比如调用前，后等)</li>
</ul>
<p>&emsp;简单来说，连接点就是被拦截到的程序执行点，因为Spring只支持方法类型的连接点，所以在Spring中连接点就是被拦截到的方法。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">@Before(&quot;pointcut()&quot;)
public void log(JoinPoint joinPoint) { &#x2F;&#x2F;这个JoinPoint参数就是连接点
}
</code></pre></p>
<h4 id="4-切入点-PointCut"><a href="#4-切入点-PointCut" class="headerlink" title="(4) 切入点(PointCut)"></a>(4) 切入点(PointCut)</h4><p>&emsp;切入点是对连接点进行拦截的条件定义。切入点表达式如何和连接点匹配是AOP的核心，Spring缺省使用AspectJ切入点语法。<br>&emsp;一般认为，所有的方法都可以认为是连接点，但是我们并不希望在所有的方法上都添加通知，而切入点的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配连接点，给满足规则的连接点添加通知。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">@Pointcut(&quot;execution(* com.remcarpediem.test.aop.service..*(..))&quot;)
public void pointcut() {
}
</code></pre>
<p>&emsp;上边切入点的匹配规则是<code>com.remcarpediem.test.aop.service</code>包下的所有类的所有函数。</p>
<h4 id="5-通知-Advice"><a href="#5-通知-Advice" class="headerlink" title="(5) 通知(Advice)"></a>(5) 通知(Advice)</h4><p>&emsp;通知是指拦截到连接点之后要执行的代码，包括了“around”、“before”和“after”等不同类型的通知。Spring AOP框架以拦截器来实现通知模型，并维护一个以连接点为中心的拦截器链。 </p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; @Before说明这是一个前置通知，log函数中是要前置执行的代码，JoinPoint是连接点，
@Before(&quot;pointcut()&quot;)
public void log(JoinPoint joinPoint) { 
}
</code></pre>
<h4 id="6-织入-Weaving"><a href="#6-织入-Weaving" class="headerlink" title="(6) 织入(Weaving)"></a>(6) 织入(Weaving)</h4><p>&emsp;织入是将切面和业务逻辑对象连接起来, 并创建通知代理的过程。织入可以在编译时，类加载时和运行时完成。在编译时进行织入就是静态代理，而在运行时进行织入则是动态代理。</p>
<h4 id="7-增强器-Adviser"><a href="#7-增强器-Adviser" class="headerlink" title="(7) 增强器(Adviser)"></a>(7) 增强器(Adviser)</h4><p>&emsp;Advisor是切面的另外一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。Advisor由切入点和Advice组成。<br>&emsp;Advisor这个概念来自于Spring对AOP的支撑，在AspectJ中是没有等价的概念的。Advisor就像是一个小的自包含的切面，这个切面只有一个通知。切面自身通过一个Bean表示，并且必须实现一个默认接口。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; AbstractPointcutAdvisor是默认接口
public class LogAdvisor extends AbstractPointcutAdvisor {
    private Advice advice; &#x2F;&#x2F; Advice
    private Pointcut pointcut; &#x2F;&#x2F; 切入点

    @PostConstruct
    public void init() {
        &#x2F;&#x2F; AnnotationMatchingPointcut是依据修饰类和方法的注解进行拦截的切入点。
        this.pointcut = new AnnotationMatchingPointcut((Class) null, Log.class);
        &#x2F;&#x2F; 通知
        this.advice = new LogMethodInterceptor();
    }
}
</code></pre>
<h4 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h4><p>&emsp;看完了上面的理论部分知识, 我相信还是会有不少朋友感觉AOP 的概念还是很模糊, 对 AOP 的术语理解的还不是很透彻。现在我们就找一个具体的案例来说明一下。<br>&emsp;简单来讲，整个 aspect 可以描述为: <strong><em>满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作</em></strong>。我们来看下边这个例子。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">@Component
@Aspect &#x2F;&#x2F; 切面
public class LogAspect {
    private final static Logger LOGGER = LoggerFactory.getLogger(LogAspect.class.getName());
     &#x2F;&#x2F; 切入点，表达式是指com.remcarpediem.test.aop.service
     &#x2F;&#x2F; 包下的所有类的所有方法
    @Pointcut(&quot;execution(* com.remcarpediem.test.aop.service..*(..))&quot;)
    public void aspect() {}
    &#x2F;&#x2F; 通知，在符合aspect切入点的方法前插入如下代码，并且将连接点作为参数传递
    @Before(&quot;aspect()&quot;)
    public void log(JoinPoint joinPoint) { &#x2F;&#x2F;连接点作为参数传入
        if (LOGGER.isInfoEnabled()) {
            &#x2F;&#x2F; 获得类名，方法名，参数和参数名称。
            Signature signature = joinPoint.getSignature();
            String className = joinPoint.getTarget().getClass().getName();
            String methodName = joinPoint.getSignature().getName();
            Object[] arguments = joinPoint.getArgs();
            MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();

            String[] argumentNames = methodSignature.getParameterNames();

            StringBuilder sb = new StringBuilder(className + &quot;.&quot; + methodName + &quot;(&quot;);

            for (int i = 0; i&lt; arguments.length; i++) {
                Object argument = arguments[i];
                sb.append(argumentNames[i] + &quot;-&gt;&quot;);
                sb.append(argument != null ? argument.toString() : &quot;null &quot;);
            }
            sb.append(&quot;)&quot;);

            LOGGER.info(sb.toString());
        }
    }
}
</code></pre></p>
<p>&emsp;上边这段代码是一个简单的日志相关的切面，依次定义了切入点和通知，而连接点作为log的参数传入进来，进行一定的操作，比如说获取连接点函数的名称，参数等。</p>
<h3 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h3><p>&emsp;所谓静态代理就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强。ApsectJ是静态代理的实现之一，也是最为流行的。静态代理由于在编译时就生成了代理类，效率相比动态代理要高一些。AspectJ可以单独使用，也可以和Spring结合使用。</p>
<h3 id="动态代理模式"><a href="#动态代理模式" class="headerlink" title="动态代理模式"></a>动态代理模式</h3><p>&emsp;与静态代理不同，动态代理就是说AOP框架不会去修改编译时生成的字节码，而是在运行时在内存中生成一个AOP代理对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<p>&emsp;Spring AOP中的动态代理主要有两种方式：JDK动态代理和CGLIB动态代理。</p>
<p>&emsp;JDK代理通过反射来处理被代理的类，并且要求被代理类必须实现一个接口。核心类是 InvocationHandler接口 和 Proxy类。<br>&emsp;而当目标类没有实现接口时，Spring AOP框架会使用CGLIB来动态代理目标类。<br>&emsp;CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。核心类是 MethodInterceptor 接口和Enhancer 类</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-c854d59f8fb95c4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两种动态代理的区别"></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;AOP的基础知识都比较枯燥，本人也不擅长概念性的文章，不过下一篇文章就是AOP源码分析了，希望大家可以继续关注。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-7d960275042f309d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/2019/02/08/Spring-AOP-一-AOP基本概念/" data-id="cju4wk8d30032ez66lh14d6w9" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-AbstractQueuedSynchronizer超详细原理解析-1" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2019/01/24/AbstractQueuedSynchronizer超详细原理解析-1/">AbstractQueuedSynchronizer超详细原理解析</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2019/01/24/AbstractQueuedSynchronizer超详细原理解析-1/">
            <time datetime="2019-01-24T12:31:40.000Z" itemprop="datePublished">2019-01-24</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/并发/">并发</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;今天我们来研究学习一下<code>AbstractQueuedSynchronizer</code>类的相关原理，<code>java.util.concurrent</code>包中很多类都依赖于这个类所提供队列式同步器，比如说常用的<code>ReentranLock</code>，<code>Semaphore</code>和<code>CountDownLatch</code>等。<br>&emsp;为了方便理解，我们以一段使用<code>ReentranLock</code>的代码为例，讲解<code>ReentranLock</code>每个方法中有关<code>AQS</code>的使用。</p>
<h3 id="ReentranLock示例"><a href="#ReentranLock示例" class="headerlink" title="ReentranLock示例"></a>ReentranLock示例</h3><p>&emsp;我们都知道<code>ReentranLock</code>的加锁行为和<code>Synchronized</code>类似，都是可重入的锁，但是二者的实现方式确实完全不同的，我们之后也会讲解<code>Synchronized</code>的原理。<strong><em>除此之外，Synchronized的阻塞无法被中断，而ReentrantLock则提供了可中断的阻塞</em></strong>。下面的代码是<code>ReentranLock</code>的函数，我们就以此为顺序，依次讲解这些函数背后的实现原理。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">ReentrantLock lock = new ReentrantLock();
lock.lock();
lock.unlock();
</code></pre>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>&emsp;<code>ReentranLock</code>分为公平锁和非公平锁，二者的区别就在获取锁机会是否和排队顺序相关。我们都知道，如果锁被另一个线程持有，那么申请锁的其他线程会被挂起等待，加入等待队列。理论上，先调用<code>lock</code>函数被挂起等待的线程应该排在等待队列的前端，后调用的就排在后边。如果此时，锁被释放，需要通知等待线程再次尝试获取锁，公平锁会让最先进入队列的线程获得锁。而非公平锁则会唤醒所有线程，让它们再次尝试获取锁，所以可能会导致后来的线程先获得了锁，则就是非公平。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre>
<p>&emsp;我们会发现<code>FairSync</code>和<code>NonfairSync</code>都继承了<code>Sync</code>类，而<code>Sync</code>的父类就是<code>AbstractQueuedSynchronizer</code>(后续简称<code>AQS</code>)。但是<code>AQS</code>的构造函数是空的,并没有任何操作。<br>&emsp;之后的源码分析，如果没有特别说明，就是指公平锁。</p>
<h3 id="lock操作"><a href="#lock操作" class="headerlink" title="lock操作"></a>lock操作</h3><p>&emsp;<code>ReentranLock</code>的<code>lock</code>函数如下所示，直接调用了<code>sync</code>的<code>lock</code>函数。也就是调用了<code>FairSync</code>的<code>lock</code>函数。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">    &#x2F;&#x2F;ReentranLock
    public void lock() {
        sync.lock();
    }
    &#x2F;&#x2F;FairSync
    final void lock() {
        &#x2F;&#x2F;调用了AQS的acquire函数,这是关键函数之一
        acquire(1);
    }
</code></pre></p>
<p>&emsp;我们接下来就正式开始<code>AQS</code>相关的源码分析了，<code>acquire</code>函数的作用是获取同一时间段内只能被一个线程获取的量，这个量就是抽象化的锁概念。我们先分析代码，你慢慢就会明白其中的含义。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public final void acquire(int arg) {
	&#x2F;&#x2F; tryAcquire先尝试获取&quot;锁&quot;,获取了就不进入后续流程
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        &#x2F;&#x2F;addWaiter是给当前线程创建一个节点,并将其加入等待队列
        &#x2F;&#x2F;acquireQueued是当线程已经加入等待队列之后继续尝试获取锁.
        selfInterrupt();
}
</code></pre></p>
<p>&emsp;<code>tryAcquire</code>，<code>addWaiter</code>和<code>acquireQueued</code>都是十分重要的函数，我们接下来依次学习一下这些函数，理解它们的作用。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F;AQS类中的变量.
private volatile int state;
&#x2F;&#x2F;这是FairSync的实现,AQS中未实现,子类按照自己的需要实现该函数
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    &#x2F;&#x2F;获取AQS中的state变量,代表抽象概念的锁.
    int c = getState();
    if (c == 0) { &#x2F;&#x2F;值为0,那么当前独占性变量还未被线程占有
        &#x2F;&#x2F;如果当前阻塞队列上没有先来的线程在等待,UnfairSync这里的实现就不一致
        if (!hasQueuedPredecessors() &amp;&amp; 
            compareAndSetState(0, acquires)) {
            &#x2F;&#x2F;成功cas,那么代表当前线程获得该变量的所有权,也就是说成功获得锁
            setExclusiveOwnerThread(current);
            &#x2F;&#x2F; setExclusiveOwnerThread将本线程设置为独占性变量所有者线程
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        &#x2F;&#x2F;如果该线程已经获取了独占性变量的所有权,那么根据重入性
        &#x2F;&#x2F;原理,将state值进行加1,表示多次lock
        &#x2F;&#x2F;由于已经获得锁,该段代码只会被一个线程同时执行,所以不需要
        &#x2F;&#x2F;进行任何并行处理
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    &#x2F;&#x2F;上述情况都不符合,说明获取锁失败
    return false;
}
</code></pre>
<p>&emsp;由上述代码我们可以发现，<code>tryAcquire</code>就是尝试获取那个线程独占的变量<code>state</code>。state的值表示其状态：如果是0，那么当前还没有线程独占此变量；否在就是已经有线程独占了这个变量，也就是代表已经有线程获得了锁。但是这个时候要再进行一次判断，看是否是当前线程自己获得的这个锁，如果是，就增加state的值。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-90472c418cd5dd47.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ReentranLock获得锁"></p>
<p>&emsp;这里有几点需要说明一下，首先是<code>compareAndSetState</code>函数，这是使用CAS操作来设置<code>state</code>的值，而且state值设置了<code>volatile</code>修饰符，通过这两点来确保修改state的值不会出现多线程问题。然后是公平锁和非公平锁的区别问题，在<code>UnfairSync</code>的<code>nonfairTryAcquire</code>函数中不会在相同的位置上调用<code>hasQueuedPredecessors</code>来判断当前是否已经有线程在排队等待获得锁。</p>
<p>&emsp;如果<code>tryAcquire</code>返回<code>true</code>，那么就是获取锁成功；如果返回false，那么就是未获得锁，需要加入阻塞等待队列。我们下面就来看一下<code>addWaiter</code>的相关操作。</p>
<h3 id="等待锁的阻塞队列"><a href="#等待锁的阻塞队列" class="headerlink" title="等待锁的阻塞队列"></a>等待锁的阻塞队列</h3><p>&emsp;将保存当前线程信息的节点加入到等待队列的相关函数中涉及到了无锁队列的相关算法，由于在<code>AQS</code>中只是将节点添加到队尾，使用到的无锁算法也相对简单。真正的无锁队列的算法我们等到分析<code>ConcurrentSkippedListMap</code>时在进行讲解。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    &#x2F;&#x2F;先使用快速入列法来尝试一下,如果失败,则进行更加完备的入列算法.
    &#x2F;&#x2F;只有在必要的情况下才会使用更加复杂耗时的算法，也就是乐观的态度
    Node pred = tail; &#x2F;&#x2F;列尾指针
    if (pred != null) {
        node.prev = pred; &#x2F;&#x2F;步骤1:该节点的前趋指针指向tail
        if (compareAndSetTail(pred, node)){ &#x2F;&#x2F;步骤二:cas将尾指针指向该节点
            pred.next = node;&#x2F;&#x2F;步骤三:如果成果,让旧列尾节点的next指针指向该节点.
            return node;
        }
    }
    &#x2F;&#x2F;cas失败,或在pred == null时调用enq
    enq(node);
    return node;
}
private Node enq(final Node node) {
    for (;;) { &#x2F;&#x2F;cas无锁算法的标准for循环,不停的尝试
        Node t = tail;
        if (t == null) { &#x2F;&#x2F;初始化
            if (compareAndSetHead(new Node())) 
              &#x2F;&#x2F;需要注意的是head是一个哨兵的作用,并不代表某个要获取锁的线程节点
                tail = head;
        } else {
            &#x2F;&#x2F;和addWaiter中一致,不过有了外侧的无限循环,不停的尝试,自旋锁
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre></p>
<p>&emsp;通过调用<code>addWaiter</code>函数，<code>AQS</code>将当前线程加入到了等待队列，但是还没有阻塞当前线程的执行，接下来我们就来分析一下<code>acquireQueued</code>函数。</p>
<h3 id="等待队列节点的操作"><a href="#等待队列节点的操作" class="headerlink" title="等待队列节点的操作"></a>等待队列节点的操作</h3><p>&emsp;由于进入阻塞状态的操作会降低执行效率，所以，<code>AQS</code>会尽力避免试图获取独占性变量的线程进入阻塞状态。所以，当线程加入等待队列之后，<code>acquireQueued</code>会执行一个for循环，每次都判断当前节点是否应该获得这个变量(在队首了)。如果不应该获取或在再次尝试获取失败，那么就调用<code>shouldParkAfterFailedAcquire</code>判断是否应该进入阻塞状态。如果当前节点之前的节点已经进入阻塞状态了，那么就可以判定当前节点不可能获取到锁，为了防止CPU不停的执行for循环，消耗CPU资源，调用<code>parkAndCheckInterrupt</code>函数来进入阻塞状态。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) { &#x2F;&#x2F;一直执行,直到获取锁,返回.
            final Node p = node.predecessor(); 
            &#x2F;&#x2F;node的前驱是head,就说明,node是将要获取锁的下一个节点.
            if (p == head &amp;&amp; tryAcquire(arg)) { &#x2F;&#x2F;所以再次尝试获取独占性变量
                setHead(node); &#x2F;&#x2F;如果成果,那么就将自己设置为head
                p.next = null; &#x2F;&#x2F; help GC
                failed = false;
                return interrupted;
                &#x2F;&#x2F;此时,还没有进入阻塞状态,所以直接返回false,表示不需要中断调用selfInterrupt函数
            }
            &#x2F;&#x2F;判断是否要进入阻塞状态.如果`shouldParkAfterFailedAcquire`
            &#x2F;&#x2F;返回true,表示需要进入阻塞
            &#x2F;&#x2F;调用parkAndCheckInterrupt；否则表示还可以再次尝试获取锁,继续进行for循环
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                &#x2F;&#x2F;调用parkAndCheckInterrupt进行阻塞,然后返回是否为中断状态
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL) &#x2F;&#x2F;前一个节点在等待独占性变量释放的通知,所以,当前节点可以阻塞
        return true;
    if (ws &gt; 0) { &#x2F;&#x2F;前一个节点处于取消获取独占性变量的状态,所以,可以跳过去
        &#x2F;&#x2F;返回false
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {
        &#x2F;&#x2F;将上一个节点的状态设置为signal,返回false,
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this); &#x2F;&#x2F;将AQS对象自己传入
    return Thread.interrupted();
}
</code></pre></p>
<h3 id="阻塞和中断"><a href="#阻塞和中断" class="headerlink" title="阻塞和中断"></a>阻塞和中断</h3><p>&emsp;由上述分析，我们知道了<code>AQS</code>通过调用<code>LockSupport</code>的<code>park</code>方法来执行阻塞当前进程的操作。其实，这里的阻塞就是线程不再执行的含义，通过调用这个函数，线程进入阻塞状态，上述的<code>lock</code>操作也就阻塞了，等待中断或在独占性变量被释放。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public static void park(Object blocker) {
    Thread t = Thread.currentThread();
    setBlocker(t, blocker);&#x2F;&#x2F;设置阻塞对象,用来记录线程被谁阻塞的,用于线程监控和分析工具来定位
    UNSAFE.park(false, 0L);&#x2F;&#x2F;让当前线程不再被线程调度,就是当前线程不再执行.
    setBlocker(t, null);
}
</code></pre></p>
<p>&emsp;关于中断的相关知识，我们以后再说，就继续沿着<code>AQS</code>的主线，看一下释放独占性变量的相关操作吧。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-73c6a9c196876ee7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ReentrantLock未获得阻塞,加入队列"></p>
<h3 id="unlock操作"><a href="#unlock操作" class="headerlink" title="unlock操作"></a>unlock操作</h3><p>&emsp;与<code>lock</code>操作类似，<code>unlock</code>操作调用了<code>AQS</code>的<code>relase</code>方法，参数和调用<code>acquire</code>时一样，都是1。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public final boolean release(int arg) {
    if (tryRelease(arg)) { 
    &#x2F;&#x2F;释放独占性变量,起始就是将status的值减1,因为acquire时是加1
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);&#x2F;&#x2F;唤醒head的后继节点
        return true;
    }
    return false;
}
</code></pre></p>
<p>&emsp;由上述代码可知，release就是先调用<code>tryRelease</code>来释放独占性变量。如果成功，那么就看一下是否有等待锁的阻塞线程，如果有，就调用<code>unparkSuccessor</code>来唤醒他们。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">protected final boolean tryRelease(int releases) {
    &#x2F;&#x2F;由于只有一个线程可以获得独占先变量,所以,所有操作不需要考虑多线程
    int c = getState() - releases; 
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) { &#x2F;&#x2F;如果等于0,那么说明锁应该被释放了,否则表示当前线程有多次lock操作.
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre>
<p>&emsp;我们可以看到<code>tryRelease</code>中的逻辑也体现了可重入锁的概念，只有等到<code>state</code>的值为0时，才代表锁真正被释放了。所以独占性变量<code>state</code>的值就代表锁的有无。当<code>state=0</code>时，表示锁未被占有，否在表示当前锁已经被占有。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">private void unparkSuccessor(Node node) {
    .....
     &#x2F;&#x2F;一般来说,需要唤醒的线程就是head的下一个节点,但是如果它获取锁的操作被取消,或在节点为null时
     &#x2F;&#x2F;就直接继续往后遍历,找到第一个未取消的后继节点.
    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
</code></pre>
<p>&emsp;调用了<code>unpark</code>方法后，进行<code>lock</code>操作被阻塞的线程就恢复到运行状态,就会再次执行<code>acquireQueued</code>中的无限for循环中的操作，再次尝试获取锁。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-83eeeb528d9bc58f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ReentrantLock释放锁并通知阻塞线程恢复执行"></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;有关<code>AQS</code>和<code>ReentrantLock</code>的分析就差不多结束了。不得不说，我第一次看到AQS的实现时真是震惊，以前都认为<code>Synchronized</code>和<code>ReentrantLock</code>的实现原理是一致的，都是依靠java虚拟机的功能实现的。没有想到还有<code>AQS</code>这样一个背后大Boss在提供帮助啊。学习了这个类的原理，我们对JUC的很多类的分析就简单了很多。此外，<code>AQS</code>涉及的<code>CAS</code>操作和无锁队列的算法也为我们学习其他无锁算法提供了基础。<strong><em>知识的海洋是无限的啊！</em></strong></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/2019/01/24/AbstractQueuedSynchronizer超详细原理解析-1/" data-id="cju4wk8bs0006ez66x4twvh7m" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-LongAdder解析-1" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2019/01/23/LongAdder解析-1/">LongAdder原理完全解析</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2019/01/23/LongAdder解析-1/">
            <time datetime="2019-01-23T15:10:42.000Z" itemprop="datePublished">2019-01-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/并发/">并发</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/cas/">cas</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;对<code>LongAdder</code>的最初了解是从Coolshell上的一篇文章中获得的，但是一直都没有深入的了解过其实现，只知道它相较于<code>AtomicLong</code>来说，更加适合写多读少的并发情景。今天，我们就研究一下<code>LongAdder</code>的原理，探究一下它如此高效的原因。</p>
<h3 id="基本原理和思想"><a href="#基本原理和思想" class="headerlink" title="基本原理和思想"></a>基本原理和思想</h3><p>&emsp;Java有很多并发控制机制，比如说以AQS为基础的锁或者以CAS为原理的自旋锁。不了解AQS的朋友可以阅读我之前的<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483716&amp;idx=1&amp;sn=22e5160b1fb1068b262d1b0f4fcfc0a0&amp;chksm=fc04c524cb734c327b823acd2cc3ea3ef8620ab2c6c0c1dc1ac6545904f1c3259afd4f2e7450&amp;token=757268630&amp;lang=zh_CN#rd" target="_blank" rel="noopener">AQS源码解析文章</a>。一般来说，CAS适合轻量级的并发操作，也就是并发量并不多，而且等待时间不长的情况，否则就应该使用普通锁，进入阻塞状态，避免CPU空转。</p>
<p>&emsp;所以，如果你有一个Long类型的值会被多线程修改，那么使用CAS进行并发控制比较好，但是如果你是需要锁住一些资源，然后进行数据库操作，那么还是使用阻塞锁比较好。</p>
<p>&emsp;第一种情况下，我们一般都使用<code>AtomicLong</code>。<code>AtomicLong</code>是通过无限循环不停的采取CAS的方法去设置内部的value，直到成功为止。那么当并发数比较多或出现更新热点时，就会导致CAS的失败机率变高，重试次数更多，越多的线程重试，CAS失败的机率越高，形成恶性循环，从而降低了效率。</p>
<p>&emsp;而LongAdder的原理就是降低对value更新的并发数，也就是将对单一value的变更压力分散到多个value值上，降低单个value的“热度”。</p>
<p>&emsp;我们知道<code>LongAdder</code>的大致原理之后，再来详细的了解一下它的具体实现，其中也有很多值得借鉴的并发编程的技巧。</p>
<h3 id="LongAdder的成员变量"><a href="#LongAdder的成员变量" class="headerlink" title="LongAdder的成员变量"></a>LongAdder的成员变量</h3><p>&emsp;<code>LongAdder</code>是<code>Striped64</code>的子类，其有三个比较重要的成员函数，在之后的函数分析中需要使用到，这里先说明一下。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; CPU的数量
static final int NCPU = Runtime.getRuntime().availableProcessors();
&#x2F;&#x2F; Cell对象的数组，长度一般是2的指数
transient volatile Cell[] cells;
&#x2F;&#x2F; 基础value值，当并发较低时，只累加该值
transient volatile long base;
&#x2F;&#x2F; 创建或者扩容Cells数组时使用的自旋锁变量
transient volatile int cellsBusy;
</code></pre>
<p>&emsp;<code>cells</code>是<code>LongAdder</code>的父类<code>Striped64</code>中的<code>Cell</code>数组类型的成员变量。每个<code>Cell</code>对象中都包含一个value值，并提供对这个value值的CAS操作。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">static final class Cell {
    volatile long value;
    Cell(long x) { value = x; }
    final boolean cas(long cmp, long val) {
        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
    }
}
</code></pre></p>
<h3 id="Add操作"><a href="#Add操作" class="headerlink" title="Add操作"></a>Add操作</h3><p>&emsp;我们首先来看一下<code>LongAdder</code>的<code>add</code>函数，其会多次尝试CAS操作将值进行累加，如果成功了就直接返回，失败则继续执行。代码比较复杂，而且涉及的情况比较多，我们就以梳理历次尝试CAS操作为主线，讲清楚这些CAS操作的前提条件和场景。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public void add(long x) {
    Cell[] as; long b, v; int m; Cell a;
    &#x2F;&#x2F; 当cells数组为null时，会进行第一次cas操作尝试。
    if ((as = cells) != null || !casBase(b = base, b + x)) {
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) &lt; 0 ||
            (a = as[getProbe() &amp; m]) == null || 
            !(uncontended = a.cas(v = a.value, v + x)))
            &#x2F;&#x2F; 当cells数组不为null，并且通过getProbe() &amp; m
            &#x2F;&#x2F; 定位的Cell对象不为null时进行第二次CAS操作。
            &#x2F;&#x2F; 如果执行不成功，则进入longAccumulate函数。
            longAccumulate(x, null, uncontended); 
    }
}
</code></pre>
<p>&emsp;当并发量较少时，cell数组尚未初始化，所以只调用<code>casBase</code>函数，对base变量进行CAS累加。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-39fea917eb75cd7e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一个CAS操作"></p>
<p>&emsp;我们来看一下<code>casBase</code>函数相关的源码吧。我们可以认为变量<code>base</code>就是第一个value值，也是基础value变量。先调用casBase函数来cas一下base变量，如果成功了，就不需要在进行下面比较复杂的算法，<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">final boolean casBase(long cmp, long val) {
    return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);
}
</code></pre></p>
<p>&emsp;当并发量逐渐提高时，<code>casBase</code>函数会失败。如果cells数组为null或为空,就直接调用<code>longAccumulate</code>方法。因为cells为null或在为空，说明cells未初始化，所以调用<code>longAccumulate</code>进行初始化。否则继续判断。<br>&emsp;如果cells中已经初始化，就继续进行后续判断。我们先来理解一下<code>getProbe() &amp; m</code>的这个操作吧，可以把这个操作当作一次计算”hash”值，然后将cells中这个位置的Cell对象赋值给变量a。如果变量a不为null，那么就调用该对象的cas方法去设置其value值。如果a为null，或在cas赋值发生冲突，那么调用<code>longAccumulate</code>方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-8433413840b2a94b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二个CAS操作"></p>
<h3 id="LongAccumulate方法"><a href="#LongAccumulate方法" class="headerlink" title="LongAccumulate方法"></a>LongAccumulate方法</h3><p>&emsp;<code>longAccumulate</code>函数比较复杂，带有我的注释的代码已经贴在了文章后边，这里我们就只讲一下其中比较关键的一些技巧和思想。</p>
<p>&emsp;首先，我们都知道只有当对<code>base</code>的cas操作失败之后，<code>LongAdder</code>才引入<code>Cell</code>数组．所以在<code>longAccumulate</code>中就是对<code>Cell</code>数组进行操作，分别涉及了数组的初始化，扩容和设置某个位置的Cell对象等操作。</p>
<p>&emsp;在这段代码中，关于<code>cellBusy</code>的cas操作构成了一个SpinLock，这就是经典的SpinLock的编程技巧，大家可以学习一下。</p>
<p>&emsp;我们先来看一下<code>longAccumulate</code>的主体代码，首先是一个无限for循环，然后根据cells数组的状态来判断是要进行cells数组的初始化，还是进行对象添加或者扩容。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">final void longAccumulate(long x, LongBinaryOperator fn,
                             boolean wasUncontended) {
       int h;
       if ((h = getProbe()) == 0) { 
           &#x2F;&#x2F;获取PROBE变量，探针变量，与当前运行的线程相关，不同线程不同
           ThreadLocalRandom.current(); 
       &#x2F;&#x2F;初始化PROBE变量，和getProbe都使用Unsafe类提供的原子性操作。
           h = getProbe();
           wasUncontended = true;
       }
       boolean collide = false;
       for (;;) { &#x2F;&#x2F;cas经典无限循环，不断尝试
           Cell[] as; Cell a; int n; long v;
           if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) { 
           &#x2F;&#x2F; cells不为null,并且数组size大于0,表示cells已经初始化了
           &#x2F;&#x2F; 初始化Cell对象并设置到数组中或者进行数组扩容
           }
           else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) {
           &#x2F;&#x2F;cells数组未初始化，获得cellsBusy lock,进行cells数组的初始化
           &#x2F;&#x2F; cells数组初始化操作
           }
          &#x2F;&#x2F;如果初始化数组失败了，那就再次尝试一下直接cas base变量，
          &#x2F;&#x2F; 如果成功了就直接返回，这是最后一个进行CAS操作的地方。
           else if (casBase(v = base, ((fn == null) ? v + x :
                                       fn.applyAsLong(v, x))))
               break;
       }
   }
</code></pre>
<p>&emsp;进行Cell数组代码如下所示，它首先调用<code>casCellsBusy</code>函数获取了<code>cellsBusy</code>‘锁’，然后进行数组的初始化操作，最后将<code>cellBusy</code>‘锁’释放掉。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; 注意在进入这段代码之前已经casCellsBusy获得cellsBusy这个锁变量了。
boolean init = false;
try {
    if (cells == as) {
        Cell[] rs = new Cell[2];
        rs[h &amp; 1] = new Cell(x); &#x2F;&#x2F;设置x的值为cell对象的value值
        cells = rs;
        init = true;
    }
} finally {
    cellsBusy = 0;
}
if (init)
    break;
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-71b68d5e008eca77.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第三个CAS操作"></p>
<p>&emsp;如果Cell数组已经初始化过了，那么就进行Cell数组的设置或者扩容。这部分代码有一系列的if else的判断，如果前一个条件不成立，才会进入下一条判断。</p>
<p>&emsp;首先，当Cell数组中对应位置的cell对象为null时，表明该位置的Cell对象需要进行初始化，所以使用<code>casCellsBusy</code>函数获取’锁’，然后初始化Cell对象，并且设置进cells数组，最后释放掉’锁’。</p>
<p>&emsp;当Cell数组中对应位置的cell对象不为null，则直接调用其cas操作进行累加。</p>
<p>&emsp;当上述操作都失败后，认为多个线程在对同一个位置的Cell对象进行操作，这个Cell对象是一个“热点”，所以Cell数组需要进行扩容，将热点分散。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">if ((a = as[(n - 1) &amp; h]) == null) { &#x2F;&#x2F;通过与操作计算出来需要操作的Cell对象的坐标
    if (cellsBusy == 0) { &#x2F;&#x2F;volatile 变量，用来实现spinLock,来在初始化和resize cells数组时使用。
    &#x2F;&#x2F;当cellsBusy为0时，表示当前可以对cells数组进行操作。 
        Cell r = new Cell(x);&#x2F;&#x2F;将x值直接赋值给Cell对象
        if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {&#x2F;&#x2F;如果这个时候cellsBusy还是0
        &#x2F;&#x2F;就cas将其设置为非０，如果成功了就是获得了spinLock的锁．可以对cells数组进行操作．
        &#x2F;&#x2F;如果失败了，就会再次执行一次循环
            boolean created = false;
            try {
                Cell[] rs; int m, j;
                &#x2F;&#x2F;判断cells是否已经初始化，并且要操作的位置上没有cell对象．
                if ((rs = cells) != null &amp;&amp;
                    (m = rs.length) &gt; 0 &amp;&amp;
                    rs[j = (m - 1) &amp; h] == null) {
                    rs[j] = r;　&#x2F;&#x2F;将之前创建的值为x的cell对象赋值到cells数组的响应位置．
                    created = true;
                }
            } finally {
                &#x2F;&#x2F;经典的spinLock编程技巧，先获得锁，然后try finally将锁释放掉
                &#x2F;&#x2F;将cellBusy设置为0就是释放锁．
                cellsBusy = 0;
            }
            if (created)
                break;　&#x2F;&#x2F;如果创建成功了，就是使用x创建了新的cell对象，也就是新创建了一个分担热点的value
            continue; 
        }
    }
    collide = false; &#x2F;&#x2F;未发生碰撞
}
else if (!wasUncontended)&#x2F;&#x2F;是否已经发生过一次cas操作失败
    wasUncontended = true; &#x2F;&#x2F;设置成true,以便第二次进入下一个else if 判断
else if (a.cas(v = a.value, ((fn == null) ? v + x :
                            fn.applyAsLong(v, x))))
    　&#x2F;&#x2F;fn是操作类型，如果是空，就是相加，所以让a这个cell对象中的value值和x相加，然后在cas设置，如果成果
    &#x2F;&#x2F;就直接返回
    break;
else if (n &gt;= NCPU || cells != as)
　　&#x2F;&#x2F;如果cells数组的大小大于系统的可获得处理器数量或在as不再和cells相等．
    collide = false;
else if (!collide)
    collide = true;
else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {
　　&#x2F;&#x2F;再次获得cellsBusy这个spinLock,对数组进行resize
    try {
        if (cells == as) {&#x2F;&#x2F;要再次检测as是否等于cells以免其他线程已经对cells进行了操作．
            Cell[] rs = new Cell[n &lt;&lt; 1]; &#x2F;&#x2F;扩容一倍
            for (int i = 0; i &lt; n; ++i)
                rs[i] = as[i];
            cells = rs;&#x2F;&#x2F;赋予cells一个新的数组对象
        }
    } finally {
        cellsBusy = 0;
    }
    collide = false;
    continue;
}
h = advanceProbe(h);&#x2F;&#x2F;由于使用当前探针变量无法操作成功，所以重新设置一个,再次尝试
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-7bd9e13169f41c0f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第四个CAS操作"></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;本篇文章写的不是很好，我写完之后又看了一遍coolshell上的关于<code>LongAdder</code>的文章，感觉自己没有人家写的那么简洁明了。我对代码细节的注释和投入太多了。其实很多代码大家都可以看懂，并不需要大量的代码片段加注释。以后要注意一下。之后会接着研究一下JUC包中的其他类，希望大家多多关注。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/2019/01/23/LongAdder解析-1/" data-id="cju4wk8ck001qez6679gqfui8" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-MySQL探秘-八-InnoDB的事务" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/12/10/MySQL探秘-八-InnoDB的事务/">MySQL探秘(八):InnoDB的事务</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/12/10/MySQL探秘-八-InnoDB的事务/">
            <time datetime="2018-12-10T13:45:39.000Z" itemprop="datePublished">2018-12-10</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/MySQL/">MySQL</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;事务是数据库最为重要的机制之一，凡是使用过数据库的人，都了解数据库的事务机制，也对ACID四个基本特性如数家珍。但是聊起事务或者ACID的底层实现原理，往往言之不详，不明所以。所以，今天我们就一起来分析和探讨InnoDB的事务机制，希望能建立起对事务底层实现原理的具体了解。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-2e908e18a2de4210.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事务的四大特性"></p>
<p>&emsp;数据库事务具有ACID四大特性。ACID是以下4个词的缩写：</p>
<ul>
<li>原子性(atomicity) ：事务最小工作单元，要么全成功，要么全失败 。</li>
<li>一致性(consistency)： 事务开始和结束后，数据库的完整性不会被破坏 。</li>
<li>隔离性(isolation) ：不同事务之间互不影响，四种隔离级别为RU（读未提交）、RC（读已提交）、RR（可重复读）、SERIALIZABLE （串行化）。</li>
<li>持久性(durability) ：事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失 。</li>
</ul>
<p>&emsp;下面，我们就以一个具体实例来介绍数据库事务的原理，并介绍InnoDB是如何实现ACID四大特性的。</p>
<h3 id="示例介绍"><a href="#示例介绍" class="headerlink" title="示例介绍"></a>示例介绍</h3><p>&emsp;我们首先来看一下具体的示例。大家可以自己亲自试验一下，这样理解和记忆都会更加深刻。<br>&emsp;首先，使用如下的SQL语句创建两张表，分别是goods和trade，代表货物和交易。并向goods表中插入一条记录，id为1的货物数量为10。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">CREATE TABLE goods (id INT, num INT, PRIMARY KEY(id));
CREATE TABLE trade (id INT, goods_id INT, user_id INT, PRIMARY KEY(id));
INSERT INTO goods VALUES(1, 10);
</code></pre>
<p>&emsp;然后打开终端，连接数据库，开启会话一，先用BEGIN显示开启一个事务。会话一先将goods表中id为1的货物的数量减一，然后向trade表中添加一笔交易的记录，最后使用COMMIT显示提交事务。<br>&emsp;而会话二则先查询goods表中id为1的货物数量，然后向trade表中添加一笔交易记录，接着更新goods表中id为1的货物的数量，最后使用ROLLBACK进行事务的回滚。其中，两个会话中执行的具体语句和先后顺序如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-e1cb53add98d666d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例具体语句和执行顺序"></p>
<p>&emsp;这个示例可以体现数据库事务的很多特性，我们一一来介绍。首先会话一的操作2更新了id为1的货物的数量，但是会话二的操作5读出来的数量仍然是10，这体现了事务的隔离性，使用InnoDB的<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483698&amp;idx=1&amp;sn=3654042755c7ea0922e5d5b462930946&amp;chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制机制</a>实现。<br>&emsp;会话二的操作7也要更新同种货物的数量，此时因为会话一的操作2已经更新了该货物的数量，InnoDB已经锁住了该记录的行锁，所以操作7会被阻塞，直到会话一COMMIT。但是会话一的操作4和会话二的操作7都是向trade表中插入记录，后者却不会因为前者而阻塞，因为二者插入的不是同一行记录。锁机制是一种常见的并发控制机制，它和多版本控制机制一起实现了InnoDB事务的隔离性，关于InnoDB锁相关的具体内容可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483694&amp;idx=1&amp;sn=671ad369f67441c7d1572110066d5695&amp;chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483702&amp;idx=1&amp;sn=669fb9f413db0cc744bdb5b9ec8f725e&amp;chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>。</p>
<p>&emsp;会话一事务最终使用COMMIT提交了事务而会话二事务则使用ROLLBACK回滚了整个事务，这体现了事务的原子性。即事务的一系列操作要么全部执行(COMMIT)，要么就全部不执行(ROLLBACK)，不存在只执行一部分的情况。InnoDB使用事务日志系统来实现事务的原子性。这里有的同学就会问了，如果中途连接断开或者Server Crash会怎么样。能怎么样，直接自动回滚呗。</p>
<p>&emsp;一旦会话一使用COMMIT操作提交事务成功后，那么数据一定会被写入到数据库中并持久的存储起来，这体现了事务的持久性。InnoDB使用<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483683&amp;idx=1&amp;sn=5225ab3481c38bb57297a36df8e62bce&amp;chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">redo log机制</a>来实现事务的持久性。</p>
<p>&emsp;而事务的一致性比较难以理解，简单的讲在事务开始时，此时数据库有一种状态，这个状态是所有的MySQL对象处于一致的状态，例如数据库完整性约束正确，日志状态一致等。当事务提交后，这时数据库又有了一个新的状态，不同的数据，不同的索引，不同的日志等。但此时，约束，数据，索引，日志等MySQL各种状态还是要保持一致性。 也就是说数据库从一个一致性的状态，变到另一个一致性的状态。事务执行后，并没有破坏数据库的完整性约束。</p>
<p>&emsp;下面我们就来详细讲解一下上述示例涉及的事务的ACID特性的具体实现原理。<strong>总结来说，事务的隔离性由多版本控制机制和锁实现，而原子性、一致性和持久性通过InnoDB的redo log、undo log和Force Log at Commit机制来实现</strong>。</p>
<h3 id="原子性，持久性和一致性"><a href="#原子性，持久性和一致性" class="headerlink" title="原子性，持久性和一致性"></a>原子性，持久性和一致性</h3><p>&emsp;原子性，持久性和一致性主要是通过redo log、undo log和Force Log at Commit机制机制来完成的。redo log用于在崩溃时恢复数据，undo log用于对事务的影响进行撤销，也可以用于多版本控制。而Force Log at Commit机制保证事务提交后redo log日志都已经持久化。<br>&emsp;开启一个事务后，用户可以使用COMMIT来提交，也可以用ROLLBACK来回滚。其中COMMIT或者ROLLBACK执行成功之后，数据一定是会被全部保存或者全部回滚到最初状态的，这也体现了事务的原子性。但是也会有很多的异常情况，比如说事务执行中途连接断开，或者是执行COMMIT或者ROLLBACK时发生错误，Server Crash等，此时数据库会自动进行回滚或者重启之后进行恢复。</p>
<p>&emsp;我们先来看一下redo log的原理，redo log顾名思义，就是重做日志，每次数据库的SQL操作导致的数据变化它都会记录一下，<strong>具体来说，redo log是物理日志，记录的是数据库页的物理修改操作</strong>。如果数据发生了丢失，数据库可以根据redo log进行数据恢复。</p>
<p>&emsp;InnoDB通过Force Log at Commit机制实现事务的持久性，即当事务COMMIT时，必须先将该事务的所有日志都写入到redo log文件进行持久化之后，COMMIT操作才算完成。<br>&emsp;当事务的各种SQL操作执行时，即会在缓冲区中修改数据，也会将对应的redo log写入它所属的缓存。当事务执行COMMIT时，与该事务相关的redo log缓冲必须都全部刷新到磁盘中之后COMMIT才算执行成功。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-99cd9e5402f46d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据库日志和数据落盘机制"></p>
<p>&emsp;redo log写入磁盘时，必须进行一次操作系统的fsync操作，防止redo log只是写入了操作系统的磁盘缓存中。参数innodb_flush_log_at_trx_commit可以控制redo log日志刷新到磁盘的策略，它的具体作用可以查阅<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483683&amp;idx=1&amp;sn=5225ab3481c38bb57297a36df8e62bce&amp;chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB的磁盘文件及落盘机制</a></p>
<p>&emsp;redo log全部写入磁盘后事务就算COMMIT成功了，但是此时事务修改的数据还在内存的缓冲区中，称其为脏页，这些数据会依据检查点(CheckPoint)机制择时刷新到磁盘中，然后删除相应的redo log，但是如果在这个过程中数据库Crash了，那么数据库重启时，会依据redo log file将那些还在内存中未更新到磁盘上的数据进行恢复。</p>
<p>&emsp;数据库为了提高性能，数据页在内存修改后并不是每次都会刷到磁盘上。而是引入checkpoint机制，择时将数据页落盘，checkpoint记录之前的数据页保证一定落盘了，这样相关的redo log就没有用了(由于InnoDB redo log file循环使用，这时这部分日志就可以被覆盖)，checkpoint之后的数据页有可能落盘，也有可能没有落盘，所以checkpoint之后的redo log file在崩溃恢复的时候还是需要被使用的。InnoDB会依据脏页的刷新情况，定期推进checkpoint，从而减少数据库崩溃恢复的时间。检查点的信息在第一个日志文件的头部。</p>
<p>&emsp;数据库崩溃重启后需要从redo log中把未落盘的脏页数据恢复出来，重新写入磁盘，保证用户的数据不丢失。当然，在崩溃恢复中还需要回滚没有提交的事务。由于回滚操作需要undo日志的支持，undo日志的完整性和可靠性需要redo日志来保证，所以崩溃恢复先做redo恢复数据，然后做undo回滚。</p>
<p>&emsp;在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-6a680cf9597332b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据和回滚日志的逻辑存储结构.jpg"></p>
<p>&emsp;undo log的存储不同于redo log，它存放在数据库内部的一个特殊的段(segment)中，这个段称为回滚段。回滚段位于共享表空间中。undo段中的以undo page为更小的组织单位。undo page和存储数据库数据和索引的页类似。因为redo log是物理日志，记录的是数据库页的物理修改操作。所以undo log的写入也会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。如上图所示，表空间中有回滚段和叶节点段和非叶节点段，而三者都有对应的页结构。</p>
<p>&emsp;我们再来总结一下数据库事务的整个流程，如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-c46ad59604b75f65.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事务的相关流程"></p>
<p>&emsp;事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页，然后redo log按照时间或者空间等条件进行落盘，undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了。此时，事务还未COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进行数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使用undo log进行事务回滚。事务执行COMMIT操作时，会将本事务相关的所有redo log都进行落盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发生了崩溃，则只使用redo log恢复数据。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>&emsp;InnoDB事务的隔离性主要通过多版本控制机制和锁机制实现，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483698&amp;idx=1&amp;sn=3654042755c7ea0922e5d5b462930946&amp;chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制</a>，<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483694&amp;idx=1&amp;sn=671ad369f67441c7d1572110066d5695&amp;chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483702&amp;idx=1&amp;sn=669fb9f413db0cc744bdb5b9ec8f725e&amp;chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>三篇文章。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;本来想一篇文章将MySQL的事务机制讲明白，写完自己读了一遍，还是发现内容有些晦涩难懂，复杂的知识本来就是很难讲明白的，夫夷以近，则游者众；险以远，则至者少，希望读者以本文作为一篇指引性的文章，自己再去更加深入的地方去探秘。不过，能将复杂知识讲解的通俗简单也是一项很大的本领，文字和讲解能力还是需要提示的。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483664&amp;idx=1&amp;sn=a4aea45edf13b367ee17539eaff4874b&amp;chksm=fc04c570cb734c66447aec4344288025bfe6ba7d715af31dc6d60d65411cd90a05d9b02e749d&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Mysql探索(一):B-Tree索引
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483669&amp;idx=1&amp;sn=de5770a2c732a688b6377b4201bf1577&amp;chksm=fc04c575cb734c63fb5da0a871c5447c0cbbaea2a0a39d3896058b546e3d3a85575f575faf4b&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">数据库内部存储结构探索
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483673&amp;idx=1&amp;sn=cba5118dd4705035c40089a9e59305a9&amp;chksm=fc04c579cb734c6fbc0e67006493d5727ed62262ac243ec74ad6c088cb4e3bcd53dfad73caaf&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(二)：SQL语句执行过程详解
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483676&amp;idx=1&amp;sn=b82135c479c806d2b97d026e143f346a&amp;chksm=fc04c57ccb734c6a530b209b3d78de96c30291228e2296179565cc367107df9bc05bcc325c1c&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(三):InnoDB的内存结构和特性
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483683&amp;idx=1&amp;sn=5225ab3481c38bb57297a36df8e62bce&amp;chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(四):InnoDB的磁盘文件及落盘机制
</a></li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483694&amp;idx=1&amp;sn=671ad369f67441c7d1572110066d5695&amp;chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(五):InnoDB锁的类型和状态查询
</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483698&amp;idx=1&amp;sn=3654042755c7ea0922e5d5b462930946&amp;chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&amp;token=731065842&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(六):InnoDB一致性非锁定读
</a></p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-7d960275042f309d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://mysql.taobao.org/monthly/2017/12/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB 事务系统</a></li>
<li><a href="http://mysql.taobao.org/monthly/2015/06/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB 崩溃恢复过程
</a></li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/2018/12/10/MySQL探秘-八-InnoDB的事务/" data-id="cju4wk8cq0024ez663chitwm2" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-MySQL探秘-六-InnoDB一致性非锁定读" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/11/18/MySQL探秘-六-InnoDB一致性非锁定读/">MySQL探秘(六):InnoDB一致性非锁定读</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/11/18/MySQL探秘-六-InnoDB一致性非锁定读/">
            <time datetime="2018-11-18T13:45:39.000Z" itemprop="datePublished">2018-11-18</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/MySQL/">MySQL</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVVC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6%E7%AE%80%E5%8D%95%E7%9A%84MVVC.jpg" alt="一致性非锁定读示意图"></p>
<p>&emsp;上图直观地展现了InnoDB一致性非锁定读的机制。之所以称其为非锁定读，是因为不需要等待行上排他锁的释放。快照数据是指该行的之前版本的数据，每行记录可能有多个版本，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVVC)。InnoDB是通过undo log来实现MVVC。undo log本身用来在事务中回滚数据，因此快照数据本身是没有额外开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p>
<p>&emsp;一致性非锁定读是InnoDB默认的读取方式，即读取不会占用和等待行上的锁。但是并不是在每个事务隔离级别下都是采用此种方式。此外，即使都是使用一致性非锁定读，但是对于快照数据的定义也各不相同。</p>
<p>&emsp;在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。然而，对于快照数据的定义却不同。在READ COMMITTED事务隔离级别下，一致性非锁定读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，则读取事务开始时的行数据版本。</p>
<p>&emsp;我们下面举个例子来详细说明一下上述的情况。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike"># session A
mysql&gt; BEGIN;
mysql&gt; SELECT * FROM test WHERE id = 1;
</code></pre></p>
<p>&emsp;我们首先在会话A中显示地开启一个事务，然后读取test表中的id为1的数据，但是事务并没有结束。于此同时，用户在开启另一个会话B，这样可以模拟并发的操作，然后对会话B做出如下的操作：</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike"># session B
mysql&gt; BEGIN;
mysql&gt; UPDATE test SET id = 3 WHERE id = 1;
</code></pre>
<p>&emsp;在会话B的事务中，将test表中id为1的记录修改为id=3，但是事务同样也没有提交，这样id=1的行其实加了一个排他锁。由于InnoDB在READ COMMITTED和REPEATABLE READ事务隔离级别下使用一致性非锁定读，这时如果会话A再次读取id为1的记录，仍然能够读取到相同的数据。此时，READ COMMITTED和REPEATABLE READ事务隔离级别没有任何区别。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6%E4%BC%9A%E8%AF%9DA%E5%92%8C%E4%BC%9A%E8%AF%9DB.jpg" alt="会话A和会话B示意图"></p>
<p>&emsp;如上图所示，当会话B提交事务后，会话A再次运行<code>SELECT * FROM test WHERE id = 1</code>的SQL语句时，两个事务隔离级别下得到的结果就不一样了。<br>&emsp;对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本，如果行被锁定了，则读取该行版本的最新一个快照。因为会话B的事务已经提交，所以在该隔离级别下上述SQL语句的结果集是空的。<br>&emsp;对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据，因此，在该隔离级别下，上述SQL语句仍然会获得相同的数据。</p>
<h4 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h4><p>&emsp;我们首先来看一下wiki上对MVVC的定义：</p>
<blockquote>
<p>Multiversion concurrency control (MCC or MVCC), is a concurrency control<br>method commonly used by database management systems to provide<br>concurrent access to the database and in programming languages to<br>implement transactional memory.</p>
</blockquote>
<p>&emsp;由定义可知，MVVC是用于数据库提供并发访问控制的并发控制技术。<br>数据库的并发控制机制有很多，最为常见的就是锁机制。锁机制一般会给竞争资源加锁，阻塞读或者写操作来解决事务之间的竞争条件，最终保证事务的可串行化。而MVVC则引入了另外一种并发控制，它让读写操作互不阻塞，每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回，由此解决了事务的竞争条件。<br>&emsp;考虑一个现实场景。管理者要查询所有用户的存款总额，假设除了用户A和用户B之外，其他用户的存款总额都为0，A、B用户各有存款1000，所以所有用户的存款总额为2000。但是在查询过程中，用户A会向用户B进行转账操作。转账操作和查询总额操作的时序图如下图所示。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6MVVC%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF.jpg" alt="转账和查询的时序图"></p>
<p>&emsp;如果没有任何的并发控制机制，查询总额事务先读取了用户A的账户存款，然后转账事务改变了用户A和用户B的账户存款，最后查询总额事务继续读取了转账后的用户B的账号存款，导致最终统计的存款总额多了100元，发生错误。</p>
<p>&emsp;使用锁机制可以解决上述的问题。查询总额事务会对读取的行加锁，等到操作结束后再释放所有行上的锁。因为用户A的存款被锁，导致转账操作被阻塞，直到查询总额事务提交并将所有锁都释放。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6%E8%BD%AC%E8%B4%A6%E4%BD%BF%E7%94%A8%E9%94%81.jpg" alt="使用锁机制"><br>&emsp;但是这时可能会引入新的问题，当转账操作是从用户B向用户A进行转账时会导致死锁。转账事务会先锁住用户B的数据，等待用户A数据上的锁，但是查询总额的事务却先锁住了用户A数据，等待用户B的数据上的锁。</p>
<p>&emsp;使用MVVC机制也可以解决这个问题。查询总额事务先读取了用户A的账户存款，然后转账事务会修改用户A和用户B账户存款，查询总额事务读取用户B存款时不会读取转账事务修改后的数据，而是读取本事务开始时的数据副本(在REPEATABLE READ隔离等级下)。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6%E8%BD%AC%E8%B4%A6%E4%BD%BF%E7%94%A8MVVC.jpg" alt="使用MVVC机制"></p>
<p>&emsp;MVCC使得数据库读不会对数据加锁，普通的SELECT请求不会加锁，提高了数据库的并发处理能力。借助MVCC，数据库可以实现READ COMMITTED，REPEATABLE READ等隔离级别，用户可以查看当前数据的前一个或者前几个历史版本，保证了ACID中的I特性（隔离性)</p>
<h4 id="InnoDB的MVVC实现"><a href="#InnoDB的MVVC实现" class="headerlink" title="InnoDB的MVVC实现"></a>InnoDB的MVVC实现</h4><p>&emsp;多版本并发控制仅仅是一种技术概念，并没有统一的实现标准， 其的核心理念就是数据快照，不同的事务访问不同版本的数据快照，从而实现不同的事务隔离级别。虽然字面上是说具有多个版本的数据快照，但这并不意味着数据库必须拷贝数据，保存多份数据文件，这样会浪费大量的存储空间。InnoDB通过事务的undo日志巧妙地实现了多版本的数据快照。<br>&emsp;数据库的事务有时需要进行回滚操作，这时就需要对之前的操作进行undo。因此，在对数据进行修改时，InnoDB会产生undo log。当事务需要进行回滚时，InnoDB可以利用这些undo log将数据回滚到修改之前的样子。<br>&emsp;根据行为的不同 undo log 分为两种 insert undo log和update undo log。<br>&emsp;insert undo log 是在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对于其它事务此记录是不可见的，所以 insert undo log 可以在事务提交后直接删除而不需要进行 purge 操作。<br>&emsp;update undo log 是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，为了提供 MVCC机制，因此 update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。<br>&emsp;为了保证事务并发操作时，在写各自的undo log时不产生冲突，InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际上是一种 Undo 文件组织方式。<br>&emsp;InnoDB行记录有三个隐藏字段：分别对应该行的rowid、事务号db_trx_id和回滚指针db_roll_ptr，其中db_trx_id表示最近修改的事务的id，db_roll_ptr指向回滚段中的undo log。如下图所示。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6innodb%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%88%9D.jpg" alt="初始状态"></p>
<p>&emsp;当事务2使用UPDATE语句修改该行数据时，会首先使用排他锁锁定改行，将该行当前的值复制到undo log中，然后再真正地修改当前行的值，最后填写事务ID，使用回滚指针指向undo log中修改前的行。如下图所示。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6innodb%E5%AE%9E%E7%8E%B02.jpg" alt="第一次修改"></p>
<p>&emsp;当事务3进行修改与事务2的处理过程类似，如下图所示。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6innodb%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A13.jpg" alt="第二次修改"></p>
<p>&emsp;REPEATABLE READ隔离级别下事务开始后使用MVVC机制进行读取时，会将当时活动的事务id记录下来，记录到Read View中。READ COMMITTED隔离级别下则是每次读取时都创建一个新的Read View。<br>&emsp;Read View是InnoDB中用于判断记录可见性的数据结构，记录了一些用于判断可见性的属性。</p>
<ul>
<li>low_limit_id：某行记录的db_trx_id &lt; 该值，则该行对于当前Read View是一定可见的</li>
<li>up_limit_id：某行记录的db_trx_id &gt;= 该值，则该行对于当前read view是一定不可见的</li>
<li>low_limit_no：用于purge操作的判断</li>
<li>rw_trx_ids：读写事务数组</li>
</ul>
<p>&emsp;Read View创建后，事务再次进行读操作时比较记录的db_trx_id和Read View中的low_limit_id，up_limit_id和读写事务数组来判断可见性。</p>
<p>&emsp;如果该行中的db_trx_id等于当前事务id，说明是事务内部发生的更改，直接返回该行数据。否则的话，如果db_trx_id小于up_limit_id，说明是事务开始前的修改，则该记录对当前Read View是可见的，直接返回该行数据。</p>
<p>&emsp;如果db_trx_id大于或者等于low_limit_id，则该记录对于该Read View一定是不可见的。如果db_trx_id位于[up_limit_id, low_limit_id)范围内，需要在活跃读写事务数组(rw_trx_ids)中查找db_trx_id是否存在，如果存在，记录对于当前Read View是不可见的。<br>&emsp;如果记录对于Read View不可见，需要通过记录的DB_ROLL_PTR指针遍历undo log，构造对当前Read View可见版本数据。<br>&emsp;简单来说，Read View记录读开始时及其之后，所有的活动事务，这些事务所做的修改对于Read View是不可见的。除此之外，所有其他的小于创建Read View的事务号的所有记录均可见。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>&emsp;我们后续还会学习InnoDB的锁的相关的知识，请大家持续关注。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483664&amp;idx=1&amp;sn=a4aea45edf13b367ee17539eaff4874b&amp;chksm=fc04c570cb734c66447aec4344288025bfe6ba7d715af31dc6d60d65411cd90a05d9b02e749d&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Mysql探索(一):B-Tree索引
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483669&amp;idx=1&amp;sn=de5770a2c732a688b6377b4201bf1577&amp;chksm=fc04c575cb734c63fb5da0a871c5447c0cbbaea2a0a39d3896058b546e3d3a85575f575faf4b&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">数据库内部存储结构探索
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483673&amp;idx=1&amp;sn=cba5118dd4705035c40089a9e59305a9&amp;chksm=fc04c579cb734c6fbc0e67006493d5727ed62262ac243ec74ad6c088cb4e3bcd53dfad73caaf&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(二)：SQL语句执行过程详解
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483676&amp;idx=1&amp;sn=b82135c479c806d2b97d026e143f346a&amp;chksm=fc04c57ccb734c6a530b209b3d78de96c30291228e2296179565cc367107df9bc05bcc325c1c&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(三):InnoDB的内存结构和特性
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483683&amp;idx=1&amp;sn=5225ab3481c38bb57297a36df8e62bce&amp;chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(四):InnoDB的磁盘文件及落盘机制
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483694&amp;idx=1&amp;sn=671ad369f67441c7d1572110066d5695&amp;chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(五):InnoDB锁的类型和状态查询
</a></li>
</ul>
<p><img src="http://pie6tw55i.bkt.clouddn.com/qrcode_for_gh_bcc90a2a52c5_344.jpg" alt=""></p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="http://mysql.taobao.org/monthly/2018/03/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2018/03/01/</a></li>
<li><a href="https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/" target="_blank" rel="noopener">https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/</a></li>
<li><a href="http://hedengcheng.com/?p=148" target="_blank" rel="noopener">http://hedengcheng.com/?p=148</a></li>
<li>《唐成－2016PG大会-数据库多版本实现内幕.pdf》</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/2018/11/18/MySQL探秘-六-InnoDB一致性非锁定读/" data-id="cju4wk8ct002bez66f6cpbt4f" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/2019/04/06/基于Redis和Lua的分布式限流/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/分布式/">分布式</a></p>
                            <p class="item-title"><a href="/2019/04/06/基于Redis和Lua的分布式限流/" class="title">基于Redis和Lua的分布式限流</a></p>
                            <p class="item-date"><time datetime="2019-04-06T02:51:31.000Z" itemprop="datePublished">2019-04-06</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/2019/03/30/超详细的Guava-RateLimiter限流原理解析/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/03/30/超详细的Guava-RateLimiter限流原理解析/" class="title">超详细的Guava RateLimiter限流原理解析</a></p>
                            <p class="item-date"><time datetime="2019-03-30T05:33:07.000Z" itemprop="datePublished">2019-03-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/2019/03/09/TCP-IP的底层队列/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/网络/">网络</a></p>
                            <p class="item-title"><a href="/2019/03/09/TCP-IP的底层队列/" class="title">TCP/IP的底层队列</a></p>
                            <p class="item-date"><time datetime="2019-03-09T15:24:38.000Z" itemprop="datePublished">2019-03-09</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/2019/02/27/TCP拥塞控制算法简介/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/网络/">网络</a></p>
                            <p class="item-title"><a href="/2019/02/27/TCP拥塞控制算法简介/" class="title">TCP拥塞控制算法简介</a></p>
                            <p class="item-date"><time datetime="2019-02-27T15:08:05.000Z" itemprop="datePublished">2019-02-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/2019/02/17/Spring-AOP-二-修饰者模式和JDK-Proxy/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/02/17/Spring-AOP-二-修饰者模式和JDK-Proxy/" class="title">Spring AOP(二) 修饰者模式和JDK Proxy</a></p>
                            <p class="item-date"><time datetime="2019-02-17T05:20:37.000Z" itemprop="datePublished">2019-02-17</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">21</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/NetWork/">NetWork</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Network/">Network</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/源码分析/">源码分析</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android性能/">Android性能</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JavaScript/">JavaScript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/杂记/">杂记</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/NIO/">NIO</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/c/数据结构/">数据结构</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/函数式编程/">函数式编程</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端-Spring/">后端 - Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器/">容器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/思考/">思考</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/生活/">生活</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/源码/">源码</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/源码/视图/">视图</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/综合/">综合</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计划/">计划</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计/">设计</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">3</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2019 remCarpediem<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        


    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>