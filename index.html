
 <!DOCTYPE HTML>
<html lang="Chinese">
<head>
  <meta charset="UTF-8">
  
    <title>Carpediem</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="remCarpediem">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Carpediem">
<meta property="og:url" content="http://remcarpediem.com/index.html">
<meta property="og:site_name" content="Carpediem">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Carpediem">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="Carpediem" type="application/atom+xml">
    
    
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Carpediem">Carpediem</a></h1>
				<h2 class="blog-motto">blog of nobody</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:remcarpediem.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/10/Spring-Cloud-Stream-一-：Spring基础知识/" title="Spring Cloud Stream(一)：Spring基础知识" itemprop="url">Spring Cloud Stream(一)：Spring基础知识</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2017-10-10T13:51:45.000Z" itemprop="datePublished"> Published 2017-10-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;我研究和阅读<code>Spring Cloud Stream</code>源码已经有一个多月了，但是由于自己的Spring基础知识不是很充足，所以导致很多地方都没有融会贯通，并且相关的文章一直无从下手。于是我先整理了当时阅读代码时的知识点记录，算是源码分析之前的基础知识储备吧，整理的有些杂乱，希望大家理解。<br>&emsp;本文涉及的Spring知识如下：</p>
<ul>
<li>Spring Boot的<code>@Import</code>用法和原理,与<code>Configuration</code>和<code>ImportBeanDefinitionRegistrar</code>相关</li>
<li>Bean初始化各个周期的回调，比如<code>InitializingBean</code>,<code>BeanPostProcessor</code>,<code>SmartInitializingSingleton</code></li>
<li><code>FactoryBean</code>和<code>MethodInterceptor</code></li>
<li><code>Aware</code>系列回调</li>
<li><code>Lifecycle</code>和<code>SmartLifecycle</code>和<code>DefaultLifecycleProcessor</code></li>
</ul>
<h4 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h4><p> <code>BeanDefinitionRegistryPostProcessor</code>实现了<code>BeanFactoryPostProcessor</code>接口，是Spring框架的<code>BeanDefinitionRegistry</code>的后处理器，用来注册额外的<code>BeanDefinition</code>。<code>postProcessBeanDefinitionRegistry</code>方法会在所有的<code>BeanDefinition</code>已经被加载了，但是所有的<code>Bean</code>还没有被创建前调用。<code>BeanDefinitionRegistryPostProcessor</code>经常被用来注册<code>BeanFactoryPostProcessor</code>的<code>BeanDefinition</code>。</p>
<h4 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h4><p> <code>@Import</code>注解用来支持在<code>Configuration</code>类中引入其他的配置类，包括<code>Configuration</code>类，<code>ImportSelector</code>和<code>ImportBeanDefinitionRegistrar</code>的实现类。<code>ImportBeanDefinitionRegistrar</code>在<code>ConfigurationClassPostProcessor</code>处理<code>Configuration</code>类期间被调用，用来生成该<code>Configuration</code>类所需要的<code>BeanDefinition</code>。而<code>ConfigurationClassPostProcessor</code>正实现了<code>BeanDefinitionRegistryPostProcessor</code>接口。下面我们就来看一下其<code>processConfigBeanDefinitions</code>方法到底是如何处理<code>Configuration</code>类的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">        <span class="comment">//第一步：先把所有Configuration的beanDefinition找到。</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">			BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">			<span class="comment">//利用AnnotationMetadata是否有@Configuration这个注解。需要注意的是</span></span><br><span class="line">            <span class="comment">//Configuration是一个元注解，它是可以使用在其他注解上的，被这些注解注释的类也被认为是Configuration</span></span><br><span class="line">            <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">				configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//第二步：通过Order注解的值来排序，定义了Configuration的先后顺序</span></span><br><span class="line">		configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">			<span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">			<span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">			<span class="keyword">return</span> (i1 &lt; i2) ? -<span class="number">1</span> : (i1 &gt; i2) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">        <span class="comment">//..... 此处有省略</span></span><br><span class="line">		ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">				<span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">				<span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">		Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">		Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">		do &#123;</span><br><span class="line">            <span class="comment">//第三步：通过BeanDefinition来读取ConfigurationClass</span></span><br><span class="line">			parser.parse(candidates);</span><br><span class="line">			parser.validate();</span><br><span class="line"></span><br><span class="line">			Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">			configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">						registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">						<span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//第四步：重点，通过ConfigurationClass来获得BeanDefinition</span></span><br><span class="line">			<span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">			alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">			candidates.clear();</span><br><span class="line">            <span class="comment">//第五步：由于在loadBeanDefinitions过程中会向registry中添加BeanDefinition,所以这里需要把新的Definition</span></span><br><span class="line">            <span class="comment">//在重新检测一遍，先看是否是Configuration类，如果是的那么还要再进行一次处理。</span></span><br><span class="line">			<span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">                <span class="comment">//.....此处有省略，大致逻辑就是通过registry多出的BeanDefinition获得新的candidateNames</span></span><br><span class="line">				candidateNames = newCandidateNames;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line">        <span class="comment">//.....此处有省略</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p> 接着我们直接到<code>ConfigurationClassBeanDefinitionReader</code>类中查看<code>loadBeanDefinition</code>函数的实现。它会调用<code>loadBeanDefinitionsForConfigurationClass</code>函数。在该函数中会处理所有和<code>Configuration</code>相关的<code>BeanDefinition</code>,其中就会调用<code>loadBeanDefinitionsFromRegistrars</code>来通过<code>ImportBeanDefinitionRegistrar</code>加载<code>BeanDefinition</code>。<br> 看到这里，大家可能会有个疑问，多个<code>Configuration</code>和多个<code>ImportBeanDefinitionRegistrar</code>存在的情况下，它们之间的对应关系是如何确定的呢？<br> <code>ConfigurationClassParser</code>的parse方法会将Configuration类相关的配置信息全部解析出来。我们可以看其<code>doProcessConfigurationClass</code>方法的源码。通过<code>@Import</code>注解将<code>Configuration</code>类和相应的<code>ImportBeanDefinitionRegistrar</code>联系在一起。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//首先处理内部成员类的情况</span></span><br><span class="line">		processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理 @PropertySource 注解</span></span><br><span class="line">		<span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">				sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">				org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">				processPropertySource(propertySource);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理 @ComponentScan 注解</span></span><br><span class="line">		Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">		<span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">				!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">				<span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">				Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">						<span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">				<span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">				<span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">					<span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(</span><br><span class="line">							holder.getBeanDefinition(), <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理 @Import 注解</span></span><br><span class="line">		processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理 @ImportResource 注解</span></span><br><span class="line">		<span class="keyword">if</span> (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123;</span><br><span class="line">			AnnotationAttributes importResource =</span><br><span class="line">					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">			String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line">			Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line">			<span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">				String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">				configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理configuration中的 @Bean 函数</span></span><br><span class="line">		Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">		<span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">			configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//......有省略</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="InitializingBean，FactoryBean，MethodInterceptor"><a href="#InitializingBean，FactoryBean，MethodInterceptor" class="headerlink" title="InitializingBean，FactoryBean，MethodInterceptor"></a>InitializingBean，FactoryBean，MethodInterceptor</h4><p> Spring Cloud Stream的<code>BindableProxyFactory</code>类实现了上述接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BindableProxyFactory implements MethodInterceptor, FactoryBean&lt;Object&gt;, Bindable, InitializingBean</span><br></pre></td></tr></table></figure></p>
<p> 其中，<code>InitializingBean</code>接口有一个<code>afterPropertiesSet</code>方法，该方法在<code>bean</code>所有的属性都被赋值后调用。bean的属性被初始化是在初始化的时候做的，与<code>BeanPostProcessor</code>结合来看，<code>afterPropertiesSet</code>方法在<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>之间被调用。<br> Spring中有两个类型的Bean,普通Bean和工厂Bean。FactoryBean有三个接口，分别是:</p>
<ul>
<li>Object getObject():返回FactoryBean创建的对象实例。</li>
<li>boolean isSingleton():表示FactoryBean返回的对象实例是否为单例。</li>
<li>Class getObjectType():返回FactoryBean返回的对象类型。<br> 我们可以看一下<code>BindableProxyFactory</code>的相关实现，这里会和<code>MethodInterceptor</code>配合。<code>MethodInterceptor</code>是AOP相关的接口，用于在调用对象接口时进行切片注入或在直接实现接口。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//使用AOP的ProxyFactory类，由于该类本身也是先了MethodInterceptor接口</span></span><br><span class="line">        <span class="comment">//所以这样配合使用，直接返回ProxyFactory类。</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.proxy == <span class="keyword">null</span>) &#123;</span><br><span class="line">			ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(<span class="keyword">this</span>.type, <span class="keyword">this</span>);</span><br><span class="line">			<span class="keyword">this</span>.proxy = factory.getProxy();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.proxy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="BeanPostProcessor，ApplicationContextAware，BeanFactoryAware，SmartInitializingSingleton"><a href="#BeanPostProcessor，ApplicationContextAware，BeanFactoryAware，SmartInitializingSingleton" class="headerlink" title="BeanPostProcessor，ApplicationContextAware，BeanFactoryAware，SmartInitializingSingleton"></a>BeanPostProcessor，ApplicationContextAware，BeanFactoryAware，SmartInitializingSingleton</h4><p> Spring Cloud Stream的<code>StreamListenerAnnotationBeanPostProcessor</code>实现了如下接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamListenerAnnotationBeanPostProcessor</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>, <span class="title">ApplicationContextAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">SmartInitializingSingleton</span>,</span><br><span class="line">		<span class="title">InitializingBean</span></span></span><br></pre></td></tr></table></figure></p>
<p> <code>BeanPostProcessor</code>是<code>bean</code>的后处理器，通过它我们可以在<code>Bean</code>初始化前后进行处理。它的<code>postProcessBeforeInitialization</code>方法在<code>Bean</code>初始化之前被调用，而<code>postProcessAfterInitialization</code>在<code>Bean</code>初始化后被调用。相关原理涉及到Spring创建Bean的流程，这个之后有时间再研究吧。</p>
<h4 id="Aware系列接口"><a href="#Aware系列接口" class="headerlink" title="Aware系列接口"></a>Aware系列接口</h4><p> Spring中提供了一些<code>Aware</code>相关的接口，像是<code>BeanFactoryAware</code>,<code>ApplicationContextAware</code>等。当一个类实现了这些接口之后，<code>Aware</code>接口的Bean在初始化之后，可以取得相应的资源的实例。比如<code>StreamListenerAnnotationBeanPostProcessor</code>对象就实现了<code>ApplicationContextAware</code>和<code>BeanFactoryAware</code>接口来获取<code>ConfigurableApplicationContext</code>与<code>BeanFactory</code>实例。</p>
<h4 id="SmartInitializingSingleton"><a href="#SmartInitializingSingleton" class="headerlink" title="SmartInitializingSingleton"></a>SmartInitializingSingleton</h4><p> 当所有的singleton的bean都初始化完成之后才会调用这个接口<br>的<code>afterSingletonsInstantiated</code>函数</p>
<h4 id="SmartLifecycle"><a href="#SmartLifecycle" class="headerlink" title="SmartLifecycle"></a>SmartLifecycle</h4><p> 之前介绍的接口都是在Bean的生命周期内的某个阶段中被调用，如果我们希望在容器本身的生命周期事件上做一些事情该怎麽办呢？Spring容器提供了<code>Lifecycle</code>接口。当<code>ApplicationContext</code>接口启动或在关闭时，它会调用本容器内所有的Lifecycle接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="comment">//启动该组件</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//停止组件</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//查看组件是否正在运行</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 如果两个对象有依赖关系，希望某一个bean先初始化完成，完成一些工作之后，再初始化另一个bean。在这个场景下，可以使用<code>SmartLifecycle</code>接口，该接口的<code>getPhase</code>方法返回一个整型数字，表明执行顺序。如果其<code>getPhase()</code>方法返回<code>Integer.MIN_VALUE</code>,那么该对象最先启动，最后停止；如果返回<code>Integer.MAX_VALUE</code>,那么该对象最后启动，最先停止。在<code>Spring</code>容器里，有<code>DefaultLifecycleProcessor</code>这个类来处理所有的<code>Lifecycle</code>的bean。在<code>AbstractApplicationContext</code>的<code>finishRefresh</code>函数中会调用到该processer的<code>onRefresh函数</code>，从其调用其本身的<code>startBeans</code>函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBeans</span><span class="params">(<span class="keyword">boolean</span> autoStartupOnly)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line">		Map&lt;Integer, LifecycleGroup&gt; phases = <span class="keyword">new</span> HashMap&lt;Integer, LifecycleGroup&gt;();</span><br><span class="line">        <span class="comment">//遍历所有的Lifecycle,按照phase分成不同的LifecycleGroup</span></span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, ? extends Lifecycle&gt; entry : lifecycleBeans.entrySet()) &#123;</span><br><span class="line">			Lifecycle bean = entry.getValue();</span><br><span class="line">			<span class="keyword">if</span> (!autoStartupOnly || (bean <span class="keyword">instanceof</span> SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123;</span><br><span class="line">				<span class="keyword">int</span> phase = getPhase(bean);</span><br><span class="line">				LifecycleGroup group = phases.get(phase);</span><br><span class="line">				<span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">					group = <span class="keyword">new</span> LifecycleGroup(phase, <span class="keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);</span><br><span class="line">					phases.put(phase, group);</span><br><span class="line">				&#125;</span><br><span class="line">				group.add(entry.getKey(), bean);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!phases.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//按照phase排序，然后启动</span></span><br><span class="line">			List&lt;Integer&gt; keys = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(phases.keySet());</span><br><span class="line">			Collections.sort(keys);</span><br><span class="line">			<span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">				phases.get(key).start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端-Spring/">后端 - Spring</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Spring-Boot/">Spring Boot</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/10/10/Spring-Cloud-Stream-一-：Spring基础知识/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/10/10/Spring-Cloud-Stream-一-：Spring基础知识/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/09/10/Spring-Boot-一-Spring-Boot-starter自定义/" title="Spring Boot (一): Spring Boot starter自定义" itemprop="url">Spring Boot (一): Spring Boot starter自定义</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2017-09-10T12:25:35.000Z" itemprop="datePublished"> Published 2017-09-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p> 前些日子在公司接触了<code>spring boot</code>和<code>spring cloud</code>,有感于其大大简化了spring的配置过程，十分方便使用者快速构建项目，而且拥有丰富的starter供开发者使用。但是由于其自动化配置的原因，往往导致出现问题，新手无法快速定位问题。这里我就来总结一下spring boot 自定义starter的过程,相信大家看完这篇文章之后，能够对<code>spring boot starter</code>的运行原理有了基本的认识。<br> 为了节约你的时间，本篇文章的主要内容有：</p>
<ul>
<li>spring boot starter的自定义</li>
<li>spring boot auto-configuration的两种方式,spring.factories和注解</li>
<li>Conditional注解的使用</li>
</ul>
<h3 id="引入pom依赖"><a href="#引入pom依赖" class="headerlink" title="引入pom依赖"></a>引入pom依赖</h3><p> 相信接触过spring boot的开发者都会被其丰富的starter所吸引，如果你想给项目添加redis支持，你就可以直接引用<code>spring-boot-starter-redis</code>，如果你想使项目微服务化，你可以直接使用<code>spring-cloud-starter-eureka</code>。这些都是spring boot所提供的便利开发者的组件，大家也可以自定义自己的starter并开源出去供开发者使用。<br> 创建自己的starter项目需要maven依赖是如下所示:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="核心配置类StorageAutoConfigure"><a href="#核心配置类StorageAutoConfigure" class="headerlink" title="核心配置类StorageAutoConfigure"></a>核心配置类StorageAutoConfigure</h4><p> 构建starter的关键是编写一个装配类，这个类可以提供该starter核心bean。这里我们的starter提供一个类似<code>redis</code>的键值存储功能的bean，我们叫它为<code>StorageService</code>。负责对这个bean进行自动化装配的类叫做<code>StorageAutoConfigure</code>。保存application.properties配置信息的类叫做<code>StorageServiceProperties</code>。这三种类像是铁三角一样，你可以在很多的<code>spring-boot-starter</code>中看到他们的身影。<br> 我们首先来看<code>StorageAutoConfigure</code>的定义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(StorageService.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(StorageServiceProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageAutoConfigure</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StorageServiceProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(StorageService.class)</span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"storage.service"</span>, value = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line">    <span class="function">StorageService <span class="title">exampleService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StorageService(properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 我们首先讲一下源码中注解的作用。</p>
<ul>
<li><code>@Configuration</code>,被该注解注释的类会提供一个或则多个<code>@bean</code>修饰的方法并且会被spring容器处理来生成<code>bean definitions</code>。</li>
<li><code>@bean</code>注解是必须修饰函数的，该函数可以提供一个<code>bean</code>。而且该函数的函数名必须和bean的名称一致，除了首字母不需要大写。</li>
<li><code>@ConditionalOnClass</code>注解是条件判断的注解，表示对应的类在classpath目录下存在时，才会去解析对应的配置文件。</li>
<li><code>@EnableConfigurationProperties</code>注解给出了该配置类所需要的配置信息类，也就是<code>StorageServiceProperties</code>类，这样spring容器才会去读取配置信息到<code>StorageServiceProperties</code>对象中。</li>
<li><code>@ConditionalOnMissingBean</code>注解也是条件判断的注解，表示如果不存在对应的bean条件才成立，这里就表示如果已经有<code>StorageService</code>的bean了，那么就不再进行该bean的生成。这个注解十分重要，涉及到默认配置和用户自定义配置的原理。也就是说用户可以自定义一个<code>StorageService</code>的bean,这样的话，spring容器就不需要再初始化这个默认的bean了。</li>
<li><code>ConditionalOnProperty</code>注解是条件判断的注解，表示如果配置文件中的响应配置项数值为true,才会对该bean进行初始化。</li>
</ul>
<p> 看到这里，大家大概都明白了<code>StorageAutoConfigure</code>的作用了吧，spring容器会读取相应的配置信息到<code>StorageServiceProperties</code>中，然后依据调节判断初始化StorageService这个bean。集成了该<code>starter</code>的项目就可以直接使用<code>StorageService</code>来存储键值信息了。</p>
<h4 id="配置信息类StorageServiceProperties"><a href="#配置信息类StorageServiceProperties" class="headerlink" title="配置信息类StorageServiceProperties"></a>配置信息类StorageServiceProperties</h4><p> 存储配置信息的类<code>StorageServiceProperties</code>很简单，源码如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"storage.service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageServiceProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//一系列的getter和setter函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <code>@ConfigurationProperties</code>注解就是让spring容器知道该配置类的配置项前缀是什么，上述的源码给出的配置信息项有<code>storage.service.username</code>,<code>storage.service.password</code>和<code>storage.service.url</code>，类似于数据库的host和用户名密码。这些配置信息都会由spring容器从<code>application.properties</code>文件中读取出来设置到该类中。</p>
<h4 id="starter提供功能的StorageService"><a href="#starter提供功能的StorageService" class="headerlink" title="starter提供功能的StorageService"></a>starter提供功能的StorageService</h4><p> <code>StorageService</code>类是提供整个starter的核心功能的类，也就是提供键值存储的功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(StorageService.class);</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Object&gt; storage = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StorageService</span><span class="params">(StorageServiceProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.url = properties.getUrl();</span><br><span class="line">        <span class="keyword">this</span>.username = properties.getUsername();</span><br><span class="line">        <span class="keyword">this</span>.password = properties.getPassword();</span><br><span class="line">        logger.debug(<span class="string">"init storage with url "</span> + url + <span class="string">" name: "</span> + username + <span class="string">" password: "</span> + password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object val)</span> </span>&#123;</span><br><span class="line">        storage.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object  <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="注解配置和spring-factories"><a href="#注解配置和spring-factories" class="headerlink" title="注解配置和spring.factories"></a>注解配置和spring.factories</h4><p>&emsp;自定义的<code>starter</code>有两种方式来通知spring容器导入自己的auto-configuration类，也就是本文当中的<code>StorageAutoConfigure</code>类。<br>&emsp;一般都是在<code>starter</code>项目的<code>resources/META-INF</code>文件夹下的spring.factories文件中加入需要自动化配置类的全限定名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=starter.StorageAutoConfigure</span><br></pre></td></tr></table></figure></p>
<p>&emsp;<code>spring boot</code>项目中的<code>EnableAutoConfigurationImportSelector</code>会自动去每个jar的相应文件下查看spring.factories文件内容，并将其中的类加载出来在auto-configuration过程中进行配置。而<code>EnableAutoConfigurationImportSelector</code>在<code>@EnableAutoConfiguration</code>注解中被<code>import</code>。<br>&emsp;第一种方法只要是引入该starter，那么spring.factories中的auto-configuration类就会被装载，但是如果你希望有更加灵活的方式，那么就使用自定义注解来引入装配类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(StorageAutoConfigure.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableStorage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;有了这个注解，你可以在你引入该starter的项目中使用该注解，通过<code>@import</code>注解，spring容器会自动加载<code>StorageAutoConfigure</code>并自动化进行配置。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>&emsp;上述只是关于spring boot starter最为简单的定制和原理分析，后续我准备研究一下<code>spring cloud stream</code>的源码，主要是因为工作上一直在使用这个框架。请大家继续关注。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/后端/">后端</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Spring-Boot/">Spring Boot</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/09/10/Spring-Boot-一-Spring-Boot-starter自定义/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/09/10/Spring-Boot-一-Spring-Boot-starter自定义/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/25/Raft算法/" title="Raft算法" itemprop="url">Raft算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2017-07-25T09:09:09.000Z" itemprop="datePublished"> Published 2017-07-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p> 前段时间一直在学习mit的分布式课程<a href="http://nil.csail.mit.edu/6.824/2015/index.html" target="_blank" rel="external">Distributed Systems</a>，仔细阅读了raft论文，但是中间又跑去搞docker了，所以一直没有整理raft相关的文章，今天就来总结一下。<br>&emsp;文章中没有多少详细的图片，但是大家可以边看文章边看<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="external">Raft演示动画</a><br> 之前介绍的<a href="http://remcarpediem.com/2017/04/16/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Paxos/">Paxos</a>算法一直都是分布式一致性协议的标准，但是Paxos难以理解，更难以理解。于是Stanford的教授提出了Raft协议，它是一个为真实世界应用建立的协议，主要注重协议的落地性和可理解性。这里有Raft的<a href="http://nil.csail.mit.edu/6.824/2015/papers/raft-atc14.pdf" target="_blank" rel="external">论文</a>，大家有兴趣可以自行阅读一下。<br> Raft是为了managing a replicated log。Raft会首先选举一个leader,然后让这个leader来管理replicated log。Raft将consensus问题(也就是一致性问题)划分成三个相互独立的子问题：  </p>
<ul>
<li>leader election</li>
<li>log replication</li>
<li>safety</li>
</ul>
<h4 id="Raft-basis"><a href="#Raft-basis" class="headerlink" title="Raft basis"></a>Raft basis</h4><p> 任何时间每个server都处于下列三个状态之一：leader,follower,或在candidate之一。在正常状态下，整个集群只会有一个leader并且其他所有server都处于followers状态下。followers是被动的，它们只会对leader的request进行反应。第三个状态candidate是用来选举新的leader的。<br> Raft以Term来划分运行时间，你可以将其理解为任期。Term以连续的整数来命名，每个Term都以一个election开始。在一次选举中，一个或多个candidate试图成为leader。如果一个candidate赢得了election,那么它就成为leader。如果一次election中没有candidate获胜，那么就进行下一个Term,重新进行election。每个Term最多只有一leader，否则进入下一个Term,这样Term就可以作为一个logical clock。<br> Raft服务器通过RPC来交互，只需要两个RPC操作，RequestVote RPCs and AppendEntries RPCs。RequestVote用于选举而AppendEntries用于leader发送请求进行relicate log entries和心跳。</p>
<h4 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h4><p>&emsp;Raft通过心跳机制来触发leader selection。当一个服务器启动时，默认位于followers状态，并且一直持续知道它一直接受到leader的RPC请求。leader会周期性发送心跳给所有的followers。如果follower一段时间内没有接受到心跳，那么就认为当前没有leader应该开始leader selection。<br>&emsp;开始election后，server将其Term进行加一，然后转变成candidate状态，并且给其他所有server发送RequestVote RPC请求来进行vote。这个过程一直持续到：server自己赢得election,其他的server赢得election,或者这个Term期间没有server获胜，进入下一个Term。<br>&emsp;candidate收到半数以上server的vote就赢得了election。每个server在一个Term中只会vote一次。server基于first-come-and-first-serve的规则来进行投票。一旦某个candidate赢得了election, 就变成了leader,并且开始周期性发送心跳。<br>&emsp;当等待投票时，candidate受到了其他candidate发送的AppendEntries PRC请求,如果candiate发现在包含在请求当中的Term数值大于或则等于自己的Term数值，那么该candiate主动退回到follower状态，否在拒绝该请求，继续保持candidate状态。<br>&emsp;当很多server变成candidate状态进行election时，选举失败的可能性就很高了。那么每个candiate会推迟随机时间之后进入下一个Term并进行新的election。以此来避免大量的选举失败的情况发生。</p>
<h4 id="Log-replication"><a href="#Log-replication" class="headerlink" title="Log replication"></a>Log replication</h4><p>&emsp;一旦一个leader被选举成功，它就开始处理client请求。每个client请求都包含一个需要被replicated state machine处理的命令，leader将这些命令当作一个新的entry添加到log中。然后给follower发送AppendEntries RPCs请求来复制这个log entry。当一个entry被safely relicated(在下一小结中会讲解)，leader就会将entry交给state machine进行执行，并且将结果返回。<br>&emsp;当一个log entry可以被安全的交给state machine处理时，我们认为它是committed的。Raft保证所有committed的log entry一定是持久化的，并且一定被state machine执行。Log entry是committed一旦该entry在大多数follower上被replicated。一旦一个entry被committed,那么在它之前的所有log也是committed的。Leader会随时关注最大的committed的log的index,并在AppendEntries RPCs请求中携带该信息，这样follower就能知道哪些entry被committed，它们就会将其提交给自己的state machine来执行。<br>&emsp;当followers crash或则网络丢包时，leader会一直发送AppendEntries RPCs直到所有followers都存储了entry。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017725-raft-raft1.png" alt="log entry的排列"></p>
<p>&emsp;每个Log entry都有其唯一标识，entry中包括了 leader Term，index和要执行的comand。index是指entry在Log中的位置。Raft通过Log Machine Property来维护Log的合理性：</p>
<ul>
<li>如果两个entries在不同的logs中(存储在不同的server上)拥有相同的index和term,那么他们包含相同的command。</li>
<li>如果两个entries在不同的logs中拥有相同的index和term,那么他们之前的entries也都是一致或在内容相同的。<br>&emsp;第一条规定保证leader每个Term中的每个index最多只能创建一个entry。而第二条规定使得followers在处理AppendEntries RPCs请求时要进行一致性检测。leader在AppendEntries请求中带上了自己logs中排在新entry之前的那个entry的index和term,如果follower在自己的logs中找不到该entry,那么就拒绝添加new entry。这样就保证了第二条规定不会被违反。<br>&emsp;正常情况下，leader和followers的logs都是一致的，但是当一系列的leader crash，followers crash和election之后，followers的logs可能会被当前leader的logs多出一些entry,也可能会少一些entry。在Raft中，leader通过强迫followers的logs复制leader的logs来保持一致性。这就意味着follower logs中的冲突的entry会被重写。</li>
</ul>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017725-raft-raft2.png" alt="leader和follower的logs冲突"></p>
<p>&emsp;为了一致化logs,leader的logs需要和follower的logs进行对比，找出它们之间最后一条相同的entry。然后将follower logs中那条entry之后的所有entry删除，并发送leader logs中那条entry之后的entry给follower。这些行为都发生在AppendEntries RPCs的一致性检查过程中。<br>&emsp;leader会每个follower维护一个nextIndex来记录发送给这个follower的下一条log entry的index。nextIndex初始化为leader logs的最后一条entry之后的index。如果follower的logs和leader的logs不一致，那么AppendEntries RPCs的一致性检查就会失败。leader发现自己的请求被follower拒绝了，那么就减少该follower的nextIndex然后再次发送AppendEntries请求。最终nextIndex就会变成二者log中最后一个一致的entry的index。当上述情况发生之后，AppendEntries请求就会成功，就会删除follower中多的entry和添加缺少的entry。</p>
<h4 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h4><p>&emsp;这一小节主要描述在leader election过程中的一些限定。这些限定保证任何一个Term的leader的logs都包含了之前Term中所有committed的entry。这也是所谓的Leader Completeness Property。</p>
<h4 id="Election限制"><a href="#Election限制" class="headerlink" title="Election限制"></a>Election限制</h4><p>&emsp;Raft规定：在election过程中，new leader本身必须有之前Term中所有committed的log entry。也就是说每次election成功的leader必然包含之前所有的committed的log entry。这样保证了log的单向流动，一定是从leader到follower。<br>&emsp;Raft通过election vote过程来保证上述限制。一个candidate必须得到集群中多于半数的server的vote，而每个committed的log entry一定也会存在于多于半数的server的logs中。也就是说在RequestVote RPC中包含了candidate自己logs中最后一个committed的log信息，接受到该请求的server会将其和自己log中最后一个committed的log进行对比，如果自己的log晚于candiate的，那么就同意该candiate成为leader,否在拒绝。这样的话，没有包含所有committed log entry的candidate就一定不会得到超过半数的server的vote。Raft根据entry的term和index来确定每个entry的先后顺序。较大term的log entry比较新，如果log entry的term一致，那就是越大的index约新。</p>
<h5 id="Committing-entries-from-previous-terms"><a href="#Committing-entries-from-previous-terms" class="headerlink" title="Committing entries from previous terms"></a>Committing entries from previous terms</h5><p>&emsp;如果旧的leader在committing an entry时crash了，那么新的leader是否需要重新commit这个entry呢？但是为了简化，Raft重来不会提交之前Term的log entry。没有被committed的log entry就会被重写。</p>
<h5 id="Followers-and-candidate-crashs"><a href="#Followers-and-candidate-crashs" class="headerlink" title="Followers and candidate crashs"></a>Followers and candidate crashs</h5><p>&emsp;如果followers或在candidate在接受到RPC之前crash，leader会一直重试发送RPC。如果是在接受处理之后crash，没有发送回复，leader也是会重复发送RPC,但是因为RPC都是幂等的，所以不会造成额外的影响。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>&emsp;Raft的应用十分广泛，比如etcd项目就是使用Raft来保证分布式一致性的，之后我也想去研究一下etcd中Raft的实现，毕竟之前都是理论。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/分布式/">分布式</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Raft/">Raft</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/07/25/Raft算法/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/07/25/Raft算法/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/23/Kubernetes部署/" title="Kubernetes部署" itemprop="url">Kubernetes部署</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2017-07-23T07:33:52.000Z" itemprop="datePublished"> Published 2017-07-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;学习完Docker之后，发现了kubernetes这个容器云框架，于是就自己部署来玩玩。大家也可以按照这个<a href="和我一步步部署 kubernetes 集群">和我一步步部署 kubernetes 集群</a>文章来部署。最近在这里花费了大量的时间，之后希望整理一下相关的原理介绍。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017723-kube-kuber1.png" alt="kuber1.png"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017723-kube-kube3.png" alt="kube3.png"></p>
<h3 id="问题列表和解决方案"><a href="#问题列表和解决方案" class="headerlink" title="问题列表和解决方案"></a>问题列表和解决方案</h3><ul>
<li>google源找不到解决方案：<br><a href="http://www.jianshu.com/p/4f5066dad9b4" target="_blank" rel="external">http://www.jianshu.com/p/4f5066dad9b4</a><br>公钥未安装导致无法安装</li>
<li>Created API client, waiting for the control plane to become ready<br>卡死在这里，阿里云需要使用内网ip地址 你也可以使用journalctl -u kubelet 查看日志<br>ApiServer的debug <a href="https://github.com/kubernetes/kubernetes/wiki/Debugging-FAQ" target="_blank" rel="external">https://github.com/kubernetes/kubernetes/wiki/Debugging-FAQ</a></li>
<li>SSL/TLS协议<br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></li>
<li>etcd cant bind the addr<br><a href="https://github.com/coreos/etcd/issues/4789" target="_blank" rel="external">https://github.com/coreos/etcd/issues/4789</a><br>nc -l 10.5.0.9 2380<br>iptables查看端口问题</li>
<li>flanneld<br><a href="https://stackoverflow.com/questions/34439659/flannel-and-docker-dont-start" target="_blank" rel="external">https://stackoverflow.com/questions/34439659/flannel-and-docker-dont-start</a><br>flanneld 启动/kubernetes 没有找到<br>//fail to retrieve network config: invalid charactar</li>
<li><p>linux低版本不支持flanneld的vxlan功能，需要换成udp<br>cant register network : oeperation not supported<br><a href="https://github.com/coreos/etcd/issues/3710" target="_blank" rel="external">https://github.com/coreos/etcd/issues/3710</a></p>
</li>
<li><p>linux低版本不支持docker<br><a href="http://dockone.io/question/1060" target="_blank" rel="external">http://dockone.io/question/1060</a><br>pod-infra-container-image</p>
</li>
<li>dashboard<br><a href="https://github.com/kubernetes/kubernetes/issues/39722" target="_blank" rel="external">https://github.com/kubernetes/kubernetes/issues/39722</a></li>
<li>127.0.3.1:9090 cant connection<br><a href="http://blog.csdn.net/xinghun_4/article/details/50492041" target="_blank" rel="external">http://blog.csdn.net/xinghun_4/article/details/50492041</a><br>add route<br><a href="https://github.com/kubernetes/dashboard/issues/672" target="_blank" rel="external">https://github.com/kubernetes/dashboard/issues/672</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/容器/">容器</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/docker/">docker</a><a href="/tags/kubernetes/">kubernetes</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/07/23/Kubernetes部署/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/07/23/Kubernetes部署/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/02/Docker系列之Jenkins自动化部署/" title="Docker系列之Jenkins自动化部署" itemprop="url">Docker系列之Jenkins自动化部署</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2017-07-02T13:23:35.000Z" itemprop="datePublished"> Published 2017-07-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p> Devops的概念已经火了很久了，我一直想对这方面进行一定的了解；再加上实验室项目环境依赖比较复杂，希望使用Docker来解决，所以最近就好好研究了一波Docker的相关实践和原理。这里整理一下，希望组成一个系列，从实践到原理详细讲解一下Docker的使用。<br> 第一篇就讲一下Jenkins+Docker的自动化部署实践。大致的流程如下：目前我有两个服务器，分别是阿里云和bandwagon,代码存储在github上，每次push都会触发阿里云上的jenkins的构建任务，jenkins将github上的代码fetch到本地，编译打包成war文件，生成docker image并上传到docker registry上，然后通过ssh来登录bandwagon服务器pull下来新生成的image并启动。由于篇幅问题，本篇文章不会介绍有关docker image的build和docker registry的搭建，但是我会在后续文章中再做详细讲解。<br> 学习Docker，我推荐先在网络上找说明指南，一步一步自己尝试的使用，然后如果觉得有必要可以看一下《Docker容器和容器云》这本书。<br> 本文内容都是docker和jenkins的基础知识，为了节约你的时间，本文的主要内容如下：</p>
<ul>
<li>docker 基础命令</li>
<li>jenkins docker版本的搭建，构建任务的配置</li>
<li>Pubish Over SSH 安装和配置</li>
<li>通过github的webhook来触发jenkins构建任务</li>
</ul>
<h4 id="Docker运行jenkins"><a href="#Docker运行jenkins" class="headerlink" title="Docker运行jenkins"></a>Docker运行jenkins</h4><p> Docker如此火爆的一个原因是因为它形成了一个良好的生态圈，基本上主流的软件应用都有相应的Docker image。如果大家不清楚Docker image的含义，建议大家看一下<a href="https://www.gitbook.com/book/richardhc/chinese_docker/details" target="_blank" rel="external">Docker中文指南</a>，我们可以通过<code>docker pull</code>命令来下载响应的image,然后运行。比如我们希望在阿里云服务器上部署一个jenkins应用，首先可以执行下列语句来获取一个jenkins的image。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkinsci/jenkins:lts</span><br></pre></td></tr></table></figure></p>
<p> 这里我们使用pull从docker registry上拉取image,但是目前业界上有很多共有或在私有的docker registry,比如说docker hub和daoCloud。所以image的全称就由三部分组成:域名或在ip + / + 软件名称 + : + 版本号，所以上边的这条命令就是让docker去jenkinsci这个Jenkins机构自己部署的registry上下载jenkins的lts版本的image.你也可以直接使用<code>docker pull jenkins</code>来下载image,但docker会默认的从docker hub上下载jenkins的laster版本。</p>
<p> 下载成功之后，你可以使用<code>docker images</code>命令来查看当前下载的image信息</p>
<p> 你可以通过<code>docker run</code>命令来运行docker容器，请注意我这里的用词，在Docker中image和container是不同的概念，你可以将他们简单的理解成Java中类和对象的关系。我们使用下面的命令来启动这个jenkins容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name jenkins -p 9090:8080 -v /var/jenkins_home:/var/jenkins_home jenkinsci/jenkins:lts</span><br></pre></td></tr></table></figure></p>
<p> 我们来依次讲解一下run命令的几个参数把：</p>
<ul>
<li><p><code>-d</code> 后台运行docker容器并打印容器ID。如果不加<code>-d</code>参数，那么容器运行会和终端绑定，如果终端关闭，那么容器也会关闭，但是容器不会被删除。但是如果你只是想试一试某个容器，运行后自动进入命令行，那么可以使用-it参数;如果你想容器关闭之后自动删除，那么就使用-rm参数。</p>
</li>
<li><p><code>--name</code> 给docker container起一个别名，后续可以通过别名来管理容器，否在会系统会默认分配一个随机的别名。</p>
</li>
<li><p><code>-p</code> docker容器和外侧的端口映射，jenkins服务是运行在docker容器内部的，但是docker容器默认不对外暴露接口，所以通过这个参数将内部的8080端口映射到服务器本身的9090端口上。</p>
</li>
<li><p><code>-v</code> 数据卷的挂载。这里涉及到docker container的一个特性，container如果停止运行了，那么再次启动时，之前所有运行相关的数据和文件就都不存在了，就类似于设置了自动还原的电脑一般，无论你做了多少的操作，一旦关机重启之后就又恢复到最初的状态。数据卷就是来解决上述问题的，通过Docker container外部的文件夹的挂载，将可持久化的文件存储到外部挂载的文件夹中。</p>
</li>
</ul>
<p> 然后你就可以根据你自己的ip地址来键入下列地址http:ip:9090来访问jenkins的主页了。<br>&emsp;这里有一点需要注意的是，需要注意你阿里云服务器设置的网络安全协议，是否禁用掉了9090这个端口。</p>
<h4 id="Publish-over-SSH配置"><a href="#Publish-over-SSH配置" class="headerlink" title="Publish over SSH配置"></a>Publish over SSH配置</h4><p>&emsp;Jenkins的初始化配置和SSH Over Publish的安装请大家自行百度，这里我主要讲解一下SSH Over Pushlish配置。<br>&emsp;首先我们要在jenkins服务器上生成密钥对，使用<code>ssh-keygen -t rsa</code>命令来生成秘密对，这样的话，在~/.ssh/下就会有私钥id_rsa和公钥id_rsa.pub。<br>&emsp;然后你需要上传公钥到目标服务器上，也就是我的bandwagon服务器上，可以使用<code>ssh-copy-id</code>来将文件上传到服务器上，类似于<code>scp</code>命令的使用方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub &lt;username&gt;@&lt;host&gt;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;最后我们需要修改目标服务器的ssh配置文件，配置文件为/etc/ssh/sshd_config。设置ssh-server允许使用私钥和公钥对的方式登录，然后使用<code>sudo /etc/init.d/ssh restart</code>命令重启ssh服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">#AuthorizedKeysFile     %h/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>
<p>&emsp;上述步骤成功之后，大家在系统管理中配置Publish over SSH。相关的配置信息如下图所示。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins1.png" alt="jenkins1.png"></p>
<p>&emsp;你还可以点击下方的高级选项，来配置ssh服务器的端口，超时时间等信息，还可以点击Test Configuration来检测是否配置成功。</p>
<h4 id="构建任务配置"><a href="#构建任务配置" class="headerlink" title="构建任务配置"></a>构建任务配置</h4><p>&emsp;我们先创建一个构建任务，该任务从github repo上将代码拉取下来，然后执行构建任务，然后通过Publish Over SSH在目标服务器上进行部署。<br>&emsp;我们首先配置源码管理模块，选择Git选项，然后配置Repository URL 并添加认证信息。可以将自己的github帐号和密码加入其中。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins2.png" alt="jenkins2.png"></p>
<p>&emsp;不同的项目的构建命令不同，但是我们可以在构建后操作模块设置后续操作，通过ssh登录目标服务器，让目标服务器执行命令行操作来pull最新上传的image并且执行，这样就完成了部署。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins3.png" alt="jenkins3.png"></p>
<h4 id="Push触发构建任务"><a href="#Push触发构建任务" class="headerlink" title="Push触发构建任务"></a>Push触发构建任务</h4><p>&emsp;完成上述配置，你就可以手动在jenkins上启动构架任务了，但是要做到自动化部署，还必须设置Push操作自动触发jenkins构建任务的机制。<br>&emsp;我们先到首页-用户管理界面打开自己的用户界面，然后点击左侧的设置按钮，并点击<code>show API token</code>按钮来获取API token.然后在构建任务设置页面的构建触发器模块勾选触发远程构建选项，并将token填到里边去。这是jenkins会提示你如何通过URL来触发构建任务。<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins5.png" alt="jenkins5.png"></p>
<p>&emsp;然后我们打开github上相应库的设置页面。点击左侧的Webhooks选项，然后添加hook.将上述的url填写到Payload URL栏中，点击添加。如果添加成功之后，每次你push一个新版本，那么jenkins就会自动进行部署了。<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins6.png" alt="jenkins6.png"></p>
<p>&emsp;如果你发现webhooks发送请求失败，那可能是因为你jenkins安全设置的问题，禁止掉了发送请求自动化构建。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;本篇讲的都是十分基础性的内容，后一篇文章讲一下dockerfile的原理和注意事项与docker registry。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/运维/">运维</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Docker/">Docker</a><a href="/tags/Jenkins/">Jenkins</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/07/02/Docker系列之Jenkins自动化部署/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/07/02/Docker系列之Jenkins自动化部署/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/19/《多处理器编程艺术》－链表：锁的作用/" title="《多处理器编程艺术》－链表：锁的作用" itemprop="url">《多处理器编程艺术》－链表：锁的作用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2017-06-19T13:57:31.000Z" itemprop="datePublished"> Published 2017-06-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p> 最近在阅读《多处理器编程艺术》一书，掌握了很多Java多线程的底层知识，现在就做一下书中链表-锁的作用一章的总结。<br>&emsp;为了节约你的时间，本文主要内容如下：</p>
<ul>
<li>带锁的链表队列</li>
<li>细粒度同步</li>
<li>乐观同步</li>
<li>惰性同步</li>
<li>非阻塞同步</li>
</ul>
<h3 id="粗粒度同步"><a href="#粗粒度同步" class="headerlink" title="粗粒度同步"></a>粗粒度同步</h3><p>&emsp;所谓粗粒度同步其实很简单，就是在List的<code>add</code>,<code>remove</code>,<code>contains</code>函数的开始就直接使用Lock加锁，然后在函数结尾释放。<br>&emsp;<code>add</code>函数的代码如下所示，函数的主体就是链表的遍历添加逻辑，只不过在开始和结束进行了锁的获取和释放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node head;</span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">    Node pred, curr;</span><br><span class="line">    <span class="keyword">int</span> key = item.hashCode();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pred = head;</span><br><span class="line">        curr = pred.next;</span><br><span class="line">        <span class="keyword">while</span>(curr.key &lt; key) &#123;</span><br><span class="line">            pred = curr;</span><br><span class="line">            curr = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == curr.key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(item);</span><br><span class="line">            node.next = curr;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;大家看到这里就会想到，这不就是类似于<code>Hashtable</code>的实现方式吗？把可能出现多线程问题的函数都用一个重入锁锁住。但是这个方法的缺点很明显，如果竞争激烈的话，对链表的操作效率会很低，因为<code>add</code>,<code>remove</code>,<code>contains</code>三个函数都需要获取锁，也都需要等待锁的释放。至于如何优化，我们可以一步一步往下看</p>
<h3 id="细粒度同步"><a href="#细粒度同步" class="headerlink" title="细粒度同步"></a>细粒度同步</h3><p>&emsp;<strong><em>我们可以通过锁定单个节点而不是整个链表来提高并发</em></strong>。给每个节点增加一个Lock变量以及相关的lock()和unlock()函数,当线程遍历链表的时候，若它是第一个访问节点的线程，则锁住被访问的节点，在随后的某个时刻释放锁。这种细粒度的锁机制允许并发线程以流水线的方式遍历链表。<br>&emsp;使用这种方式来遍历链表，必须同时获取两个相邻节点的锁，通过“交叉手”的方式来获取锁：除了初始的head哨兵节点外，只有在已经获取pred的锁时，才能获取curr的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个Node对象中都有一个Lock对象，可以进行lock()和unlock()操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key = item.hashCode();</span><br><span class="line">        head.lock();</span><br><span class="line">        Node pred = head;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Node curr = pred.next;</span><br><span class="line">            curr.lock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (curr.key &lt; key) &#123;</span><br><span class="line">                    pred.unlock();</span><br><span class="line">                    pred = curr;</span><br><span class="line">                    curr = pred.next;</span><br><span class="line">                    curr.lock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (curr.key == key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Node newNode = <span class="keyword">new</span> Node(item);</span><br><span class="line">                newNode.next = curr;</span><br><span class="line">                pred.next = newNode;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                curr.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pred.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="乐观同步"><a href="#乐观同步" class="headerlink" title="乐观同步"></a>乐观同步</h3><p>&emsp;虽然细粒度锁是对单一粒度锁的一种改进，但它仍然出现很长的获取锁和释放锁的序列。而且，访问链表中不同部分的线程仍然可能相互阻塞。例如，一个正在删除链表中第二个元素的线程将会阻塞所有试图查找后继节点的线程。<br>&emsp;减少同步代价的一种方式就是乐观：<strong><em>不需要获取锁就可以查找，对找到的节点进行加锁，然后确认锁住的节点是正确的；如果一个同步冲突导致节点被错误的锁定，则释放这些锁重新开始</em></strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = item.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//如果不成功，就进行重试</span></span><br><span class="line">        Node pred = head;</span><br><span class="line">        Node curr = pred.next;</span><br><span class="line">        <span class="keyword">while</span> (curr.key &lt; key) &#123;</span><br><span class="line">            pred = curr;</span><br><span class="line">            curr = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到目标相关的pred和curr之后再将二者锁住</span></span><br><span class="line">        pred.lock();</span><br><span class="line">        curr.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//锁住二者之后再进行判断，是否存在并发冲突</span></span><br><span class="line">            <span class="keyword">if</span> (validate(pred, curr)) &#123;</span><br><span class="line">                <span class="comment">//如果不存在，那么就直接进行正常操作</span></span><br><span class="line">                <span class="keyword">if</span> (curr.key == key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node node = <span class="keyword">new</span> Node(item);</span><br><span class="line">                    node.next = curr;</span><br><span class="line">                    pred.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pred.unlock();</span><br><span class="line">            curr.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(Node pred, Node curr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从队列头开始查找pred和curr,判断是否存在并发冲突</span></span><br><span class="line">    Node node = head;</span><br><span class="line">    <span class="keyword">while</span> (node.key &lt;= pred.key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == pred) &#123;</span><br><span class="line">            <span class="keyword">return</span> pred.next == curr;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;由于不再使用能保护并发修改的锁，所以每个方法调用都可能遍历那些已经被删除的节点，所以在进行添加，删除获取判断是否存在的之前必须再次进行验证。</p>
<h3 id="惰性同步"><a href="#惰性同步" class="headerlink" title="惰性同步"></a>惰性同步</h3><p>&emsp;当不用锁遍历两次链表的代价比使用锁遍历一次链表的代价小很多时，乐观同步的实现效果非常好。但是这种算法的缺点之一就是contains()方法在遍历时需要锁，这一点并不令人满意，其原因在于对contains()的调用要比其他方法的调用频繁得多。<br>&emsp;<strong><em>使用惰性同步的方法，使得contains()调用是无等待的，同时add()和remove()方法即使在被阻塞的情况下也只需要遍历一次链表</em></strong>。<br>&emsp;<strong><em>对每个节点增加一个布尔类型的marked域，用于说明该节点是否在节点集合中。现在，遍历不再需要锁定目标结点，也没有必须通过重新遍历整个链表来验证结点是否可达。所有未被标记的节点必然是可达的</em></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add方法和乐观同步的方法一致，只有检验方法做了修改。</span></span><br><span class="line"><span class="comment">//只需要检测节点的marked变量就可以，并且查看pred的next是否还是指向curr，需要注意的是marked变量一定是voliate的。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(Node pred, Node curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !pred.marked &amp;&amp; !curr.marked &amp;&amp; pred.next == curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;惰性同步的优点之一就是能够将类似于设置一个flag这样的逻辑操作与类似于删除结点的链接这种对结构的物理改变分开。通常情况下，延迟操作可以是批量处理方式进行，且在某个方便的时候再懒惰地进行处理，从而降低了对结构进行物理修改的整体破裂性。惰性同步的主要缺点是add()和remove()调用是阻塞的：如果一个线程延迟，那么其他线程也将延迟。</p>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>&emsp;使用惰性同步的思维是非常有益处的。我们可以进一步将add(),remove()和contains()这三个方法都变成非阻塞的。前两个方法是无锁的，最后一个方法是无等待的。我们无法直接使用compareAndSet()来改变next域来实现，因为这样会出现问题。但是我们可以将结点的next域和marked域看作是单个的原子单位：当marked域为true时，对next域的任何修改都将失败。<br>&emsp;我们可以使用AtomicMarkableReference<t>对象将指向类型T的对象引用next和布尔值marked封装在一起。这些域可以一起或单个地原子更新。可以让每个结点的next域为一个AtomicMarkableReference<node>。线程可以通过设置结点next域中的标记位来逻辑地删除curr,和其他正在执行add()和remove()的线程共享物理删除:当每个线程遍历链表时，通过物理删除所有被标记的节点来清理链表。</node></t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Window <span class="title">find</span><span class="params">(Node head, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node pred = <span class="keyword">null</span>, curr = <span class="keyword">null</span>, succ = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] marked = &#123;<span class="keyword">false</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> snip;</span><br><span class="line"></span><br><span class="line">        retry: <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            pred = head;</span><br><span class="line">            curr = curr.next.get(marked);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                succ = curr.next.get(marked); <span class="comment">//获取succ,并且查看是被被标记</span></span><br><span class="line">                <span class="keyword">while</span> (marked[<span class="number">0</span>]) &#123;<span class="comment">//如果被标记了，说明curr被逻辑删除了，需要继续物理删除</span></span><br><span class="line">                    snip = pred.next.compareAndSet(curr, succ, <span class="keyword">false</span>, <span class="keyword">false</span>);<span class="comment">//</span></span><br><span class="line">                    <span class="keyword">if</span> (!snip) <span class="keyword">continue</span> retry;</span><br><span class="line">                    curr = succ;</span><br><span class="line">                    succ = curr.next.get(marked);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当不需要删除后，才继续遍历</span></span><br><span class="line">                <span class="keyword">if</span> (curr.key &gt;= key) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Window(pred, curr);</span><br><span class="line">                &#125;</span><br><span class="line">                pred = curr;</span><br><span class="line">                curr = succ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key = item.hashCode();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            Window window = find(head, key);</span><br><span class="line">            Node pred = window.pred, curr = window.curr;</span><br><span class="line">            <span class="keyword">if</span> (curr.key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Node node = <span class="keyword">new</span> Node(item);</span><br><span class="line">                node.next = <span class="keyword">new</span> AtomicMarkableReference&lt;&gt;(curr, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (pred.next.compareAndSet(curr, node, <span class="keyword">false</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key = item.hashCode();</span><br><span class="line">        <span class="keyword">boolean</span> sinp;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            Window window = find(head, key);</span><br><span class="line">            Node pred = window.pred, curr = window.curr;</span><br><span class="line">            <span class="keyword">if</span> (curr.key != key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Node succ = curr.next.getReference();</span><br><span class="line">                <span class="comment">//要进行删除了，那么就直接将curr.next设置为false,然后在进行真正的物理删除。</span></span><br><span class="line">                sinp = curr.next.compareAndSet(curr, succ, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (!sinp) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pred.next.compareAndSet(curr, succ, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">          AtomicMarkableReference&lt;Node&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;文中的代码在我的github的这个<a href="https://github.com/ztelur/MultiprocessorProgramming/tree/master/src/com/company/nine" target="_blank" rel="external">repo</a>中都可以找到。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/多线程/">多线程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/锁/">锁</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/06/19/《多处理器编程艺术》－链表：锁的作用/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/06/19/《多处理器编程艺术》－链表：锁的作用/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/03/2017年，计划目录/" title="2017年，计划目录" itemprop="url">2017年，计划目录</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2017-05-03T06:40:16.000Z" itemprop="datePublished"> Published 2017-05-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;和<a href="http://remcarpediem.com/2016/03/05/2016%E5%B9%B4%EF%BC%8C%E8%AE%A1%E5%88%92%E7%9B%AE%E5%BD%95/">16年计划</a>一样，建立一个计划目录，记录一下17年的计划和实现情况,进行不定时的更新。</p>
<h2 id="计划清单"><a href="#计划清单" class="headerlink" title="计划清单"></a>计划清单</h2><h3 id="英语学习"><a href="#英语学习" class="headerlink" title="英语学习"></a>英语学习</h3><h4 id="单词量"><a href="#单词量" class="headerlink" title="单词量"></a>单词量</h4><ul>
<li>口语小助手 <strong>2017.1.30~</strong></li>
</ul>
<h4 id="口语"><a href="#口语" class="headerlink" title="口语"></a>口语</h4><ul>
<li>每天一集《摩登家庭》的听力口语练习 <strong>2017.1.30~</strong></li>
</ul>
<h3 id="Android开发"><a href="#Android开发" class="headerlink" title="Android开发"></a>Android开发</h3><h4 id="Android性能方面研究"><a href="#Android性能方面研究" class="headerlink" title="Android性能方面研究"></a>Android性能方面研究</h4><h5 id="GT开源项目研究"><a href="#GT开源项目研究" class="headerlink" title="GT开源项目研究"></a>GT开源项目研究</h5><h4 id="博客文章"><a href="#博客文章" class="headerlink" title="博客文章"></a>博客文章</h4><h5 id="Android富文本"><a href="#Android富文本" class="headerlink" title="Android富文本"></a>Android富文本</h5><h5 id="Android-Trasication动画"><a href="#Android-Trasication动画" class="headerlink" title="Android Trasication动画"></a>Android Trasication动画</h5><h3 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h3><h3 id="要阅读的书籍"><a href="#要阅读的书籍" class="headerlink" title="要阅读的书籍"></a>要阅读的书籍</h3><ul>
<li>《暗时间》<strong>2017.1.30~</strong><h3 id="习惯养成"><a href="#习惯养成" class="headerlink" title="习惯养成"></a>习惯养成</h3></li>
</ul>
<h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><ul>
<li>关灯之后不准再玩手机</li>
<li>11点半左右睡觉</li>
</ul>
<h4 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h4><ul>
<li>每日的思考，总结和回顾</li>
</ul>
<h2 id="Update-2017-1-1"><a href="#Update-2017-1-1" class="headerlink" title="Update 2017.1.1"></a>Update 2017.1.1</h2><p>&emsp;开始制定计划，一个星期时间。</p>
<h2 id="Update-2017-1-30"><a href="#Update-2017-1-30" class="headerlink" title="Update 2017.1.30"></a>Update 2017.1.30</h2><p>&emsp;制订2月计划</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul>
<li>两篇博文：Android富文本和Android Trasication动画</li>
<li>Gt开源项目研究</li>
</ul>
<h3 id="《暗时间》研读"><a href="#《暗时间》研读" class="headerlink" title="《暗时间》研读"></a>《暗时间》研读</h3><h3 id="英语口语练习"><a href="#英语口语练习" class="headerlink" title="英语口语练习"></a>英语口语练习</h3><h3 id="思维的习惯，总结，回顾，自醒！！！！！"><a href="#思维的习惯，总结，回顾，自醒！！！！！" class="headerlink" title="思维的习惯，总结，回顾，自醒！！！！！"></a>思维的习惯，总结，回顾，自醒！！！！！</h3><h2 id="Update-2017-4-6"><a href="#Update-2017-4-6" class="headerlink" title="Update 2017.4.6"></a>Update 2017.4.6</h2><h3 id="书籍-正在进行-预计时间3个月"><a href="#书籍-正在进行-预计时间3个月" class="headerlink" title="书籍 正在进行,预计时间3个月"></a>书籍 <strong>正在进行,预计时间3个月</strong></h3><ul>
<li>多核编程的艺术</li>
<li>高效能Mysql</li>
</ul>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h4 id="RPC简单框架"><a href="#RPC简单框架" class="headerlink" title="RPC简单框架"></a>RPC简单框架</h4><h4 id="Netty源码分析"><a href="#Netty源码分析" class="headerlink" title="Netty源码分析"></a>Netty源码分析</h4><h3 id="Java并发知识"><a href="#Java并发知识" class="headerlink" title="Java并发知识"></a>Java并发知识</h3><h4 id="JUC源码分析"><a href="#JUC源码分析" class="headerlink" title="JUC源码分析"></a>JUC源码分析</h4><h4 id="无锁算法"><a href="#无锁算法" class="headerlink" title="无锁算法"></a>无锁算法</h4><h2 id="Update-2017-5-3"><a href="#Update-2017-5-3" class="headerlink" title="Update 2017.5.3"></a>Update 2017.5.3</h2><h3 id="书籍-正在进行-预计时间3个月-1"><a href="#书籍-正在进行-预计时间3个月-1" class="headerlink" title="书籍 正在进行,预计时间3个月"></a>书籍 <strong>正在进行,预计时间3个月</strong></h3><ul>
<li>多核编程的艺术 读完第一章</li>
<li>高效能Mysql </li>
</ul>
<h3 id="mit-分布式课程-预计２个月"><a href="#mit-分布式课程-预计２个月" class="headerlink" title="mit 分布式课程 预计２个月"></a>mit 分布式课程 <strong>预计２个月</strong></h3><p>主页：<a href="http://nil.csail.mit.edu/6.824/2015/index.html" target="_blank" rel="external">http://nil.csail.mit.edu/6.824/2015/index.html</a><br>github:<a href="https://github.com/ztelur/mit-distributed-systems" target="_blank" rel="external">https://github.com/ztelur/mit-distributed-systems</a><br>经典课程啊，使用go语言，坚持自己把lab都做完</p>
<h3 id="中间件-1"><a href="#中间件-1" class="headerlink" title="中间件"></a>中间件</h3><h4 id="RPC简单框架-1"><a href="#RPC简单框架-1" class="headerlink" title="RPC简单框架"></a>RPC简单框架</h4><ul>
<li><a href="http://remcarpediem.com/2017/04/16/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Paxos/">分布式一致性算法Paxos</a><h4 id="Netty源码分析-1"><a href="#Netty源码分析-1" class="headerlink" title="Netty源码分析"></a>Netty源码分析</h4></li>
<li><p><a href="http://remcarpediem.com/2017/04/02/Netty%E6%BA%90%E7%A0%81-%E4%B8%89-I-O%E6%A8%A1%E5%9E%8B%E5%92%8CJava-NIO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">Netty源码(三):I/O模型和Java NIO底层原理</a></p>
</li>
<li><p><a href="http://remcarpediem.com/2017/03/27/Netty%E6%BA%90%E7%A0%81-%E4%BA%8C-Netty%E7%9A%84Channel%E5%92%8CPipeline/">Netty源码(二):Netty的Channel和Pipeline</a></p>
</li>
<li><a href="http://remcarpediem.com/2017/03/22/Netty%E6%BA%90%E7%A0%81-%E4%B8%80-Netty%E4%B8%AD%E7%9A%84Buffer/">Netty源码(一):Netty中的Buffer</a></li>
<li>Netty的网络模型　还未进行<h3 id="Java并发知识-1"><a href="#Java并发知识-1" class="headerlink" title="Java并发知识"></a>Java并发知识</h3><h4 id="JUC源码分析-1"><a href="#JUC源码分析-1" class="headerlink" title="JUC源码分析"></a>JUC源码分析</h4></li>
<li><a href="http://remcarpediem.com/2017/04/06/AbstractQueuedSynchronizer%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">AbstractQueuedSynchronizer超详细原理解析</a></li>
<li><a href="http://remcarpediem.com/2017/04/21/LongAdder%E8%A7%A3%E6%9E%90/">LongAdder解析</a></li>
<li><a href="http://remcarpediem.com/2017/05/03/BlockingQueue%E4%B8%8ECondition%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">BlockingQueue与Condition原理解析</a><h4 id="无锁算法-1"><a href="#无锁算法-1" class="headerlink" title="无锁算法"></a>无锁算法</h4></li>
<li>ConcurrentHashMap　待写博客</li>
</ul>
<h2 id="Update-2017-10-7"><a href="#Update-2017-10-7" class="headerlink" title="Update 2017.10.7"></a>Update 2017.10.7</h2><p>&emsp;已经很久没有指定过计划了，前段时间因为家里和校招的原因，牵扯了很多精力，而且个人也逐渐变得放松起来，确实，工作已经确定，是可以放松一下了。所以我决定之后的目标集中在个人习惯方面，并且增加对经济和金融的学习，为以后个人财务管理和投资做准备。</p>
<h3 id="Java后台编程"><a href="#Java后台编程" class="headerlink" title="Java后台编程"></a>Java后台编程</h3><p>&emsp;Spring Cloud Stream的源码已经研究很久了，但是由于之前对Spring的不熟悉，一直没有结果，希望尽快把文章写出来，并且可以发到一些比较有影响的平台上去，另外Stream和Rocket的结合也希望作为我个人的项目来尽快完成</p>
<ul>
<li>Spring Cloud Stream 源码分析</li>
<li>Spring Cloud Stream Rocket binder的编写</li>
</ul>
<h3 id="编程习惯"><a href="#编程习惯" class="headerlink" title="编程习惯"></a>编程习惯</h3><p>&emsp;我一直认为我不算一个优秀的程序员，一是很多编程习惯不是很好，二是确实实际代码行数也不够，所以我最近一段时间从下面这些方面来提升</p>
<ul>
<li>自动化与快捷键 shell编程的利用，编程IDE的快捷键，虽然这些都是最简单的，但是我希望从这里开始入手吧</li>
<li>编程风格：统一一致，代码大全学过很多，但是自己写代码有是另外一种情况，还得从新来过</li>
</ul>
<h3 id="工作生活习惯"><a href="#工作生活习惯" class="headerlink" title="工作生活习惯"></a>工作生活习惯</h3><p>&emsp;最近由于比较懈怠，平常学习过程中都比较随意，经常边写代码边看游戏视频，学习股票知识也都是看看就好，我希望之后的一个月内能够养成下列的习惯吧。</p>
<ul>
<li>一心一用：学习时就别看视频，也别学个10分钟就玩一下手机了。番茄工作法吧。</li>
<li>看书，看学习视频要认真，笔记，复习</li>
<li>每日计划和回顾</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/计划/">计划</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/05/03/2017年，计划目录/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/05/03/2017年，计划目录/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/03/BlockingQueue与Condition原理解析/" title="BlockingQueue与Condition原理解析" itemprop="url">BlockingQueue与Condition原理解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2017-05-03T02:07:45.000Z" itemprop="datePublished"> Published 2017-05-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p> 我在前段时间写了一篇关于AQS的<a href="http://remcarpediem.com/2017/04/06/AbstractQueuedSynchronizer%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">文章</a>，在文章里边我说几乎所有在<code>JUC</code>包中的所有多线程相关的类都和<code>AQS</code>相关，今天我就在这里总结一下另一个依赖于<code>AQS</code>来实现的同步工具类：<code>BlockingQueue</code>。我们主要以<code>ArrayBlockingQueue</code>为主来分析相关的源码。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p> 相信大多数同学都是在学习线程池相关知识时了解到阻塞队列的概念的。知道各种类型的阻塞队列对线程池初始化时的影响。在java doc中这样定义阻塞队列。当从阻塞队列获取元素但是队列为空时，当前线程会阻塞直到另一个线程向阻塞队列中添加一个元素；类似的，当向一个阻塞队列加入元素时，如果队列已经满了，当前线程也会阻塞知道另外一个线程从队列中读取一个元素。阻塞队列一般都是FIFO,用来实现生产者和消费者模式。阻塞队列的方法通过四种不同的方式来处理操作无法被立即完成的情况，这四种情况分别为抛出异常，返回特殊值(null或在是false),阻塞当前线程直到执行结束，最后一种是只阻塞固定时间，然后还未执行成功就放弃操作。这些方法都总结在下边这种表中了。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-condition-BlockingQueue.png" alt="BlockingQueue"></p>
<p> 我们就只分析<code>put</code>和<code>take</code>方法。</p>
<h3 id="put和take函数"><a href="#put和take函数" class="headerlink" title="put和take函数"></a>put和take函数</h3><p> 我们都知道，使用同步队列可以很轻松的实现生产者-消费者模式，其实，同步队列就是按照生产者-消费者的模式来实现的，我们可以将<code>put</code>函数看作生产者的操作，<code>take</code>是消费者的操作。<br> <code>put</code>函数会在队列末尾添加元素，如果队列已经满了，无法添加元素的话，就一直阻塞等待到可以加入为止。函数的源码如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">//先获得锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) </span><br><span class="line">        <span class="comment">//如果队列满了，就NotFull这个condition对象上进行等待</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="comment">//这里可以注意的是ArrayBlockingList实际上使用Array实现了一个环形数组，</span></span><br><span class="line">   <span class="comment">//当putIndex达到最大时，就返回到起点，继续插入,</span></span><br><span class="line">   <span class="comment">//当然，如果此时0位置的元素还没有被取走，</span></span><br><span class="line">   <span class="comment">//下次put时，就会因为cout == item.length未被阻塞。</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">//因为插入了元素，通知等待notEmpty事件的线程。</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 我们会发现put函数也是使用了wait/notify的机制。与一般生产者-消费者的实现方式不同，同步队列使用<code>ReentrantLock</code>和<code>Condition</code>相结合的先获得锁，再等待的机制；而不是<code>synchronized</code>和<code>Object.wait</code>的机制。这里的区别我们下一节再详细讲解。<br> 看完了生产者相关的<code>put</code>函数，我们再来看一下消费者调用的<code>take</code>函数。<code>take</code>函数在队列为空时会被阻塞，一直到阻塞队列加入了新的元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果队列为空，那么在notEmpty对象上等待，</span></span><br><span class="line">        <span class="comment">//当put函数调用时，会调用notEmpty的notify进行通知。</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>; <span class="comment">//取出takeIndex位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        <span class="comment">//如果到了尾部，将指针重新调整到头部</span></span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//通知notFull对象上等待的线程</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Condition-await和Object-wait"><a href="#Condition-await和Object-wait" class="headerlink" title="Condition.await和Object.wait"></a>Condition.await和Object.wait</h3><p> 我们发现<code>ArrayBlockingList</code>并没有使用<code>Object.wait</code>，而是使用的<code>Condition.await</code>，这是为什么呢？其中又有哪些原因呢？<br> <code>Condition</code>对象可以提供和<code>Object</code>的<code>wait</code>和<code>notify</code>一样的行为，但是后者必须使用<code>synchronized</code>这个内置的monitor锁，而<code>Condition</code>使用的是<code>RenentranceLock</code>。这两种方式在阻塞等待时都会将相应的锁释放掉，但是<code>Condition</code>的等待可以中断，这是二者唯一的区别。<br>＆emsp;Condition的流程大致如下边两张图所示.</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-condition-condition1.png" alt="await"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-condition-condition2.png" alt="notify"></p>
<p> 我们首先来看一下<code>await</code>函数的实现，详细的讲解都在代码中．</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//在condition wait队列上添加新的节点</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//释放当前持有的锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//由于node在之前是添加到condition wait queue上的，现在判断这个node</span></span><br><span class="line">    <span class="comment">//是否被添加到Sync的获得锁的等待队列上。</span></span><br><span class="line">    <span class="comment">//node在condition queue上说明还在等待事件的notify,</span></span><br><span class="line">    <span class="comment">//notify函数会将condition queue 上的node转化到Sync的队列上。</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//node还没有被添加到Sync Queue上，说明还在等待事件通知</span></span><br><span class="line">        <span class="comment">//所以调用park函数来停止线程执行</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//判断是否被中断,线程从park函数返回有两种情况，一种是</span></span><br><span class="line">        <span class="comment">//其他线程调用了unpark,另外一种是线程被中断</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代码执行到这里，已经有其他线程调用notify函数，或则被中断，该线程可以继续执行，但是必须先</span></span><br><span class="line">    <span class="comment">//再次获得调用await函数时的锁．acquireQueued函数在AQS文章中做了介绍．</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">  　．．．．</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//AQS的方法，当前已经在锁中了，所以直接操作</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">//获取state当前的值，然后保存，以待以后恢复</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Checks for interrupt, returning THROW_IE if interrupted</span><br><span class="line"> * before signalled, REINTERRUPT if after signalled, or</span><br><span class="line"> * 0 if not interrupted.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//中断可能发生在两个阶段中，一是在等待singla,另外一个是在获得signal之后</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里要和下边的transferForSignal对应着看，这是线程中断进入的逻辑．那边是signal的逻辑</span></span><br><span class="line">    <span class="comment">//两边可能有并发冲突，但是成功的一方必须调用enq来进入acquire lock queue中．</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果失败了，说明transferForSignal那边成功了，等待node 进入acquire lock queue</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>signal</code>函数将等待事件最长时间的线程节点从等待condition的队列移动到获得lock的等待队列中．<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">    <span class="comment">//如果当前线程没有获得锁，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//将Condition wait queue中的第一个node转移到acquire lock queue中．</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    do &#123;</span><br><span class="line">　　 <span class="comment">//由于生产者的signal在有消费者等待的情况下，必须要通知</span></span><br><span class="line">        <span class="comment">//一个消费者，所以这里有一个循环，直到队列为空</span></span><br><span class="line">        <span class="comment">//把first 这个node从condition queue中删除掉</span></span><br><span class="line">        <span class="comment">//condition queue的头指针指向node的后继节点，如果node后续节点为null,那么也将尾指针也置为null</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//transferForSignal将node转而添加到Sync的acquire lock 队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果设置失败，说明该node已经被取消了,所以返回false,让doSignal继续向下通知其他未被取消的node</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//将node添加到acquire lock　queue中．</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">//需要注意的是这里的node进行了转化</span></span><br><span class="line">    <span class="comment">//ws&gt;0代表canceled的含义所以直接unpark线程</span></span><br><span class="line">    <span class="comment">//如果compareAndSetWaitStatus失败，所以直接unpark,让线程继续执行await中的</span></span><br><span class="line">    <span class="comment">//进行isOnSyncQueue判断的while循环,然后进入acquireQueue函数．</span></span><br><span class="line">    <span class="comment">//这里失败的原因可能是Lock其他线程释放掉了锁，同步设置p的waitStatus</span></span><br><span class="line">    <span class="comment">//如果compareAndSetWaitStatus成功了呢？那么该node就一直在acquire lock queue中</span></span><br><span class="line">    <span class="comment">//等待锁被释放掉再次抢夺锁，然后再unparｋ</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;后边一篇文章主要讲解如何自己使用<code>AQS</code>来创建符合自己业务需求的锁，请大家继续关注我的文章啦．一起进步偶．</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/并发/">并发</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JUC/">JUC</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/05/03/BlockingQueue与Condition原理解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/05/03/BlockingQueue与Condition原理解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/21/LongAdder解析/" title="LongAdder解析" itemprop="url">LongAdder解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2017-04-21T14:38:05.000Z" itemprop="datePublished"> Published 2017-04-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>＆emsp;对<code>LongAdder</code>的最初了解是从Coolshell上的一篇文章中获得的，但是一直都没有深入的了解过其实现，只知道它相较于<code>AtomicLong</code>来说，更加适合读多写少的并发情景。今天，我们就研究一下<code>LongAdder</code>的原理，探究一下它如此高效的原因。</p>
<h3 id="基本原理和思想"><a href="#基本原理和思想" class="headerlink" title="基本原理和思想"></a>基本原理和思想</h3><p> 我们都知道<code>AtomicLong</code>是通过无限循环不停的采取CAS的方法去设置value，直到成功为止。那么当并发数比较多或出现更新热点时，就会导致CAS的失败机率变高，重试次数更多，越多的线程重试，CAS失败的机率越高，形成恶性循环，从而降低了效率。而LongAdder的原理就是降低对value更新的并发数，也就是将对单一value的变更压力分散到多个value值上，降低单个value的“热度”<br> 我们知道<code>LongAdder</code>的大致原理之后，再来详细的了解一下它的具体实现，其中也有很多值得借鉴的并发编程的技巧。</p>
<h3 id="Add操作"><a href="#Add操作" class="headerlink" title="Add操作"></a>Add操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123; <span class="comment">//step1</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> || <span class="comment">//step2</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||  <span class="comment">//step3</span></span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x))) <span class="comment">//step4</span></span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended); <span class="comment">// step5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>cells</code>是<code>LongAdder</code>的父类<code>Striped64</code>中的<code>Cell</code>数组类型的成员变量。每个<code>Cell</code>对象中都包含一个value值，并提供对这个value值的CAS操作。<br> 我们来看一下<code>casBase</code>函数相关的源码吧。我们可以认为变量<code>base</code>就是第一个value值，也是基础value变量。先调用casBase函数来cas一下base变量，如果成功了，就不需要在进行下面比较复杂的算法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final boolean casBase(long cmp, long val) &#123;</span><br><span class="line">    return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 然后我们继续看step2第二层条件语句中执行的逻辑。如果cells数组为null或为空,就直接调用<code>longAccumulate</code>方法。因为cells为null或在为空，说明cells未完全初始化，所以调用<code>longAccumulate</code>进行初始化。否则继续判断。<br> 如果cells中已经有对象了，那么执行step3。我们先来理解一下<code>getProbe() &amp; m</code>的这个操作吧。我们可以首先将这个操作当作一次计算”hash”值,然后将cells中这个位置的Cell对象赋值给变量a。然后判断a是否为null,如果不为null,那么就调用Cell对象自己的cas方法去设置value值。如果a为null,或在cas赋值发生冲突，那么也是开始调用<code>longAccumulate</code>方法。</p>
<h3 id="LongAccumulate方法"><a href="#LongAccumulate方法" class="headerlink" title="LongAccumulate方法"></a>LongAccumulate方法</h3><p> <code>longAccumulate</code>函数比较复杂，带有我的注释的代码已经贴在了文章后边，这里我们就只讲一下其中比较关键的一些技巧和思想．<br> 首先，我们都知道只有当对<code>base</code>的cas操作失败之后，<code>LongAdder</code>才引入<code>Cell</code>数组．所以在<code>longAccumulate</code>中就是对<code>Cell</code>数组进行操作．分别涉及了数组的初始化，扩容和设置某个位置的Cell对象等操作．<br> 在这段代码中，关于cellBusy的cas操作构成了一个SpinLock,这就是经典的SpinLock的编程技巧，大家可以学习一下．</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span><br><span class="line">                             <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">       <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123; <span class="comment">//获取PROBE变量，探针变量，与当前运行的线程相关，不同线程不同</span></span><br><span class="line">           ThreadLocalRandom.current(); <span class="comment">//初始化PROBE变量，和getProbe都使用Unsafe类提供的原子性操作。</span></span><br><span class="line">           h = getProbe();</span><br><span class="line">           wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123; <span class="comment">//cas经典无限循环，不断尝试</span></span><br><span class="line">           Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">           <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123; <span class="comment">// cells不为null,并且数组size大于0</span></span><br><span class="line">           <span class="comment">//表示cells已经初始化了</span></span><br><span class="line">               <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123; <span class="comment">//通过与操作计算出来需要操作的Cell对象的坐标</span></span><br><span class="line">                   <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123; <span class="comment">//volatile 变量，用来实现spinLock,来在初始化和resize cells数组时使用。</span></span><br><span class="line">                   <span class="comment">//当cellsBusy为0时，表示当前可以对cells数组进行操作。 </span></span><br><span class="line">                       Cell r = <span class="keyword">new</span> Cell(x);<span class="comment">//将x值直接赋值给Cell对象</span></span><br><span class="line">                       <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;<span class="comment">//如果这个时候cellsBusy还是0</span></span><br><span class="line">                       <span class="comment">//就cas将其设置为非０，如果成功了就是获得了spinLock的锁．可以对cells数组进行操作．</span></span><br><span class="line">                       <span class="comment">//如果失败了，就会再次执行一次循环</span></span><br><span class="line">                           <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                               <span class="comment">//判断cells是否已经初始化，并且要操作的位置上没有cell对象．</span></span><br><span class="line">                               <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                   (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                   rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   rs[j] = r;　<span class="comment">//将之前创建的值为x的cell对象赋值到cells数组的响应位置．</span></span><br><span class="line">                                   created = <span class="keyword">true</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                               <span class="comment">//经典的spinLock编程技巧，先获得锁，然后try finally将锁释放掉</span></span><br><span class="line">                               <span class="comment">//将cellBusy设置为0就是释放锁．</span></span><br><span class="line">                               cellsBusy = <span class="number">0</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">if</span> (created)</span><br><span class="line">                               <span class="keyword">break</span>;　<span class="comment">//如果创建成功了，就是使用x创建了新的cell对象，也就是新创建了一个分担热点的value</span></span><br><span class="line">                           <span class="keyword">continue</span>; </span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   collide = <span class="keyword">false</span>; <span class="comment">//未发生碰撞</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)<span class="comment">//是否已经发生过一次cas操作失败</span></span><br><span class="line">                   wasUncontended = <span class="keyword">true</span>; <span class="comment">//设置成true,以便第二次进入下一个else if 判断</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                            fn.applyAsLong(v, x))))</span><br><span class="line">                  　<span class="comment">//fn是操作类型，如果是空，就是相加，所以让a这个cell对象中的value值和x相加，然后在cas设置，如果成果</span></span><br><span class="line">                  <span class="comment">//就直接返回</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">               　　<span class="comment">//如果cells数组的大小大于系统的可获得处理器数量或在as不再和cells相等．</span></span><br><span class="line">                   collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                   collide = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">               　　<span class="comment">//再次获得cellsBusy这个spinLock,对数组进行resize</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (cells == as) &#123;<span class="comment">//要再次检测as是否等于cells以免其他线程已经对cells进行了操作．</span></span><br><span class="line">                           Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>]; <span class="comment">//扩容一倍</span></span><br><span class="line">                           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                               rs[i] = as[i];</span><br><span class="line">                           cells = rs;<span class="comment">//赋予cells一个新的数组对象</span></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       cellsBusy = <span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   collide = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               h = advanceProbe(h);<span class="comment">//由于使用当前探针变量无法操作成功，所以重新设置一个,再次尝试</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">           <span class="comment">//cells数组未初始化，获得cellsBusy　lock,来初始化</span></span><br><span class="line">               <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                   <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                       Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                       rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x); <span class="comment">//设置x的值为cell对象的value值</span></span><br><span class="line">                       cells = rs;</span><br><span class="line">                       init = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   cellsBusy = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (init)</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;<span class="comment">//如果初始化数组失败了，那就再次尝试一下直接cas base变量，如果成功了就直接返回</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                       fn.applyAsLong(v, x))))</span><br><span class="line">               <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;本篇文章写的不是很好，我写完之后又看了一遍coolshell上的这篇关于<code>LongAdder</code>的<a href="http://coolshell.cn/articles/11454.html" target="_blank" rel="external">文章</a>，感觉自己没有人家写的那么简介明了。我对代码细节的注释和投入太多了。其实很多代码大家都可以看懂，并不需要大量的代码片段加注释。以后要注意一下。之后会接着研究一下JUC包中的其他类，希望大家多多关注。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/并发/">并发</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JUC/">JUC</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/04/21/LongAdder解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/04/21/LongAdder解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/16/分布式一致性算法Paxos/" title="分布式一致性算法Paxos" itemprop="url">分布式一致性算法Paxos</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2017-04-16T06:42:35.000Z" itemprop="datePublished"> Published 2017-04-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p> 最近在学习zookeeper原理的时候了解到了paxos算法,看了几篇文章之后还是感觉有些迷糊,后来看了知行学社的<a href="http://www.tudou.com/programs/view/e8zM8dAL6hM/" target="_blank" rel="external">paxos视频</a>才对这个算法有了一定的了解,这里就做一下总结.</p>
<h3 id="Paxos简介"><a href="#Paxos简介" class="headerlink" title="Paxos简介"></a>Paxos简介</h3><p> Paxos是Lamport于1990年提出的一种基于消息传递而具有高度容错特性的分布式一致性算法.这个算法是分布式中最为重要的算法,Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法,那就是Paxos,其他算法都是残次品.具体Paxos算法的详细内涵和故事背景大家可以参考知乎上的<a href="https://www.zhihu.com/question/19787937" target="_blank" rel="external">回答</a>;</p>
<h3 id="Paxos的使用场景和假设"><a href="#Paxos的使用场景和假设" class="headerlink" title="Paxos的使用场景和假设"></a>Paxos的使用场景和假设</h3><p> 我们都知道基于消息传递通信模型的分布式系列,不可避免的会发生以下错误:进程可能会慢,被杀死或在重启,消息可能会有延迟,丢失和重复.Paxos算法解决的问题就是在一个可能发生上述异常的分布式系统中如何就某个值达成一致,保证无论发生以上任何异常,都不会破坏决议的一致性。但是Paxos算法也有一定的使用假设。一个假设是在消息传递的过程中不会出现拜占庭将军问题：即虽然有可能一个消息被传递两次，但是绝对不会出现错误的消息。另一个假设是提议不会被反对，只能被同意或在被更新的提议替换。<br> Paxos协议中有三种角色，每个节点可以扮演多个角色：</p>
<ul>
<li>倡议者(Proposer):提议者可以提出提议(数值或在操作命令)以供投票表决。</li>
<li>接受者(Acceptor):接受者可以对提议者提出的提议进行投票表决，提议有超过半数的接收者投票即被选中。</li>
<li>学习者(Learner):学习者无投票者，只是从接收者那里获取哪个提议被选中。</li>
</ul>
<p> 在Paxos算法中，一个或在多个Proposer都可以并发的提出提议；系统必须针对所有提议中的某个提议达成一致（超过半数大的接受者选中）；最多只能对一个确定的提议达成一致；只要超过半数的节点存活且可以互相通信，整个系统一定可以达成一致，即选择一个确定的提议。<br> 如果直接讲解Paxos算法，大家可能会有些难以理解，这里我们就按着视频里的顺序，先从简单的分布式一致性算法开始，然后不断进行优化，最后将其演变成Paxos算法。</p>
<h3 id="图解Paxos主要流程"><a href="#图解Paxos主要流程" class="headerlink" title="图解Paxos主要流程"></a>图解Paxos主要流程</h3><p> Paxoso算法分为两个的阶段，我们就将其分别记为Phase1和Phase2.每个Proposer都持有一个独有的变量epoch,每个Acceptor都保存三个状态：lastest_prepared__epoch,accepted_epoch和accepted_value.lastest_prepared_epoch是指Acceptor授予访问权的Proposer的epoch值，accepted_epoch是Acceptor接受提议的Proposer的epoch值，而accepted_value就是Acceptor接受的提议值喽，他们的初始值都为null。</p>
<h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><p> Phase1过程中，Proposer向Acceptor发起<code>Prepare(epoch)</code>请求来获取访问权。将自己的epoch发送给Acceptor.而Acceptor只会接受比lastest_prepared_epoch更大的epoch,并给予访问权，并将epoch记录到lastest_prepared_epoch的值中，返回当前的accepted_epoch和accepted_value的值。在初始化状态下，二者都是null,所以返回的是<null,null>。如果epoch小于lastest_prepared_epoch则不授予访问权，并返回<error>。<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-paxos-paxos1.png" alt="phase1"><br> 如上图所示，Proposer1向5个Acceptor发送了Prepare(#1)的请求，其中前三个请求顺利到达，Acceptor授予访问权，返回<null,null>，并修改lastest_prepared_epoch为1。而后两个请求发生了网络延迟,一直未到达相应的Acceptor。<br> 在阶段一中，Proposer需要获得半数以上的Acceptor的访问权和对应的一组value的取值才会进行第二阶段，这样才会确保，一个Proposer提出的确定的议案会被另外一个Proposer发现，从而在阶段二中会进行正确的操作。</null,null></error></null,null></p>
<h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><p> 第二阶段采取“后者认同前者”的原则进行。在肯定旧epoch无法生成确定性取值时，新的epoch会提交自己的取值，不会冲突；一旦旧epoch形成了确定性取值，那么该proposer一定可以获得该取值，并且会认同该取值，不会破坏。<br> 如果Proposer在第一阶段获取的value值都是null,则旧epoch无法形成确定性取值，此时让自己的<epoch,v>成为确定性取值：</epoch,v></p>
<ul>
<li>向epoch对应的所有acceptor提交取值<epoch,v></epoch,v></li>
<li>如果收到半数以上的成功应答，则返回<ok,v></ok,v></li>
<li>否则返回<error></error></li>
</ul>
<p> 如果value的取值不为null,则认同最大accepted_epoch对应的取值f,使<epoch，f>成为确定性取值，其中epoch是自己的epoch.</epoch，f></p>
<ul>
<li>如果f出现半数以上，则说明f已经是确定性取值了，直接返回<ok,f></ok,f></li>
<li>否则，向epoch所对应的acceptor提交取值<epoch,f></epoch,f></li>
</ul>
<p> Acceptor在接收到accept(epoch,V)的请求之后，先查看epoch是不是自己记录的lastest_prepared_epoch，如果是则设置<accepted_epoch,accepted_value> = <prepared_epoch,v> 。否在则会返回error</prepared_epoch,v></accepted_epoch,accepted_value></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-paxos-paxos2.png" alt="paxos2"></p>
<p> 如上图所示，由于在阶段一中Proposer1接受到的<accepted_epoch>和<accepted_value>值都为null,所以，决定将自己的值设置为确定值，于是发送accept(1,V1)请求。Acceptor1接受到了这个请求，检查lastest_prepared_epoch也等于1,所以将自己存储的<accepted_epoch,accepted_value>设置为<1,v1>。而Proposer1的另外两个accept请求发生了网络延迟。<br> 如果此时，Proposer2向Acceptor进行propose会怎么样呢？我们来模拟propose来分析一下。</1,v1></accepted_epoch,accepted_value></accepted_value></accepted_epoch></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-paxos-paxos3.png" alt="paxos3"></p>
<p> 如上图所示，Proposer2向Acceptor发送了prepare(#2)的请求，Acceptor1先检测一下发现2大于现在的lastest_prepared_epoch,所以同意发送访问权，将lastest_prepared_epoch修改为2，并将自己保存的accepted_epoch和acceped_value返回给Proposer2；Acceptor3的操作也是类似，只不过因为Proposer1发送的accept请求发生了延迟，所以Acceptor3返回的是<null,null>；而Acceptor5的操作和我们在文章第一张图中的Acceptor1的操作相同，他们都是第一次接收到prepare请求。<br> 然后Proposer2进行第二阶段的操作，从所有的返回数据中，找到accepted_epoch最大的那个accepted_value.这里就是Acceptor返回的<1,v1>，所以，Proposer2会尽力让V1成为确定值，所以它向Acceptor发送accept(2,V1)的请求。然后Acceptor1,Acceptor3,Acceptor5三个Acceptor接受了这个accept请求，更新自己的<accepted_epoch,accepted_value>。此时，已经有三个acceptor形成了一致性的值，所以V1就成了整个系统的确定性取值。<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-paxos-paxos7.png" alt="paxos7.png"></accepted_epoch,accepted_value></1,v1></null,null></p>
<p> 那么Proposer1对Acceptor3发送的accept请求在此时达到Acceptor3会怎么样呢？Acceptor3发现当前lastest_prepared_epoch是2,所以直接拒绝了这个请求。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p> 不清楚大家现在对Paxos算法的过程是否已经有了清楚的了解啊？那么我来问几个问题，大家可以考虑一下：</p>
<ul>
<li>在本文的情景下，假如Proposer2向Acceptor2,3,4发送了prepare请求，而不是向Acceptor1,3,5发送的请求，会怎么样呢？</li>
<li>为什么强调prepare阶段时必须接受到一般以上Acceptor的返回，才能进行第二阶段?<br>&emsp;后续希望能够分析一下<code>Zookeeper</code>关于Paxos的具体使用场景和算法，希望大家多多关注。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/分布式/">分布式</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/04/16/分布式一致性算法Paxos/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/04/16/分布式一致性算法Paxos/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android/" title="Android">Android<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android性能/" title="Android性能">Android性能<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/NIO/" title="NIO">NIO<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/NetWork/" title="NetWork">NetWork<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/Network/" title="Network">Network<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Python/" title="Python">Python<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/c/" title="c">c<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/python/" title="python">python<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/函数式编程/" title="函数式编程">函数式编程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/分布式/" title="分布式">分布式<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/后端/" title="后端">后端<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/后端-Spring/" title="后端 - Spring">后端 - Spring<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/多线程/" title="多线程">多线程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/容器/" title="容器">容器<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/并发/" title="并发">并发<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/思考/" title="思考">思考<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/c/数据结构/" title="数据结构">数据结构<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/杂记/" title="杂记">杂记<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/杂记/" title="杂记">杂记<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/源码/" title="源码">源码<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/源码分析/" title="源码分析">源码分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/杂记/生活/" title="生活">生活<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/综合/" title="综合">综合<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/网络/" title="网络">网络<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/源码/视图/" title="视图">视图<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/计划/" title="计划">计划<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/设计/" title="设计">设计<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/读书笔记/" title="读书笔记">读书笔记<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/运维/" title="运维">运维<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/随笔/" title="随笔">随笔<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/JUC/" title="JUC">JUC<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Netty/" title="Netty">Netty<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/第三方库/" title="第三方库">第三方库<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/注解/" title="注解">注解<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Span/" title="Span">Span<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/scroll/" title="scroll">scroll<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/TCP-IP/" title="TCP/IP">TCP/IP<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/View/" title="View">View<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/事件传递/" title="事件传递">事件传递<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/OkHttp/" title="OkHttp">OkHttp<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Spring-Boot/" title="Spring Boot">Spring Boot<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Docker/" title="Docker">Docker<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Jenkins/" title="Jenkins">Jenkins<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GSON/" title="GSON">GSON<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/docker/" title="docker">docker<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/kubernetes/" title="kubernetes">kubernetes<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/反射/" title="反射">反射<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/JSON/" title="JSON">JSON<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Material-Design/" title="Material Design">Material Design<sup>1</sup></a></li>
			
		
		</ul>
</div>


  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> Hello ,I&#39;m Homer in NJU. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="remCarpediem">remCarpediem</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-88918565-1', 'ztelur.github.io/');
ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?8a8af29a4307eee9d7c7f8e9321aedae";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260989317'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1260989317' type='text/javascript'%3E%3C/script%3E"));</script>




<!-- baidu search 推送-->
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
