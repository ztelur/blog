### 如何实现熔断机制：Hystric的使用和原理





你好，我是aoho，今天我和你分享的主题是：如何实现熔断机制：Hystric 的使用和原理

在上一篇文章中，我们已经了解了熔断的基本原理和断路器在服务高可用架构中的重要性。相信小伙伴们已经迫不及待地准备在项目中使用断路器保护自己的服务了。自研断路器组件往往费时费力，秉承不能重复造轮子的理念，笔者这里推荐使用 Hystric。 



### Hystric 简介

Hytrix 是 Netflix 开源的一个优秀的服务间断路器，它能够在服务提供者故障时，隔离服务调用者和服务提供者，防止服务级联失败；同时提供失败回滚逻辑，使系统快速从异常中恢复。Hytrix完美地实现了断路器模式，同时还提供信号量和线程隔离的方式保护服务调用者的线程资源，它对延迟和失败提供强大的容错能力，为系统提供保护和控制。

典型的 Hystric 编程形式如下所示：

```go
err := hystrix.Do("test_command", func() error {
		// 远程调用&或者其他需要保护的方法
		return nil
	}, func(err error) error{
		// 失败回滚方法
		return nil
	})
```

被 hystrix 包装的远程调用逻辑都会封装为一个 hystrix 命令，其内包含制远程调用逻辑和失败回滚逻辑，根据 hystrix 命名唯一确认一个 hystrix 命令；

上述代码执行时会先根据 hystrix 命令的命名获取到对应的断路器，判断断路器是否打开。如果断路器打开，说明此时服务调用已经被熔断了，将直接执行失败回滚逻辑，不执行真正的远程调用逻辑；如果断路器关闭或者处于半开状态，则执行远程调用逻辑。

接下来我们将通过一个简单例子的了解 hytrix 的使用方式。详细代码见课程提供的代码库的 xxx 文件夹。

### Hystric 基础使用案例

我们以常见的货运系统为例，包裹页面需要展示下游快递系统的具体派送信息，但是实时准确的派送信息相对来说并不是不可或缺，紧急情况下可以不进行显示。下图展示了相关的服务交互图。

![cargo_and_delivery](http://cdn.remcarpediem.net/2020-05-29-120648.png)



包裹货运系统相对于下游的快递派送系统来说，级别更高，不应该受到快递派送系统的错误影响，导致上文所说的服务雪崩问题，所以二者之间的交互需要使用断路器进行熔断保护。

```go
func getDeliveryInfoResult(a, b int) (string, error) {

	serviceName := "Delivery"

	var result string

	err := hystrix.Do(serviceName+ "." + "calculate", func() error{
		// 从 consul 中获取 Delivery 服务服务实例列表
		instances := consulClient.DiscoverServices(serviceName)
		if instances == nil || len(instances) == 0 {
			return errors.New("No " + serviceName + " instances are working")
		}
		// 随机选取一个服务实例进行计算
		rand.Seed(time.Now().UnixNano())
		selectInstance := instances[rand.Intn(len(instances))].(*api.AgentService)

		requestUrl := url.URL{
			Scheme:"http",
			Host:selectInstance.Address + ":" + strconv.Itoa(selectInstance.Port),
			Path:"/query",
			RawQuery:"a=" + strconv.Itoa(a) + "&b=" + strconv.Itoa(b),
		}

		resp, err := http.Get(requestUrl.String())
		if err != nil{
			return err
		}
		body, _ := ioutil.ReadAll(resp.Body)
		result = string(body)

		return nil

	}, func(e error) error {
		// 断路器打开时的处理函数函数
		return errors.New("Http errors！")
	})

	if err == nil {
		return result, nil
	} else {
		return "", err
	}
}
```



我们启动 Cargo 服务和 Delivery 服务，能够在 Consul 页面上发现二者都已经注册上去了，接着我们访问 Cargo 的 /pacakge/query 接口，发起对 Delivery 的远程调用。访问地址如下：

```
http://localhost:10086/cargo/pacakge/query?a=2&b=3
```

可以获取到正确的响应如下：

```
Get result from Delivery is 5
```

接着我们关闭 Delivery 服务模仿下游服务出现错误的场景，继续访问上述地址，将会得到以下结果：

```
Get result from Delivery is fallback failed with 'Http errors！'. run error was 'No Delivery instances are working'
```

返回结果中直接把异常输出了，同时日志中也会输出 `No Delivery instances are working!`，说明 hystrix.Do 中包装代码被执行，但是找不到下游服务实例，无法发起调用，返回了错误码。

接着，我们多次访问上述地址，会发现被包装的代码会被一直执行，并没有触发断路器打开逻辑。这是为什么呢？

原来 hystrix 的默认配置是访问请求数在 20 次以上才会触发断路器计算的逻辑，我们可以在程序启动时修改断路器最低启动阀值为 4 次，来验证断路器打开后效果，在 cargo.go 的 main 函数中添加 hystrix 的配置信息，如下所示：

```
func main()  {
	// 设置断路器最低启动阀值为 4
	hystrix.ConfigureCommand("Calculate.calculate", hystrix.CommandConfig{
		RequestVolumeThreshold:4,
	})

	startService("UseCalculate", "", 10086, startUseCalculateHttpListener)

}
```

重新启动 Cargo 服务，连续访问接口失败 4 次之后，继续访问将不会持续出现`No Delivery instances are working!`的错误日志，说明此时断路器已经打开，直接执行了失败回滚函数返回异常结果。

如果 5 秒之后我们重新访问接口，将会发现请求重新执行了 hystrix.Do 中的远程调用代码，这是因为断路器打开之后的超时时间已经结束(默认为 5 秒钟)，断路器进入了半开状态，允许程序重新执行远程调用，试探下游服务是否恢复可用状态，因为 Delivery 服务处于一直不可用的状态，请求失败后，断路器又回到的打开状态。

### Hystric 简介和原理

看完 Hystric 使用的简单案例后，我们来了解一下 Hystric 断路器的相关原理，分析一下 Hystric.Do 的关键实现。

![](http://cdn.remcarpediem.net/2020-05-24-hystric.png)



从上述的流程图中，可以看到：

- 当Hystric.Do 函数被执行时，它会交由对应的 HystricCommand 处理。
- HystricCommand 会首先调用 allowRequest 函数判断当前是否在熔断状态中，如果不是则直接放行，执行包装定义的代码逻辑；如果是的话，还要看是否到达预定熔断时长，如果熔断时长到了，也是放行，否则直接返执行错误逻辑。
- HystricCommand 执行结束前都会调用 markSuccess(duration) 或 markFailure(duration) 函数统计一下在一定的 duration (时间间隔) 内有多少调用是成功还是失败的。
- isOpen 函数判断是否熔断的规则，是计算一下周期中 failure/(success+failure) 的错误率，如果高于一个阈值，那么打开熔断，否则关闭。
- Hystrix 会在内存中为每个 HystricCommand 维护一个数组，其中记录着每一个周期的请求结果的统计。超过时间窗口的元素会被删除掉。



### 总结

在本篇文章中，我为你讲述了 Hystric 的使用和原理，Hystric 作为开源的熔断组件，为我们提供了开箱既用的服务自我保护能力。 

那么除了熔断外，还有哪些方式来保护服务，提供高可用的服务呢？请继续关注本课程，下一讲我们继续介绍。