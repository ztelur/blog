<!DOCTYPE html>
<html lang="Ch">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>程序员历小冰</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta property="og:type" content="website">
<meta property="og:title" content="程序员历小冰">
<meta property="og:url" content="http://remcarpediem.net/page/5/index.html">
<meta property="og:site_name" content="程序员历小冰">
<meta property="og:locale" content="Chinese">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员历小冰">
    

    
        <link rel="alternate" href="/atom.xml" title="程序员历小冰" type="application/atom+xml">
    

    
        <link rel="icon" href="/css/images/avatar.jpeg">
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
    
    
    
        
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f089a91a688633df563c08899e3d893e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    


<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">程序员历小冰</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">主页</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/book">读书</a>
                
                    <a class="main-nav-link" href="/categories/plan">计划</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.jpeg">
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">主页</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/book">读书</a></td>
                
                    <td><a class="main-nav-link" href="/categories/plan">计划</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile" class="profile-fixed">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.jpeg">
            <h2 id="name">历小冰</h2>
            <h3 id="title">后端开发工程师</h3>
            <span id="location"><i class="fa fa-map-marker"></i>中国，南京</span>
            <img id="wechat" src="/css/images/wechat_public.jpg">
            <a id="follow" target="_blank" href="/css/images/wechat_public.jpg">⬆关注公众号⬆</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                93
                <span>posts</span>
            </div>
            <div class="article-info-block">
                63
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/ztelur" target="_blank" title="github" class="tooltip">
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/css/images/wechat.jpeg" target="_blank" title="wechat" class="tooltip">
                            <i class="fa fa-wechat"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/atom.xml" target="_blank" title="rss" class="tooltip">
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-Docker系列之Jenkins自动化部署" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/b4f6f76f/">Docker系列之Jenkins自动化部署</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/b4f6f76f/">
            <time datetime="2017-07-02T13:23:35.000Z" itemprop="datePublished">2017-07-02</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/docker/">docker</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Docker/">Docker</a>, <a class="tag-link" href="/tags/Jenkins/">Jenkins</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> Devops的概念已经火了很久了，我一直想对这方面进行一定的了解；再加上实验室项目环境依赖比较复杂，希望使用Docker来解决，所以最近就好好研究了一波Docker的相关实践和原理。这里整理一下，希望组成一个系列，从实践到原理详细讲解一下Docker的使用。<br> 第一篇就讲一下Jenkins+Docker的自动化部署实践。大致的流程如下：目前我有两个服务器，分别是阿里云和bandwagon,代码存储在github上，每次push都会触发阿里云上的jenkins的构建任务，jenkins将github上的代码fetch到本地，编译打包成war文件，生成docker image并上传到docker registry上，然后通过ssh来登录bandwagon服务器pull下来新生成的image并启动。由于篇幅问题，本篇文章不会介绍有关docker image的build和docker registry的搭建，但是我会在后续文章中再做详细讲解。<br> 学习Docker，我推荐先在网络上找说明指南，一步一步自己尝试的使用，然后如果觉得有必要可以看一下《Docker容器和容器云》这本书。<br> 本文内容都是docker和jenkins的基础知识，为了节约你的时间，本文的主要内容如下：</p>
<ul>
<li>docker 基础命令</li>
<li>jenkins docker版本的搭建，构建任务的配置</li>
<li>Pubish Over SSH 安装和配置</li>
<li>通过github的webhook来触发jenkins构建任务</li>
</ul>
<h4 id="Docker运行jenkins"><a href="#Docker运行jenkins" class="headerlink" title="Docker运行jenkins"></a>Docker运行jenkins</h4><p> Docker如此火爆的一个原因是因为它形成了一个良好的生态圈，基本上主流的软件应用都有相应的Docker image。如果大家不清楚Docker image的含义，建议大家看一下<a href="https://www.gitbook.com/book/richardhc/chinese_docker/details" target="_blank" rel="noopener">Docker中文指南</a>，我们可以通过<code>docker pull</code>命令来下载响应的image,然后运行。比如我们希望在阿里云服务器上部署一个jenkins应用，首先可以执行下列语句来获取一个jenkins的image。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">docker pull jenkinsci&#x2F;jenkins:lts
</code></pre></p>
<p> 这里我们使用pull从docker registry上拉取image,但是目前业界上有很多共有或在私有的docker registry,比如说docker hub和daoCloud。所以image的全称就由三部分组成:域名或在ip + / + 软件名称 + : + 版本号，所以上边的这条命令就是让docker去jenkinsci这个Jenkins机构自己部署的registry上下载jenkins的lts版本的image.你也可以直接使用<code>docker pull jenkins</code>来下载image,但docker会默认的从docker hub上下载jenkins的laster版本。</p>
<p> 下载成功之后，你可以使用<code>docker images</code>命令来查看当前下载的image信息</p>
<p> 你可以通过<code>docker run</code>命令来运行docker容器，请注意我这里的用词，在Docker中image和container是不同的概念，你可以将他们简单的理解成Java中类和对象的关系。我们使用下面的命令来启动这个jenkins容器。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">sudo docker run -d --name jenkins -p 9090:8080 -v &#x2F;var&#x2F;jenkins_home:&#x2F;var&#x2F;jenkins_home jenkinsci&#x2F;jenkins:lts
</code></pre></p>
<p> 我们来依次讲解一下run命令的几个参数把：</p>
<ul>
<li><p><code>-d</code> 后台运行docker容器并打印容器ID。如果不加<code>-d</code>参数，那么容器运行会和终端绑定，如果终端关闭，那么容器也会关闭，但是容器不会被删除。但是如果你只是想试一试某个容器，运行后自动进入命令行，那么可以使用-it参数;如果你想容器关闭之后自动删除，那么就使用-rm参数。</p>
</li>
<li><p><code>--name</code> 给docker container起一个别名，后续可以通过别名来管理容器，否在会系统会默认分配一个随机的别名。</p>
</li>
<li><p><code>-p</code> docker容器和外侧的端口映射，jenkins服务是运行在docker容器内部的，但是docker容器默认不对外暴露接口，所以通过这个参数将内部的8080端口映射到服务器本身的9090端口上。</p>
</li>
<li><p><code>-v</code> 数据卷的挂载。这里涉及到docker container的一个特性，container如果停止运行了，那么再次启动时，之前所有运行相关的数据和文件就都不存在了，就类似于设置了自动还原的电脑一般，无论你做了多少的操作，一旦关机重启之后就又恢复到最初的状态。数据卷就是来解决上述问题的，通过Docker container外部的文件夹的挂载，将可持久化的文件存储到外部挂载的文件夹中。</p>
</li>
</ul>
<p> 然后你就可以根据你自己的ip地址来键入下列地址http:ip:9090来访问jenkins的主页了。<br>&emsp;这里有一点需要注意的是，需要注意你阿里云服务器设置的网络安全协议，是否禁用掉了9090这个端口。</p>
<h4 id="Publish-over-SSH配置"><a href="#Publish-over-SSH配置" class="headerlink" title="Publish over SSH配置"></a>Publish over SSH配置</h4><p>&emsp;Jenkins的初始化配置和SSH Over Publish的安装请大家自行百度，这里我主要讲解一下SSH Over Pushlish配置。<br>&emsp;首先我们要在jenkins服务器上生成密钥对，使用<code>ssh-keygen -t rsa</code>命令来生成秘密对，这样的话，在~/.ssh/下就会有私钥id_rsa和公钥id_rsa.pub。<br>&emsp;然后你需要上传公钥到目标服务器上，也就是我的bandwagon服务器上，可以使用<code>ssh-copy-id</code>来将文件上传到服务器上，类似于<code>scp</code>命令的使用方式。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub &lt;username&gt;@&lt;host&gt;
</code></pre></p>
<p>&emsp;最后我们需要修改目标服务器的ssh配置文件，配置文件为/etc/ssh/sshd_config。设置ssh-server允许使用私钥和公钥对的方式登录，然后使用<code>sudo /etc/init.d/ssh restart</code>命令重启ssh服务。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">RSAAuthentication yes
PubkeyAuthentication yes
#AuthorizedKeysFile     %h&#x2F;.ssh&#x2F;authorized_keys
</code></pre></p>
<p>&emsp;上述步骤成功之后，大家在系统管理中配置Publish over SSH。相关的配置信息如下图所示。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins1.png" alt="jenkins1.png"></p>
<p>&emsp;你还可以点击下方的高级选项，来配置ssh服务器的端口，超时时间等信息，还可以点击Test Configuration来检测是否配置成功。</p>
<h4 id="构建任务配置"><a href="#构建任务配置" class="headerlink" title="构建任务配置"></a>构建任务配置</h4><p>&emsp;我们先创建一个构建任务，该任务从github repo上将代码拉取下来，然后执行构建任务，然后通过Publish Over SSH在目标服务器上进行部署。<br>&emsp;我们首先配置源码管理模块，选择Git选项，然后配置Repository URL 并添加认证信息。可以将自己的github帐号和密码加入其中。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins2.png" alt="jenkins2.png"></p>
<p>&emsp;不同的项目的构建命令不同，但是我们可以在构建后操作模块设置后续操作，通过ssh登录目标服务器，让目标服务器执行命令行操作来pull最新上传的image并且执行，这样就完成了部署。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins3.png" alt="jenkins3.png"></p>
<h4 id="Push触发构建任务"><a href="#Push触发构建任务" class="headerlink" title="Push触发构建任务"></a>Push触发构建任务</h4><p>&emsp;完成上述配置，你就可以手动在jenkins上启动构架任务了，但是要做到自动化部署，还必须设置Push操作自动触发jenkins构建任务的机制。<br>&emsp;我们先到首页-用户管理界面打开自己的用户界面，然后点击左侧的设置按钮，并点击<code>show API token</code>按钮来获取API token.然后在构建任务设置页面的构建触发器模块勾选触发远程构建选项，并将token填到里边去。这是jenkins会提示你如何通过URL来触发构建任务。<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins5.png" alt="jenkins5.png"></p>
<p>&emsp;然后我们打开github上相应库的设置页面。点击左侧的Webhooks选项，然后添加hook.将上述的url填写到Payload URL栏中，点击添加。如果添加成功之后，每次你push一个新版本，那么jenkins就会自动进行部署了。<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins6.png" alt="jenkins6.png"></p>
<p>&emsp;如果你发现webhooks发送请求失败，那可能是因为你jenkins安全设置的问题，禁止掉了发送请求自动化构建。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;本篇讲的都是十分基础性的内容，后一篇文章讲一下dockerfile的原理和注意事项与docker registry。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/b4f6f76f/" data-id="ckaubqb2q001hgr668pls75fw" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-《多处理器编程艺术》－链表：锁的作用" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/56d732a0/">《多处理器编程艺术》－链表：锁的作用</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/56d732a0/">
            <time datetime="2017-06-19T13:57:31.000Z" itemprop="datePublished">2017-06-19</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/并发/">并发</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/锁/">锁</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 最近在阅读《多处理器编程艺术》一书，掌握了很多Java多线程的底层知识，现在就做一下书中链表-锁的作用一章的总结。<br>&emsp;为了节约你的时间，本文主要内容如下：</p>
<ul>
<li>带锁的链表队列</li>
<li>细粒度同步</li>
<li>乐观同步</li>
<li>惰性同步</li>
<li>非阻塞同步</li>
</ul>
<h3 id="粗粒度同步"><a href="#粗粒度同步" class="headerlink" title="粗粒度同步"></a>粗粒度同步</h3><p>&emsp;所谓粗粒度同步其实很简单，就是在List的<code>add</code>,<code>remove</code>,<code>contains</code>函数的开始就直接使用Lock加锁，然后在函数结尾释放。<br>&emsp;<code>add</code>函数的代码如下所示，函数的主体就是链表的遍历添加逻辑，只不过在开始和结束进行了锁的获取和释放。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">private Node head;
private Lock lock = new ReentrantLock();
public boolean add(T item) {
    Node pred, curr;
    int key = item.hashCode();
    lock.lock();
    try {
        pred = head;
        curr = pred.next;
        while(curr.key &lt; key) {
            pred = curr;
            curr = pred.next;
        }
        if (key == curr.key) {
            return false;
        } else {
            Node node = new Node(item);
            node.next = curr;
            pred.next = node;
            return true;
        }

    } finally {
        lock.unlock();
    }
}
</code></pre></p>
<p>&emsp;大家看到这里就会想到，这不就是类似于<code>Hashtable</code>的实现方式吗？把可能出现多线程问题的函数都用一个重入锁锁住。但是这个方法的缺点很明显，如果竞争激烈的话，对链表的操作效率会很低，因为<code>add</code>,<code>remove</code>,<code>contains</code>三个函数都需要获取锁，也都需要等待锁的释放。至于如何优化，我们可以一步一步往下看</p>
<h3 id="细粒度同步"><a href="#细粒度同步" class="headerlink" title="细粒度同步"></a>细粒度同步</h3><p>&emsp;<strong><em>我们可以通过锁定单个节点而不是整个链表来提高并发</em></strong>。给每个节点增加一个Lock变量以及相关的lock()和unlock()函数,当线程遍历链表的时候，若它是第一个访问节点的线程，则锁住被访问的节点，在随后的某个时刻释放锁。这种细粒度的锁机制允许并发线程以流水线的方式遍历链表。<br>&emsp;使用这种方式来遍历链表，必须同时获取两个相邻节点的锁，通过“交叉手”的方式来获取锁：除了初始的head哨兵节点外，只有在已经获取pred的锁时，才能获取curr的锁。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;每个Node对象中都有一个Lock对象，可以进行lock()和unlock()操作
public boolean add(T item) {
    int key = item.hashCode();
    head.lock();
    Node pred = head;
    try {
        Node curr = pred.next;
        curr.lock();

        try {
            while (curr.key &lt; key) {
                pred.unlock();
                pred = curr;
                curr = pred.next;
                curr.lock();
            }

            if (curr.key == key) {
                return false;
            }
            Node newNode = new Node(item);
            newNode.next = curr;
            pred.next = newNode;
            return true;
        } finally {
            curr.unlock();
        }

    } finally {
        pred.unlock();
    }
}
</code></pre>
<h3 id="乐观同步"><a href="#乐观同步" class="headerlink" title="乐观同步"></a>乐观同步</h3><p>&emsp;虽然细粒度锁是对单一粒度锁的一种改进，但它仍然出现很长的获取锁和释放锁的序列。而且，访问链表中不同部分的线程仍然可能相互阻塞。例如，一个正在删除链表中第二个元素的线程将会阻塞所有试图查找后继节点的线程。<br>&emsp;减少同步代价的一种方式就是乐观：<strong><em>不需要获取锁就可以查找，对找到的节点进行加锁，然后确认锁住的节点是正确的；如果一个同步冲突导致节点被错误的锁定，则释放这些锁重新开始</em></strong>。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public boolean add(T item) {
    int key = item.hashCode();

    while (true) { &#x2F;&#x2F;如果不成功，就进行重试
        Node pred = head;
        Node curr = pred.next;
        while (curr.key &lt; key) {
            pred = curr;
            curr = pred.next;
        }
        &#x2F;&#x2F;找到目标相关的pred和curr之后再将二者锁住
        pred.lock();
        curr.lock();
        try {
            &#x2F;&#x2F;锁住二者之后再进行判断，是否存在并发冲突
            if (validate(pred, curr)) {
                &#x2F;&#x2F;如果不存在，那么就直接进行正常操作
                if (curr.key == key) {
                    return false;
                } else {
                    Node node = new Node(item);
                    node.next = curr;
                    pred.next = node;
                }
            }
        } finally {
            pred.unlock();
            curr.unlock();
        }
    }
}
public boolean validate(Node pred, Node curr) {
    &#x2F;&#x2F;从队列头开始查找pred和curr,判断是否存在并发冲突
    Node node = head;
    while (node.key &lt;= pred.key) {
        if (node == pred) {
            return pred.next == curr;
        }
        node = node.next;
    }
    return false;
}
</code></pre></p>
<p>&emsp;由于不再使用能保护并发修改的锁，所以每个方法调用都可能遍历那些已经被删除的节点，所以在进行添加，删除获取判断是否存在的之前必须再次进行验证。</p>
<h3 id="惰性同步"><a href="#惰性同步" class="headerlink" title="惰性同步"></a>惰性同步</h3><p>&emsp;当不用锁遍历两次链表的代价比使用锁遍历一次链表的代价小很多时，乐观同步的实现效果非常好。但是这种算法的缺点之一就是contains()方法在遍历时需要锁，这一点并不令人满意，其原因在于对contains()的调用要比其他方法的调用频繁得多。<br>&emsp;<strong><em>使用惰性同步的方法，使得contains()调用是无等待的，同时add()和remove()方法即使在被阻塞的情况下也只需要遍历一次链表</em></strong>。<br>&emsp;<strong><em>对每个节点增加一个布尔类型的marked域，用于说明该节点是否在节点集合中。现在，遍历不再需要锁定目标结点，也没有必须通过重新遍历整个链表来验证结点是否可达。所有未被标记的节点必然是可达的</em></strong>。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;add方法和乐观同步的方法一致，只有检验方法做了修改。
&#x2F;&#x2F;只需要检测节点的marked变量就可以，并且查看pred的next是否还是指向curr，需要注意的是marked变量一定是voliate的。
private boolean validate(Node pred, Node curr) {
        return !pred.marked &amp;&amp; !curr.marked &amp;&amp; pred.next == curr;
}
</code></pre>
<p>&emsp;惰性同步的优点之一就是能够将类似于设置一个flag这样的逻辑操作与类似于删除结点的链接这种对结构的物理改变分开。通常情况下，延迟操作可以是批量处理方式进行，且在某个方便的时候再懒惰地进行处理，从而降低了对结构进行物理修改的整体破裂性。惰性同步的主要缺点是add()和remove()调用是阻塞的：如果一个线程延迟，那么其他线程也将延迟。</p>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>&emsp;使用惰性同步的思维是非常有益处的。我们可以进一步将add(),remove()和contains()这三个方法都变成非阻塞的。前两个方法是无锁的，最后一个方法是无等待的。我们无法直接使用compareAndSet()来改变next域来实现，因为这样会出现问题。但是我们可以将结点的next域和marked域看作是单个的原子单位：当marked域为true时，对next域的任何修改都将失败。<br>&emsp;我们可以使用AtomicMarkableReference<t>对象将指向类型T的对象引用next和布尔值marked封装在一起。这些域可以一起或单个地原子更新。可以让每个结点的next域为一个AtomicMarkableReference<node>。线程可以通过设置结点next域中的标记位来逻辑地删除curr,和其他正在执行add()和remove()的线程共享物理删除:当每个线程遍历链表时，通过物理删除所有被标记的节点来清理链表。</node></t></p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">
    public Window find(Node head, int key) {
        Node pred = null, curr = null, succ = null;
        boolean[] marked = {false};
        boolean snip;

        retry: while(true) {
            pred = head;
            curr = curr.next.get(marked);
            while(true) {
                succ = curr.next.get(marked); &#x2F;&#x2F;获取succ,并且查看是被被标记
                while (marked[0]) {&#x2F;&#x2F;如果被标记了，说明curr被逻辑删除了，需要继续物理删除
                    snip = pred.next.compareAndSet(curr, succ, false, false);&#x2F;&#x2F;
                    if (!snip) continue retry;
                    curr = succ;
                    succ = curr.next.get(marked);
                }
                &#x2F;&#x2F;当不需要删除后，才继续遍历
                if (curr.key &gt;= key) {
                    return new Window(pred, curr);
                }
                pred = curr;
                curr = succ;
            }
        }
    }

    public boolean add(T item) {
        int key = item.hashCode();
        while(true) {
            Window window = find(head, key);
            Node pred = window.pred, curr = window.curr;
            if (curr.key == key) {
                return false;
            } else {
                Node node = new Node(item);
                node.next = new AtomicMarkableReference&lt;&gt;(curr, false);
                if (pred.next.compareAndSet(curr, node, false, false)) {
                    return true;
                }
            }
        }
    }

    public boolean remove(T item) {
        int key = item.hashCode();
        boolean sinp;
        while(true) {
            Window window = find(head, key);
            Node pred = window.pred, curr = window.curr;
            if (curr.key != key) {
                return false;
            } else {
                Node succ = curr.next.getReference();
                &#x2F;&#x2F;要进行删除了，那么就直接将curr.next设置为false,然后在进行真正的物理删除。
                sinp = curr.next.compareAndSet(curr, succ, false, true);
                if (!sinp) {
                    continue;
                }
                pred.next.compareAndSet(curr, succ, false, false);
                return true;
            }
        }
    }


class Node {
          AtomicMarkableReference&lt;Node&gt; next;
}
</code></pre>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;文中的代码在我的github的这个<a href="https://github.com/ztelur/MultiprocessorProgramming/tree/master/src/com/company/nine" target="_blank" rel="noopener">repo</a>中都可以找到。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/56d732a0/" data-id="ckaubqb4e005hgr66vn21tudn" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-2017年，计划目录" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/904b40bc/">2017年，计划目录</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/904b40bc/">
            <time datetime="2017-05-03T06:40:16.000Z" itemprop="datePublished">2017-05-03</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/plan/">plan</a>
    </div>

                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;和<a href="http://ztelur.github.io/2017/05/03/2017%E5%B9%B4%EF%BC%8C%E8%AE%A1%E5%88%92%E7%9B%AE%E5%BD%95/" target="_blank" rel="noopener">16年计划</a>一样，建立一个计划目录，记录一下17年的计划和实现情况,进行不定时的更新。</p>
<h2 id="计划清单"><a href="#计划清单" class="headerlink" title="计划清单"></a>计划清单</h2><h3 id="英语学习"><a href="#英语学习" class="headerlink" title="英语学习"></a>英语学习</h3><h4 id="单词量"><a href="#单词量" class="headerlink" title="单词量"></a>单词量</h4><ul>
<li>口语小助手 <strong>2017.1.30~</strong></li>
</ul>
<h4 id="口语"><a href="#口语" class="headerlink" title="口语"></a>口语</h4><ul>
<li>每天一集《摩登家庭》的听力口语练习 <strong>2017.1.30~</strong></li>
</ul>
<h3 id="Android开发"><a href="#Android开发" class="headerlink" title="Android开发"></a>Android开发</h3><h4 id="Android性能方面研究"><a href="#Android性能方面研究" class="headerlink" title="Android性能方面研究"></a>Android性能方面研究</h4><h5 id="GT开源项目研究"><a href="#GT开源项目研究" class="headerlink" title="GT开源项目研究"></a>GT开源项目研究</h5><h4 id="博客文章"><a href="#博客文章" class="headerlink" title="博客文章"></a>博客文章</h4><h5 id="Android富文本"><a href="#Android富文本" class="headerlink" title="Android富文本"></a>Android富文本</h5><h5 id="Android-Trasication动画"><a href="#Android-Trasication动画" class="headerlink" title="Android Trasication动画"></a>Android Trasication动画</h5><h3 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h3><h3 id="要阅读的书籍"><a href="#要阅读的书籍" class="headerlink" title="要阅读的书籍"></a>要阅读的书籍</h3><ul>
<li>《暗时间》<strong>2017.1.30~</strong><h3 id="习惯养成"><a href="#习惯养成" class="headerlink" title="习惯养成"></a>习惯养成</h3></li>
</ul>
<h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><ul>
<li>关灯之后不准再玩手机</li>
<li>11点半左右睡觉</li>
</ul>
<h4 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h4><ul>
<li>每日的思考，总结和回顾</li>
</ul>
<h2 id="Update-2017-1-1"><a href="#Update-2017-1-1" class="headerlink" title="Update 2017.1.1"></a>Update 2017.1.1</h2><p>&emsp;开始制定计划，一个星期时间。</p>
<h2 id="Update-2017-1-30"><a href="#Update-2017-1-30" class="headerlink" title="Update 2017.1.30"></a>Update 2017.1.30</h2><p>&emsp;制订2月计划</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul>
<li>两篇博文：Android富文本和Android Trasication动画</li>
<li>Gt开源项目研究</li>
</ul>
<h3 id="《暗时间》研读"><a href="#《暗时间》研读" class="headerlink" title="《暗时间》研读"></a>《暗时间》研读</h3><h3 id="英语口语练习"><a href="#英语口语练习" class="headerlink" title="英语口语练习"></a>英语口语练习</h3><h3 id="思维的习惯，总结，回顾，自醒！！！！！"><a href="#思维的习惯，总结，回顾，自醒！！！！！" class="headerlink" title="思维的习惯，总结，回顾，自醒！！！！！"></a>思维的习惯，总结，回顾，自醒！！！！！</h3><h2 id="Update-2017-4-6"><a href="#Update-2017-4-6" class="headerlink" title="Update 2017.4.6"></a>Update 2017.4.6</h2><h3 id="书籍-正在进行-预计时间3个月"><a href="#书籍-正在进行-预计时间3个月" class="headerlink" title="书籍 正在进行,预计时间3个月"></a>书籍 <strong>正在进行,预计时间3个月</strong></h3><ul>
<li>多核编程的艺术</li>
<li>高效能Mysql</li>
</ul>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h4 id="RPC简单框架"><a href="#RPC简单框架" class="headerlink" title="RPC简单框架"></a>RPC简单框架</h4><h4 id="Netty源码分析"><a href="#Netty源码分析" class="headerlink" title="Netty源码分析"></a>Netty源码分析</h4><h3 id="Java并发知识"><a href="#Java并发知识" class="headerlink" title="Java并发知识"></a>Java并发知识</h3><h4 id="JUC源码分析"><a href="#JUC源码分析" class="headerlink" title="JUC源码分析"></a>JUC源码分析</h4><h4 id="无锁算法"><a href="#无锁算法" class="headerlink" title="无锁算法"></a>无锁算法</h4><h2 id="Update-2017-5-3"><a href="#Update-2017-5-3" class="headerlink" title="Update 2017.5.3"></a>Update 2017.5.3</h2><h3 id="书籍-正在进行-预计时间3个月-1"><a href="#书籍-正在进行-预计时间3个月-1" class="headerlink" title="书籍 正在进行,预计时间3个月"></a>书籍 <strong>正在进行,预计时间3个月</strong></h3><ul>
<li>多核编程的艺术 读完第一章</li>
<li>高效能Mysql </li>
</ul>
<h3 id="mit-分布式课程-预计２个月"><a href="#mit-分布式课程-预计２个月" class="headerlink" title="mit 分布式课程 预计２个月"></a>mit 分布式课程 <strong>预计２个月</strong></h3><p>主页：<a href="http://nil.csail.mit.edu/6.824/2015/index.html" target="_blank" rel="noopener">http://nil.csail.mit.edu/6.824/2015/index.html</a><br>github:<a href="https://github.com/ztelur/mit-distributed-systems" target="_blank" rel="noopener">https://github.com/ztelur/mit-distributed-systems</a><br>经典课程啊，使用go语言，坚持自己把lab都做完</p>
<h3 id="中间件-1"><a href="#中间件-1" class="headerlink" title="中间件"></a>中间件</h3><h4 id="RPC简单框架-1"><a href="#RPC简单框架-1" class="headerlink" title="RPC简单框架"></a>RPC简单框架</h4><ul>
<li><a href="http://remcarpediem.com/2017/04/16/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Paxos/" target="_blank" rel="noopener">分布式一致性算法Paxos</a><h4 id="Netty源码分析-1"><a href="#Netty源码分析-1" class="headerlink" title="Netty源码分析"></a>Netty源码分析</h4></li>
<li><p><a href="http://remcarpediem.com/2017/04/02/Netty%E6%BA%90%E7%A0%81-%E4%B8%89-I-O%E6%A8%A1%E5%9E%8B%E5%92%8CJava-NIO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">Netty源码(三):I/O模型和Java NIO底层原理</a></p>
</li>
<li><p><a href="http://remcarpediem.com/2017/03/27/Netty%E6%BA%90%E7%A0%81-%E4%BA%8C-Netty%E7%9A%84Channel%E5%92%8CPipeline/" target="_blank" rel="noopener">Netty源码(二):Netty的Channel和Pipeline</a></p>
</li>
<li><a href="http://remcarpediem.com/2017/03/22/Netty%E6%BA%90%E7%A0%81-%E4%B8%80-Netty%E4%B8%AD%E7%9A%84Buffer/" target="_blank" rel="noopener">Netty源码(一):Netty中的Buffer</a></li>
<li>Netty的网络模型　还未进行<h3 id="Java并发知识-1"><a href="#Java并发知识-1" class="headerlink" title="Java并发知识"></a>Java并发知识</h3><h4 id="JUC源码分析-1"><a href="#JUC源码分析-1" class="headerlink" title="JUC源码分析"></a>JUC源码分析</h4></li>
<li><a href="http://remcarpediem.com/2017/04/06/AbstractQueuedSynchronizer%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">AbstractQueuedSynchronizer超详细原理解析</a></li>
<li><a href="http://remcarpediem.com/2017/04/21/LongAdder%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">LongAdder解析</a></li>
<li><a href="http://remcarpediem.com/2017/05/03/BlockingQueue%E4%B8%8ECondition%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">BlockingQueue与Condition原理解析</a><h4 id="无锁算法-1"><a href="#无锁算法-1" class="headerlink" title="无锁算法"></a>无锁算法</h4></li>
<li>ConcurrentHashMap　待写博客</li>
</ul>
<h2 id="Update-2017-10-7"><a href="#Update-2017-10-7" class="headerlink" title="Update 2017.10.7"></a>Update 2017.10.7</h2><p>&emsp;已经很久没有指定过计划了，前段时间因为家里和校招的原因，牵扯了很多精力，而且个人也逐渐变得放松起来，确实，工作已经确定，是可以放松一下了。所以我决定之后的目标集中在个人习惯方面，并且增加对经济和金融的学习，为以后个人财务管理和投资做准备。</p>
<h3 id="Java后台编程"><a href="#Java后台编程" class="headerlink" title="Java后台编程"></a>Java后台编程</h3><p>&emsp;Spring Cloud Stream的源码已经研究很久了，但是由于之前对Spring的不熟悉，一直没有结果，希望尽快把文章写出来，并且可以发到一些比较有影响的平台上去，另外Stream和Rocket的结合也希望作为我个人的项目来尽快完成</p>
<ul>
<li>Spring Cloud Stream 源码分析</li>
<li>Spring Cloud Stream Rocket binder的编写</li>
</ul>
<h3 id="编程习惯"><a href="#编程习惯" class="headerlink" title="编程习惯"></a>编程习惯</h3><p>&emsp;我一直认为我不算一个优秀的程序员，一是很多编程习惯不是很好，二是确实实际代码行数也不够，所以我最近一段时间从下面这些方面来提升</p>
<ul>
<li>自动化与快捷键 shell编程的利用，编程IDE的快捷键，虽然这些都是最简单的，但是我希望从这里开始入手吧</li>
<li>编程风格：统一一致，代码大全学过很多，但是自己写代码有是另外一种情况，还得从新来过</li>
</ul>
<h3 id="工作生活习惯"><a href="#工作生活习惯" class="headerlink" title="工作生活习惯"></a>工作生活习惯</h3><p>&emsp;最近由于比较懈怠，平常学习过程中都比较随意，经常边写代码边看游戏视频，学习股票知识也都是看看就好，我希望之后的一个月内能够养成下列的习惯吧。</p>
<ul>
<li>一心一用：学习时就别看视频，也别学个10分钟就玩一下手机了。番茄工作法吧。</li>
<li>看书，看学习视频要认真，笔记，复习</li>
<li>每日计划和回顾</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/904b40bc/" data-id="ckaubqb1o0005gr66uyluq0v1" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-BlockingQueue与Condition原理解析" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/815f6f66/">BlockingQueue与Condition原理解析</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/815f6f66/">
            <time datetime="2017-05-03T02:07:45.000Z" itemprop="datePublished">2017-05-03</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/并发/">并发</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JUC/">JUC</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 我在前段时间写了一篇关于AQS的<a href="http://remcarpediem.com/2017/04/06/AbstractQueuedSynchronizer%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">文章</a>，在文章里边我说几乎所有在<code>JUC</code>包中的所有多线程相关的类都和<code>AQS</code>相关，今天我就在这里总结一下另一个依赖于<code>AQS</code>来实现的同步工具类：<code>BlockingQueue</code>。我们主要以<code>ArrayBlockingQueue</code>为主来分析相关的源码。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p> 相信大多数同学都是在学习线程池相关知识时了解到阻塞队列的概念的。知道各种类型的阻塞队列对线程池初始化时的影响。在java doc中这样定义阻塞队列。当从阻塞队列获取元素但是队列为空时，当前线程会阻塞直到另一个线程向阻塞队列中添加一个元素；类似的，当向一个阻塞队列加入元素时，如果队列已经满了，当前线程也会阻塞知道另外一个线程从队列中读取一个元素。阻塞队列一般都是FIFO,用来实现生产者和消费者模式。阻塞队列的方法通过四种不同的方式来处理操作无法被立即完成的情况，这四种情况分别为抛出异常，返回特殊值(null或在是false),阻塞当前线程直到执行结束，最后一种是只阻塞固定时间，然后还未执行成功就放弃操作。这些方法都总结在下边这种表中了。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-condition-BlockingQueue.png" alt="BlockingQueue"></p>
<p> 我们就只分析<code>put</code>和<code>take</code>方法。</p>
<h3 id="put和take函数"><a href="#put和take函数" class="headerlink" title="put和take函数"></a>put和take函数</h3><p> 我们都知道，使用同步队列可以很轻松的实现生产者-消费者模式，其实，同步队列就是按照生产者-消费者的模式来实现的，我们可以将<code>put</code>函数看作生产者的操作，<code>take</code>是消费者的操作。<br> <code>put</code>函数会在队列末尾添加元素，如果队列已经满了，无法添加元素的话，就一直阻塞等待到可以加入为止。函数的源码如下所示。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">    public void put(E e) throws InterruptedException {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly(); &#x2F;&#x2F;先获得锁
        try {
            while (count == items.length) 
            &#x2F;&#x2F;如果队列满了，就NotFull这个condition对象上进行等待
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
    private void enqueue(E x) {
        final Object[] items = this.items;
        items[putIndex] = x;
        &#x2F;&#x2F;这里可以注意的是ArrayBlockingList实际上使用Array实现了一个环形数组，
       &#x2F;&#x2F;当putIndex达到最大时，就返回到起点，继续插入,
       &#x2F;&#x2F;当然，如果此时0位置的元素还没有被取走，
       &#x2F;&#x2F;下次put时，就会因为cout == item.length未被阻塞。
        if (++putIndex == items.length)
            putIndex = 0;
        count++;
        &#x2F;&#x2F;因为插入了元素，通知等待notEmpty事件的线程。
        notEmpty.signal();
    }
</code></pre></p>
<p> 我们会发现put函数也是使用了wait/notify的机制。与一般生产者-消费者的实现方式不同，同步队列使用<code>ReentrantLock</code>和<code>Condition</code>相结合的先获得锁，再等待的机制；而不是<code>synchronized</code>和<code>Object.wait</code>的机制。这里的区别我们下一节再详细讲解。<br> 看完了生产者相关的<code>put</code>函数，我们再来看一下消费者调用的<code>take</code>函数。<code>take</code>函数在队列为空时会被阻塞，一直到阻塞队列加入了新的元素。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">    public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0)
            &#x2F;&#x2F;如果队列为空，那么在notEmpty对象上等待，
            &#x2F;&#x2F;当put函数调用时，会调用notEmpty的notify进行通知。
                notEmpty.await();
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
    private E dequeue() {
        E x = (E) items[takeIndex];
        items[takeIndex] = null; &#x2F;&#x2F;取出takeIndex位置的元素
        if (++takeIndex == items.length)
            &#x2F;&#x2F;如果到了尾部，将指针重新调整到头部
            takeIndex = 0;
        count--;
        ....
        &#x2F;&#x2F;通知notFull对象上等待的线程
        notFull.signal();
        return x;
    }
</code></pre></p>
<h3 id="Condition-await和Object-wait"><a href="#Condition-await和Object-wait" class="headerlink" title="Condition.await和Object.wait"></a>Condition.await和Object.wait</h3><p> 我们发现<code>ArrayBlockingList</code>并没有使用<code>Object.wait</code>，而是使用的<code>Condition.await</code>，这是为什么呢？其中又有哪些原因呢？<br> <code>Condition</code>对象可以提供和<code>Object</code>的<code>wait</code>和<code>notify</code>一样的行为，但是后者必须使用<code>synchronized</code>这个内置的monitor锁，而<code>Condition</code>使用的是<code>RenentranceLock</code>。这两种方式在阻塞等待时都会将相应的锁释放掉，但是<code>Condition</code>的等待可以中断，这是二者唯一的区别。<br>＆emsp;Condition的流程大致如下边两张图所示.</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-condition-condition1.png" alt="await"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-condition-condition2.png" alt="notify"></p>
<p> 我们首先来看一下<code>await</code>函数的实现，详细的讲解都在代码中．</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    &#x2F;&#x2F;在condition wait队列上添加新的节点
    Node node = addConditionWaiter();
    &#x2F;&#x2F;释放当前持有的锁
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    &#x2F;&#x2F;由于node在之前是添加到condition wait queue上的，现在判断这个node
    &#x2F;&#x2F;是否被添加到Sync的获得锁的等待队列上。
    &#x2F;&#x2F;node在condition queue上说明还在等待事件的notify,
    &#x2F;&#x2F;notify函数会将condition queue 上的node转化到Sync的队列上。
    while (!isOnSyncQueue(node)) {
        &#x2F;&#x2F;node还没有被添加到Sync Queue上，说明还在等待事件通知
        &#x2F;&#x2F;所以调用park函数来停止线程执行
        LockSupport.park(this);
        &#x2F;&#x2F;判断是否被中断,线程从park函数返回有两种情况，一种是
        &#x2F;&#x2F;其他线程调用了unpark,另外一种是线程被中断
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    &#x2F;&#x2F;代码执行到这里，已经有其他线程调用notify函数，或则被中断，该线程可以继续执行，但是必须先
    &#x2F;&#x2F;再次获得调用await函数时的锁．acquireQueued函数在AQS文章中做了介绍．
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
  　．．．．
}

final int fullyRelease(Node node) {
    &#x2F;&#x2F;AQS的方法，当前已经在锁中了，所以直接操作
    boolean failed = true;
    try {
        int savedState = getState();
        &#x2F;&#x2F;获取state当前的值，然后保存，以待以后恢复
        if (release(savedState)) {
            failed = false;
            return savedState;
        } else {
            throw new IllegalMonitorStateException();
        }
    } finally {
        if (failed)
            node.waitStatus = Node.CANCELLED;
    }
}

&#x2F;**
 * Checks for interrupt, returning THROW_IE if interrupted
 * before signalled, REINTERRUPT if after signalled, or
 * 0 if not interrupted.
 *&#x2F;
private int checkInterruptWhileWaiting(Node node) {
    &#x2F;&#x2F;中断可能发生在两个阶段中，一是在等待singla,另外一个是在获得signal之后
    return Thread.interrupted() ?
        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
        0;
}

final boolean transferAfterCancelledWait(Node node) {
    &#x2F;&#x2F;这里要和下边的transferForSignal对应着看，这是线程中断进入的逻辑．那边是signal的逻辑
    &#x2F;&#x2F;两边可能有并发冲突，但是成功的一方必须调用enq来进入acquire lock queue中．
    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
        enq(node);
        return true;
    }
    &#x2F;&#x2F;如果失败了，说明transferForSignal那边成功了，等待node 进入acquire lock queue
    while (!isOnSyncQueue(node))
        Thread.yield();
    return false;
}
</code></pre>
<p> <code>signal</code>函数将等待事件最长时间的线程节点从等待condition的队列移动到获得lock的等待队列中．<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public final void signal() {
    &#x2F;&#x2F;
    if (!isHeldExclusively())
    &#x2F;&#x2F;如果当前线程没有获得锁，抛出异常
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        &#x2F;&#x2F;将Condition wait queue中的第一个node转移到acquire lock queue中．
        doSignal(first);
}

private void doSignal(Node first) {
    do {
　　 &#x2F;&#x2F;由于生产者的signal在有消费者等待的情况下，必须要通知
        &#x2F;&#x2F;一个消费者，所以这里有一个循环，直到队列为空
        &#x2F;&#x2F;把first 这个node从condition queue中删除掉
        &#x2F;&#x2F;condition queue的头指针指向node的后继节点，如果node后续节点为null,那么也将尾指针也置为null
        if ( (firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &amp;&amp;
             (first = firstWaiter) != null);
    &#x2F;&#x2F;transferForSignal将node转而添加到Sync的acquire lock 队列
}

final boolean transferForSignal(Node node) {
    &#x2F;&#x2F;如果设置失败，说明该node已经被取消了,所以返回false,让doSignal继续向下通知其他未被取消的node
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;
    &#x2F;&#x2F;将node添加到acquire lock　queue中．
    Node p = enq(node);
    int ws = p.waitStatus;
    &#x2F;&#x2F;需要注意的是这里的node进行了转化
    &#x2F;&#x2F;ws&gt;0代表canceled的含义所以直接unpark线程
    &#x2F;&#x2F;如果compareAndSetWaitStatus失败，所以直接unpark,让线程继续执行await中的
    &#x2F;&#x2F;进行isOnSyncQueue判断的while循环,然后进入acquireQueue函数．
    &#x2F;&#x2F;这里失败的原因可能是Lock其他线程释放掉了锁，同步设置p的waitStatus
    &#x2F;&#x2F;如果compareAndSetWaitStatus成功了呢？那么该node就一直在acquire lock queue中
    &#x2F;&#x2F;等待锁被释放掉再次抢夺锁，然后再unparｋ
    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
</code></pre></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;后边一篇文章主要讲解如何自己使用<code>AQS</code>来创建符合自己业务需求的锁，请大家继续关注我的文章啦．一起进步偶．</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/815f6f66/" data-id="ckaubqb2p001dgr66kevggo5d" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-LongAdder解析" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/d29e90d8/">LongAdder解析</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/d29e90d8/">
            <time datetime="2017-04-21T14:38:05.000Z" itemprop="datePublished">2017-04-21</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/并发/">并发</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JUC/">JUC</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>＆emsp;对<code>LongAdder</code>的最初了解是从Coolshell上的一篇文章中获得的，但是一直都没有深入的了解过其实现，只知道它相较于<code>AtomicLong</code>来说，更加适合读多写少的并发情景。今天，我们就研究一下<code>LongAdder</code>的原理，探究一下它如此高效的原因。</p>
<h3 id="基本原理和思想"><a href="#基本原理和思想" class="headerlink" title="基本原理和思想"></a>基本原理和思想</h3><p> 我们都知道<code>AtomicLong</code>是通过无限循环不停的采取CAS的方法去设置value，直到成功为止。那么当并发数比较多或出现更新热点时，就会导致CAS的失败机率变高，重试次数更多，越多的线程重试，CAS失败的机率越高，形成恶性循环，从而降低了效率。而LongAdder的原理就是降低对value更新的并发数，也就是将对单一value的变更压力分散到多个value值上，降低单个value的“热度”<br> 我们知道<code>LongAdder</code>的大致原理之后，再来详细的了解一下它的具体实现，其中也有很多值得借鉴的并发编程的技巧。</p>
<h3 id="Add操作"><a href="#Add操作" class="headerlink" title="Add操作"></a>Add操作</h3>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public void add(long x) {
    Cell[] as; long b, v; int m; Cell a;
    if ((as = cells) != null || !casBase(b = base, b + x)) { &#x2F;&#x2F;step1
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) &lt; 0 || &#x2F;&#x2F;step2
            (a = as[getProbe() &amp; m]) == null ||  &#x2F;&#x2F;step3
            !(uncontended = a.cas(v = a.value, v + x))) &#x2F;&#x2F;step4
            longAccumulate(x, null, uncontended); &#x2F;&#x2F; step5
    }
}
</code></pre>
<p> <code>cells</code>是<code>LongAdder</code>的父类<code>Striped64</code>中的<code>Cell</code>数组类型的成员变量。每个<code>Cell</code>对象中都包含一个value值，并提供对这个value值的CAS操作。<br> 我们来看一下<code>casBase</code>函数相关的源码吧。我们可以认为变量<code>base</code>就是第一个value值，也是基础value变量。先调用casBase函数来cas一下base变量，如果成功了，就不需要在进行下面比较复杂的算法，<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">    final boolean casBase(long cmp, long val) {
        return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);
    }
</code></pre></p>
<p> 然后我们继续看step2第二层条件语句中执行的逻辑。如果cells数组为null或为空,就直接调用<code>longAccumulate</code>方法。因为cells为null或在为空，说明cells未完全初始化，所以调用<code>longAccumulate</code>进行初始化。否则继续判断。<br> 如果cells中已经有对象了，那么执行step3。我们先来理解一下<code>getProbe() &amp; m</code>的这个操作吧。我们可以首先将这个操作当作一次计算”hash”值,然后将cells中这个位置的Cell对象赋值给变量a。然后判断a是否为null,如果不为null,那么就调用Cell对象自己的cas方法去设置value值。如果a为null,或在cas赋值发生冲突，那么也是开始调用<code>longAccumulate</code>方法。</p>
<h3 id="LongAccumulate方法"><a href="#LongAccumulate方法" class="headerlink" title="LongAccumulate方法"></a>LongAccumulate方法</h3><p> <code>longAccumulate</code>函数比较复杂，带有我的注释的代码已经贴在了文章后边，这里我们就只讲一下其中比较关键的一些技巧和思想．<br> 首先，我们都知道只有当对<code>base</code>的cas操作失败之后，<code>LongAdder</code>才引入<code>Cell</code>数组．所以在<code>longAccumulate</code>中就是对<code>Cell</code>数组进行操作．分别涉及了数组的初始化，扩容和设置某个位置的Cell对象等操作．<br> 在这段代码中，关于cellBusy的cas操作构成了一个SpinLock,这就是经典的SpinLock的编程技巧，大家可以学习一下．</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">final void longAccumulate(long x, LongBinaryOperator fn,
                             boolean wasUncontended) {
       int h;
       if ((h = getProbe()) == 0) { &#x2F;&#x2F;获取PROBE变量，探针变量，与当前运行的线程相关，不同线程不同
           ThreadLocalRandom.current(); &#x2F;&#x2F;初始化PROBE变量，和getProbe都使用Unsafe类提供的原子性操作。
           h = getProbe();
           wasUncontended = true;
       }
       boolean collide = false;
       for (;;) { &#x2F;&#x2F;cas经典无限循环，不断尝试
           Cell[] as; Cell a; int n; long v;
           if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) { &#x2F;&#x2F; cells不为null,并且数组size大于0
           &#x2F;&#x2F;表示cells已经初始化了
               if ((a = as[(n - 1) &amp; h]) == null) { &#x2F;&#x2F;通过与操作计算出来需要操作的Cell对象的坐标
                   if (cellsBusy == 0) { &#x2F;&#x2F;volatile 变量，用来实现spinLock,来在初始化和resize cells数组时使用。
                   &#x2F;&#x2F;当cellsBusy为0时，表示当前可以对cells数组进行操作。 
                       Cell r = new Cell(x);&#x2F;&#x2F;将x值直接赋值给Cell对象
                       if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {&#x2F;&#x2F;如果这个时候cellsBusy还是0
                       &#x2F;&#x2F;就cas将其设置为非０，如果成功了就是获得了spinLock的锁．可以对cells数组进行操作．
                       &#x2F;&#x2F;如果失败了，就会再次执行一次循环
                           boolean created = false;
                           try {
                               Cell[] rs; int m, j;
                               &#x2F;&#x2F;判断cells是否已经初始化，并且要操作的位置上没有cell对象．
                               if ((rs = cells) != null &amp;&amp;
                                   (m = rs.length) &gt; 0 &amp;&amp;
                                   rs[j = (m - 1) &amp; h] == null) {
                                   rs[j] = r;　&#x2F;&#x2F;将之前创建的值为x的cell对象赋值到cells数组的响应位置．
                                   created = true;
                               }
                           } finally {
                               &#x2F;&#x2F;经典的spinLock编程技巧，先获得锁，然后try finally将锁释放掉
                               &#x2F;&#x2F;将cellBusy设置为0就是释放锁．
                               cellsBusy = 0;
                           }
                           if (created)
                               break;　&#x2F;&#x2F;如果创建成功了，就是使用x创建了新的cell对象，也就是新创建了一个分担热点的value
                           continue; 
                       }
                   }
                   collide = false; &#x2F;&#x2F;未发生碰撞
               }
               else if (!wasUncontended)&#x2F;&#x2F;是否已经发生过一次cas操作失败
                   wasUncontended = true; &#x2F;&#x2F;设置成true,以便第二次进入下一个else if 判断
               else if (a.cas(v = a.value, ((fn == null) ? v + x :
                                            fn.applyAsLong(v, x))))
                  　&#x2F;&#x2F;fn是操作类型，如果是空，就是相加，所以让a这个cell对象中的value值和x相加，然后在cas设置，如果成果
                  &#x2F;&#x2F;就直接返回
                   break;
               else if (n &gt;= NCPU || cells != as)
               　　&#x2F;&#x2F;如果cells数组的大小大于系统的可获得处理器数量或在as不再和cells相等．
                   collide = false;            &#x2F;&#x2F; At max size or stale
               else if (!collide)
                   collide = true;
               else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {
               　　&#x2F;&#x2F;再次获得cellsBusy这个spinLock,对数组进行resize
                   try {
                       if (cells == as) {&#x2F;&#x2F;要再次检测as是否等于cells以免其他线程已经对cells进行了操作．
                           Cell[] rs = new Cell[n &lt;&lt; 1]; &#x2F;&#x2F;扩容一倍
                           for (int i = 0; i &lt; n; ++i)
                               rs[i] = as[i];
                           cells = rs;&#x2F;&#x2F;赋予cells一个新的数组对象
                       }
                   } finally {
                       cellsBusy = 0;
                   }
                   collide = false;
                   continue;
               }
               h = advanceProbe(h);&#x2F;&#x2F;由于使用当前探针变量无法操作成功，所以重新设置一个,再次尝试
           }
           else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) {
           &#x2F;&#x2F;cells数组未初始化，获得cellsBusy　lock,来初始化
               boolean init = false;
               try {                           &#x2F;&#x2F; Initialize table
                   if (cells == as) {
                       Cell[] rs = new Cell[2];
                       rs[h &amp; 1] = new Cell(x); &#x2F;&#x2F;设置x的值为cell对象的value值
                       cells = rs;
                       init = true;
                   }
               } finally {
                   cellsBusy = 0;
               }
               if (init)
                   break;
           }&#x2F;&#x2F;如果初始化数组失败了，那就再次尝试一下直接cas base变量，如果成功了就直接返回
           else if (casBase(v = base, ((fn == null) ? v + x :
                                       fn.applyAsLong(v, x))))
               break;                          &#x2F;&#x2F; Fall back on using base
       }
   }
</code></pre>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;本篇文章写的不是很好，我写完之后又看了一遍coolshell上的这篇关于<code>LongAdder</code>的<a href="http://coolshell.cn/articles/11454.html" target="_blank" rel="noopener">文章</a>，感觉自己没有人家写的那么简介明了。我对代码细节的注释和投入太多了。其实很多代码大家都可以看懂，并不需要大量的代码片段加注释。以后要注意一下。之后会接着研究一下JUC包中的其他类，希望大家多多关注。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/d29e90d8/" data-id="ckaubqb300029gr66r9gesfqp" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-分布式一致性算法Paxos" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/5635585c/">分布式一致性算法Paxos</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/5635585c/">
            <time datetime="2017-04-16T06:42:35.000Z" itemprop="datePublished">2017-04-16</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/分布式/">分布式</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/算法/">算法</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 最近在学习zookeeper原理的时候了解到了paxos算法,看了几篇文章之后还是感觉有些迷糊,后来看了知行学社的<a href="http://www.tudou.com/programs/view/e8zM8dAL6hM/" target="_blank" rel="noopener">paxos视频</a>才对这个算法有了一定的了解,这里就做一下总结.</p>
<h3 id="Paxos简介"><a href="#Paxos简介" class="headerlink" title="Paxos简介"></a>Paxos简介</h3><p> Paxos是Lamport于1990年提出的一种基于消息传递而具有高度容错特性的分布式一致性算法.这个算法是分布式中最为重要的算法,Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法,那就是Paxos,其他算法都是残次品.具体Paxos算法的详细内涵和故事背景大家可以参考知乎上的<a href="https://www.zhihu.com/question/19787937" target="_blank" rel="noopener">回答</a>;</p>
<h3 id="Paxos的使用场景和假设"><a href="#Paxos的使用场景和假设" class="headerlink" title="Paxos的使用场景和假设"></a>Paxos的使用场景和假设</h3><p> 我们都知道基于消息传递通信模型的分布式系列,不可避免的会发生以下错误:进程可能会慢,被杀死或在重启,消息可能会有延迟,丢失和重复.Paxos算法解决的问题就是在一个可能发生上述异常的分布式系统中如何就某个值达成一致,保证无论发生以上任何异常,都不会破坏决议的一致性。但是Paxos算法也有一定的使用假设。一个假设是在消息传递的过程中不会出现拜占庭将军问题：即虽然有可能一个消息被传递两次，但是绝对不会出现错误的消息。另一个假设是提议不会被反对，只能被同意或在被更新的提议替换。<br> Paxos协议中有三种角色，每个节点可以扮演多个角色：</p>
<ul>
<li>倡议者(Proposer):提议者可以提出提议(数值或在操作命令)以供投票表决。</li>
<li>接受者(Acceptor):接受者可以对提议者提出的提议进行投票表决，提议有超过半数的接收者投票即被选中。</li>
<li>学习者(Learner):学习者无投票者，只是从接收者那里获取哪个提议被选中。</li>
</ul>
<p> 在Paxos算法中，一个或在多个Proposer都可以并发的提出提议；系统必须针对所有提议中的某个提议达成一致（超过半数大的接受者选中）；最多只能对一个确定的提议达成一致；只要超过半数的节点存活且可以互相通信，整个系统一定可以达成一致，即选择一个确定的提议。<br> 如果直接讲解Paxos算法，大家可能会有些难以理解，这里我们就按着视频里的顺序，先从简单的分布式一致性算法开始，然后不断进行优化，最后将其演变成Paxos算法。</p>
<h3 id="图解Paxos主要流程"><a href="#图解Paxos主要流程" class="headerlink" title="图解Paxos主要流程"></a>图解Paxos主要流程</h3><p> Paxoso算法分为两个的阶段，我们就将其分别记为Phase1和Phase2.每个Proposer都持有一个独有的变量epoch,每个Acceptor都保存三个状态：lastest_prepared__epoch,accepted_epoch和accepted_value.lastest_prepared_epoch是指Acceptor授予访问权的Proposer的epoch值，accepted_epoch是Acceptor接受提议的Proposer的epoch值，而accepted_value就是Acceptor接受的提议值喽，他们的初始值都为null。</p>
<h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><p> Phase1过程中，Proposer向Acceptor发起<code>Prepare(epoch)</code>请求来获取访问权。将自己的epoch发送给Acceptor.而Acceptor只会接受比lastest_prepared_epoch更大的epoch,并给予访问权，并将epoch记录到lastest_prepared_epoch的值中，返回当前的accepted_epoch和accepted_value的值。在初始化状态下，二者都是null,所以返回的是<null,null>。如果epoch小于lastest_prepared_epoch则不授予访问权，并返回<error>。<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-paxos-paxos1.png" alt="phase1"><br> 如上图所示，Proposer1向5个Acceptor发送了Prepare(#1)的请求，其中前三个请求顺利到达，Acceptor授予访问权，返回<null,null>，并修改lastest_prepared_epoch为1。而后两个请求发生了网络延迟,一直未到达相应的Acceptor。<br> 在阶段一中，Proposer需要获得半数以上的Acceptor的访问权和对应的一组value的取值才会进行第二阶段，这样才会确保，一个Proposer提出的确定的议案会被另外一个Proposer发现，从而在阶段二中会进行正确的操作。</null,null></error></null,null></p>
<h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><p> 第二阶段采取“后者认同前者”的原则进行。在肯定旧epoch无法生成确定性取值时，新的epoch会提交自己的取值，不会冲突；一旦旧epoch形成了确定性取值，那么该proposer一定可以获得该取值，并且会认同该取值，不会破坏。<br> 如果Proposer在第一阶段获取的value值都是null,则旧epoch无法形成确定性取值，此时让自己的<epoch,v>成为确定性取值：</epoch,v></p>
<ul>
<li>向epoch对应的所有acceptor提交取值<epoch,v></epoch,v></li>
<li>如果收到半数以上的成功应答，则返回<ok,v></ok,v></li>
<li>否则返回<error></error></li>
</ul>
<p> 如果value的取值不为null,则认同最大accepted_epoch对应的取值f,使<epoch，f>成为确定性取值，其中epoch是自己的epoch.</epoch，f></p>
<ul>
<li>如果f出现半数以上，则说明f已经是确定性取值了，直接返回<ok,f></ok,f></li>
<li>否则，向epoch所对应的acceptor提交取值<epoch,f></epoch,f></li>
</ul>
<p> Acceptor在接收到accept(epoch,V)的请求之后，先查看epoch是不是自己记录的lastest_prepared_epoch，如果是则设置<accepted_epoch,accepted_value> = <prepared_epoch,v> 。否在则会返回error</prepared_epoch,v></accepted_epoch,accepted_value></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-paxos-paxos2.png" alt="paxos2"></p>
<p> 如上图所示，由于在阶段一中Proposer1接受到的<accepted_epoch>和<accepted_value>值都为null,所以，决定将自己的值设置为确定值，于是发送accept(1,V1)请求。Acceptor1接受到了这个请求，检查lastest_prepared_epoch也等于1,所以将自己存储的<accepted_epoch,accepted_value>设置为<1,v1>。而Proposer1的另外两个accept请求发生了网络延迟。<br> 如果此时，Proposer2向Acceptor进行propose会怎么样呢？我们来模拟propose来分析一下。</1,v1></accepted_epoch,accepted_value></accepted_value></accepted_epoch></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-paxos-paxos3.png" alt="paxos3"></p>
<p> 如上图所示，Proposer2向Acceptor发送了prepare(#2)的请求，Acceptor1先检测一下发现2大于现在的lastest_prepared_epoch,所以同意发送访问权，将lastest_prepared_epoch修改为2，并将自己保存的accepted_epoch和acceped_value返回给Proposer2；Acceptor3的操作也是类似，只不过因为Proposer1发送的accept请求发生了延迟，所以Acceptor3返回的是<null,null>；而Acceptor5的操作和我们在文章第一张图中的Acceptor1的操作相同，他们都是第一次接收到prepare请求。<br> 然后Proposer2进行第二阶段的操作，从所有的返回数据中，找到accepted_epoch最大的那个accepted_value.这里就是Acceptor返回的<1,v1>，所以，Proposer2会尽力让V1成为确定值，所以它向Acceptor发送accept(2,V1)的请求。然后Acceptor1,Acceptor3,Acceptor5三个Acceptor接受了这个accept请求，更新自己的<accepted_epoch,accepted_value>。此时，已经有三个acceptor形成了一致性的值，所以V1就成了整个系统的确定性取值。<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-paxos-paxos7.png" alt="paxos7.png"></accepted_epoch,accepted_value></1,v1></null,null></p>
<p> 那么Proposer1对Acceptor3发送的accept请求在此时达到Acceptor3会怎么样呢？Acceptor3发现当前lastest_prepared_epoch是2,所以直接拒绝了这个请求。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p> 不清楚大家现在对Paxos算法的过程是否已经有了清楚的了解啊？那么我来问几个问题，大家可以考虑一下：</p>
<ul>
<li>在本文的情景下，假如Proposer2向Acceptor2,3,4发送了prepare请求，而不是向Acceptor1,3,5发送的请求，会怎么样呢？</li>
<li>为什么强调prepare阶段时必须接受到一般以上Acceptor的返回，才能进行第二阶段?<br>&emsp;后续希望能够分析一下<code>Zookeeper</code>关于Paxos的具体使用场景和算法，希望大家多多关注。</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/5635585c/" data-id="ckaubqb4q006agr66kig8auyq" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-AbstractQueuedSynchronizer超详细原理解析" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/d2edd1b8/">AbstractQueuedSynchronizer超详细原理解析</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/d2edd1b8/">
            <time datetime="2017-04-06T13:50:01.000Z" itemprop="datePublished">2017-04-06</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/并发/">并发</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JUC/">JUC</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 今天我们来研究学习一下<code>AbstractQueuedSynchronizer</code>类的相关原理,<code>java.util.concurrent</code>包中很多类都依赖于这个类所提供的队列式的同步器,比如说常用的<code>ReentranLock</code>,<code>Semaphore</code>和<code>CountDownLatch</code>等.<br> 为了方便理解,我们以一段使用<code>ReentranLock</code>的代码为例,讲解<code>ReentranLock</code>每个方法中有关<code>AQS</code>的使用.</p>
<h3 id="ReentranLock示例"><a href="#ReentranLock示例" class="headerlink" title="ReentranLock示例"></a>ReentranLock示例</h3><p> 我们都知道<code>ReentranLock</code>的加锁行为和<code>Synchronized</code>类似,都是可重入的锁,但是二者的实现方式确实完全不同的,我们之后也会讲解<code>Synchronized</code>的原理.<strong><em>除此之外,Synchronized的阻塞无法被中断,而ReentrantLock则提供了可中断的阻塞</em></strong>下面的代码是<code>ReentranLock</code>的相关API,我们就以此为顺序,依次讲解.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">ReentrantLock lock = new ReentrantLock();
lock.lock();
lock.unlock();
</code></pre></p>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p> ReentranLock分为公平锁和非公平锁.二者的区别就在获取锁是否和排队顺序相关.我们都知道,如果当前锁被另一个线程持有,那么当前申请锁的线程会被挂起等待,然后加入一个等待队列里.理论上,先调用<code>lock</code>函数被挂起等待的线程应该排在等待队列的前端,后调用的就排在后边.如果此时,锁被释放,需要通知等待线程再次尝试获取锁,公平锁会让最先进入队列的线程获得锁,而非公平锁则会唤醒所有线程,让它们再次尝试获取锁,所以可能会导致后来的线程先获得了锁,则就是非公平.</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre>
<p> 我们会发现<code>FairSync</code>和<code>NonfairSync</code>都继承了<code>Sync</code>类,而<code>Sync</code>的父类就是<code>AbstractQueuedSynchronizer</code>.但是<code>AQS</code>的构造函数是空的,并没有任何操作.<br> 之后的源码分析,如果没有特别说明,就是指公平锁.</p>
<h3 id="lock操作"><a href="#lock操作" class="headerlink" title="lock操作"></a>lock操作</h3><p> <code>ReentranLock</code>的<code>lock</code>函数如下所示,直接调用了<code>sync</code>的<code>lock</code>函数.也就是调用了<code>FairSync</code>的<code>lock</code>函数.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">    &#x2F;&#x2F;ReentranLock
    public void lock() {
        sync.lock();
    }
    &#x2F;&#x2F;FairSync
    final void lock() {
        acquire(1);&#x2F;&#x2F;调用了AQS的acquire函数,这是关键函数之一
    }
</code></pre></p>
<p> 好,我们接下来就正式开始<code>AQS</code>相关的源码分析了,<code>acquire</code>函数你可以将其理解为获取一个同一时间只能有一个函数获取的量,这个量就是锁概念的抽象化.我们先分析代码,你慢慢就会明白其中的含义.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp; &#x2F;&#x2F;tryAcquire先尝试获取&quot;锁&quot;,&#x2F;&#x2F;如果成功,直接返回,失败继续执行后续代码
        &#x2F;&#x2F;addWaiter是给当前线程创建一个节点,并将其加入等待队列
        &#x2F;&#x2F;acquireQueued是当线程已经加入等待队列之后的行为.
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre></p>
<p> <code>tryAcquire</code>,<code>addWaiter</code>和<code>acquireQueued</code>都是十分重要的函数,我们接下来依次学习一下这些函数,理解它们的作用.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F;AQS类中的变量.
private volatile int state;
&#x2F;&#x2F;这是FairSync的实现,AQS中未实现,子类按照自己的需要实现该类
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    &#x2F;&#x2F;获取AQS中的state变量,代表抽象概念的锁.
    int c = getState();
    if (c == 0) { &#x2F;&#x2F;值为0,那么当前独占性变量还未被线程占有
        if (!hasQueuedPredecessors() &amp;&amp; &#x2F;&#x2F;如果当前阻塞队列上没有先来的线程在等待,UnfairSync这里的实现就不一致
            compareAndSetState(0, acquires)) {
            &#x2F;&#x2F;成功cas,那么代表当前线程获得该变量的所有权,也就是说成功获得锁
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        &#x2F;&#x2F;如果该线程已经获取了独占性变量的所有权,那么根据重入性
        &#x2F;&#x2F;原理,将state值进行加1,表示多次lock
        &#x2F;&#x2F;由于已经获得锁,该段代码只会被一个线程同时执行,所以不需要
        &#x2F;&#x2F;进行任何并行处理
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    &#x2F;&#x2F;上述情况都不符合,说明获取锁失败
    return false;
}
</code></pre></p>
<p> 由上述代码我们可以发现,<code>tryAcquire</code>就是尝试获取那个线程独占的变量<code>state</code>.state的值表示其状态:如果是0,那么当前还没有线程独占此变量;否在就是已经有线程独占了这个变量,也就是代表已经有线程获得了锁.但是这个时候要再进行一次判断,看是否是当前线程自己获得的这个锁,如果是,那么就增加state的值.</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201746-aqs-AQS1.png" alt="ReentranLock获得锁"></p>
<p> 这里有几点需要说明一下,首先是<code>compareAndSetState</code>函数,这是使用CAS操作来设置<code>state</code>的值,而且state值设置了<code>volatile</code>修饰符,通过这两点来确保修改state的值不会出现多线程问题.然后是公平锁和非公平锁的区别问题,在<code>UnfairSync</code>的<code>nonfairTryAcquire</code>函数中不会在相同的位置上调用<code>hasQueuedPredecessors</code>来判断当前是否已经有线程在排队等待获得锁.<br> 如果<code>tryAcquire</code>返回<code>true</code>,那么就是获取锁成功,如果返回false,那么就是未获得锁.需要加入阻塞等待队列.我们下面就来看一下<code>addWaiter</code>的相关操作</p>
<h3 id="等待锁的阻塞队列"><a href="#等待锁的阻塞队列" class="headerlink" title="等待锁的阻塞队列"></a>等待锁的阻塞队列</h3><p> 将保存当前线程信息的节点加入到等待队列的相关函数中涉及到了无锁队列的相关算法,由于在<code>AQS</code>中只是将节点添加到队尾,使用到的无锁算法也相对简单.真正的无锁队列的算法我们等到分析<code>ConcurrentSkippedListMap</code>时在进行讲解.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    &#x2F;&#x2F;先使用快速如列法来尝试一下,如果失败,则进行更加完备的如列算法.
    Node pred = tail;&#x2F;&#x2F;列尾指针
    if (pred != null) {
        node.prev = pred; &#x2F;&#x2F;步骤1:该节点的前趋指针指向tail
        if (compareAndSetTail(pred, node)){ &#x2F;&#x2F;步骤二:cas将尾指针指向该节点
            pred.next = node;&#x2F;&#x2F;步骤三:如果成果,让旧列尾节点的next指针指向该节点.
            return node;
        }
    }
    &#x2F;&#x2F;cas失败,或在pred == null时调用enq
    enq(node);
    return node;
}
private Node enq(final Node node) {
    for (;;) { &#x2F;&#x2F;cas无锁算法的标准for循环,不停的尝试
        Node t = tail;
        if (t == null) { &#x2F;&#x2F;初始化
            if (compareAndSetHead(new Node())) &#x2F;&#x2F;需要注意的是head是一个哨兵的作用,并不代表某个要获取锁的线程节点
                tail = head;
        } else {
            &#x2F;&#x2F;和addWaiter中一致,不过有了外侧的无限循环,不停的尝试,自旋锁
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre></p>
<p> 通过调用<code>addWaiter</code>函数,<code>AQS</code>将当前线程加入到了等待队列,但是还没有阻塞当前线程的执行,接下来我们就来分析一下<code>acquireQueued</code>函数.</p>
<h3 id="等待队列节点的操作"><a href="#等待队列节点的操作" class="headerlink" title="等待队列节点的操作"></a>等待队列节点的操作</h3><p> 由于进入阻塞状态的操作会降低执行效率,所以,<code>AQS</code>会尽力避免试图获取独占性变量的线程进入阻塞状态.所以,当线程加入等待队列之后,<code>acquireQueued</code>会执行一个for循环,每次都判断当前节点是否应该获得这个变量(在队首了),如果不应该获取或在再次尝试获取失败,那么就调用<code>shouldParkAfterFailedAcquire</code>判断是否应该进入阻塞状态,如果当前节点之前的节点已经进入阻塞状态了,那么就可以判定当前节点不可能获取到锁,为了防止CPU不停的执行for循环,消耗CPU资源,调用<code>parkAndCheckInterrupt</code>函数来进入阻塞状态.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) { &#x2F;&#x2F;一直执行,知道获取锁,返回.
            final Node p = node.predecessor(); 
            &#x2F;&#x2F;node的前驱是head,就说明,node是将要获取锁的下一个节点.
            if (p == head &amp;&amp; tryAcquire(arg)) { &#x2F;&#x2F;所以再次尝试获取独占性变量
                setHead(node); &#x2F;&#x2F;如果成果,那么就将自己设置为head
                p.next = null; &#x2F;&#x2F; help GC
                failed = false;
                return interrupted;&#x2F;&#x2F;此时,还没有进入阻塞状态,所以直接返回false,表示不需要中断
            }
            &#x2F;&#x2F;判断是否要进入阻塞状态.如果`shouldParkAfterFailedAcquire`返回true,表示需要进入阻塞
            &#x2F;&#x2F;调用parkAndCheckInterrupt,否在表示还可以再次尝试获取锁,继续进行for循环
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                &#x2F;&#x2F;调用parkAndCheckInterrupt进行阻塞,然后返回是否为中断状态
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL) &#x2F;&#x2F;前一个节点在等待独占性变量释放的通知,所以,当前节点可以阻塞
        return true;
    if (ws &gt; 0) { &#x2F;&#x2F;前一个节点处于取消获取独占性变量的状态,所以,可以跳过去
        &#x2F;&#x2F;返回false
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {
        &#x2F;&#x2F;将上一个节点的状态设置为signal,返回false,
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this); &#x2F;&#x2F;将AQS对象自己传入
    return Thread.interrupted();
}
</code></pre></p>
<h3 id="阻塞和中断"><a href="#阻塞和中断" class="headerlink" title="阻塞和中断"></a>阻塞和中断</h3><p> 由上述分析,我们知道了<code>AQS</code>通过调用<code>LockSupport</code>的<code>park</code>方法来执行阻塞当前进程的操作.其实,这里的阻塞就是线程不再执行的含义.通过调用这个函数,线程进入阻塞状态,上述的<code>lock</code>操作也就阻塞了.等待中断或在独占性变量被释放.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public static void park(Object blocker) {
    Thread t = Thread.currentThread();
    setBlocker(t, blocker);&#x2F;&#x2F;设置阻塞对象,用来记录线程被谁阻塞的,用于线程监控和分析工具来定位
    UNSAFE.park(false, 0L);&#x2F;&#x2F;让当前线程不再被线程调度,就是当前线程不再执行.
    setBlocker(t, null);
}
</code></pre></p>
<p> 关于中断的相关知识,我们以后再说,就继续沿着<code>AQS</code>的主线,看一下释放独占性变量的相关操作吧.</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201746-aqs-AQS2.png" alt="ReentrantLock未获得阻塞,加入队列"></p>
<h3 id="unlock操作"><a href="#unlock操作" class="headerlink" title="unlock操作"></a>unlock操作</h3><p> 与<code>lock</code>操作类似,<code>unlock</code>操作调用了<code>AQS</code>的<code>relase</code>方法,参数和调用<code>acquire</code>时一样,都是1.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public final boolean release(int arg) {
    if (tryRelease(arg)) { &#x2F;&#x2F;释放独占性变量,起始就是将status的值减1,因为acquire时是加1
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);&#x2F;&#x2F;唤醒head的后继节点
        return true;
    }
    return false;
}
</code></pre></p>
<p> 由上述代码可知,release就是先调用<code>tryRelease</code>来释放独占性变量,如果成果,那么就看一下是否有等待锁的阻塞线程,如果有,就调用<code>unparkSuccessor</code>来唤醒他们.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">protected final boolean tryRelease(int releases) {
    &#x2F;&#x2F;由于只有一个线程可以获得独占先变量,所以,所有操作不需要考虑多线程
    int c = getState() - releases; 
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) { &#x2F;&#x2F;如果等于0,那么说明锁应该被释放了,否在表示当前线程有多次lock操作.
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre></p>
<p> 我们可以看到<code>tryRelease</code>中的逻辑也体现了可重入锁的概念,只有等到<code>state</code>的值为1时,才代表锁真正被释放了.所以独占性变量<code>state</code>的值就代表锁的有无.当<code>state=0</code>时,表示锁未被占有,否在表示当前锁已经被占有.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">private void unparkSuccessor(Node node) {
    .....
     &#x2F;&#x2F;一般来说,需要唤醒的线程就是head的下一个节点,但是如果它获取锁的操作被取消,或在节点为null时
     &#x2F;&#x2F;就直接继续往后遍历,找到第一个未取消的后继节点.
    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
</code></pre></p>
<p> 调用了<code>unpark</code>方法后,进行<code>lock</code>操作被阻塞的线程就恢复到运行状态,就会再次执行<code>acquireQueued</code>中的无限for循环中的操作,再次尝试获取锁.</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201746-aqs-AQS3.png" alt="ReentrantLock释放锁并通知阻塞线程恢复执行"></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p> 有关<code>AQS</code>和<code>ReentrantLock</code>的分析就差不多结束了,不得不说,我第一次看到AQS的实现时真是震惊,以前都认为<code>Synchronized</code>和<code>ReentrantLock</code>的实现原理是一致的,都是依靠java虚拟机的功能实现的,没有想到还有<code>AQS</code>这样一个背后大Boss在提供帮助啊.学习了这个类的原理,我们对JUC的很多类的分析就简单了很多,此外,<code>AQS</code>涉及的<code>CAS</code>操作和无锁队列的算法也为我们学习其他无锁算法提供了基础.<strong><em>知识的海洋是无限的啊!</em></strong></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/d2edd1b8/" data-id="ckaubqb20000egr667uhuy8vh" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Netty源码-三-I-O模型和Java-NIO底层原理" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/dbc01bc2/">Netty源码(三):I/O模型和Java NIO底层原理</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/dbc01bc2/">
            <time datetime="2017-04-02T15:11:13.000Z" itemprop="datePublished">2017-04-02</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Netty/">Netty</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Netty/">Netty</a>, <a class="tag-link" href="/tags/epoll/">epoll</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> <a href="http://remcarpediem.com/2017/03/27/Netty%E6%BA%90%E7%A0%81-%E4%BA%8C-Netty%E7%9A%84Channel%E5%92%8CPipeline/" target="_blank" rel="noopener">上一篇文章</a>我们主要讲解了Netty的<code>Channel</code>和<code>Pipeline</code>，了解到不同的<code>Channel</code>可以提供基于不同网络协议的通信处理．既然涉及到网络通信，就不得不说一下多线程，同步异步相关的知识了．Netty的网络模型是多线程的<code>Reactor</code>模式，所有I/O请求都是异步调用，我们今天就来探讨一下一些基础概念和Java NIO的底层机制．<br> 为了节约你的时间，本文主要内容如下：</p>
<ul>
<li>异步，阻塞的概念</li>
<li>操作系统I/O的类型</li>
<li>Java NIO的Linux底层实现</li>
</ul>
<h3 id="异步，同步，阻塞，非阻塞"><a href="#异步，同步，阻塞，非阻塞" class="headerlink" title="异步，同步，阻塞，非阻塞"></a>异步，同步，阻塞，非阻塞</h3><p> <strong><em>同步和异步关注的是消息通信机制</em></strong>，所谓同步就是调用者进行调用后，在没有得到结果之前，该调用一直不会返回，但是一旦调用返回，就得到了返回值，<strong><em>同步就是指调用者主动等待调用结果</em></strong>；而异步则相反，执行调用之后直接返回，所以可能没有返回值，等到有返回值时，由被调用者通过状态，通知来通知调用者．<strong>异步就是指被调用者来通知调用者调用结果就绪*</strong>．<strong><em>所以，二者在消息通信机制上有所不同，一个是调用者检查调用结果是否就绪，一个是被调用者通知调用者结果就绪</em></strong><br> <strong><em>阻塞和非阻塞关注的是程序在等待调用结果(消息，返回值)时的状态</em></strong>．阻塞调用是指在调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会继续执行．非阻塞调用是指在不能立刻得到结构之前，调用线程不会被挂起，还是可以执行其他事情．<br> 两组概念相互组合就有四种情况，分别是同步阻塞，同步非阻塞，异步阻塞，异步非阻塞．我们来举个例子来分别类比上诉四种情况．<br> 比如你要从网上下载一个1G的文件，按下下载按钮之后，如果你一直在电脑旁边，等待下载结束，这种情况就是同步阻塞；如果你不需要一直呆在电脑旁边，你可以去看一会书，但是你还是隔一段时间来查看一下下载进度，这种情况就是同步非阻塞；如果你一直在电脑旁边，但是下载器在下载结束之后会响起音乐来提醒你，这就是异步阻塞；但是如果你不呆在电脑旁边，去看书，下载器下载结束后响起音乐来提醒你，那么这种情况就是异步非阻塞．</p>
<h3 id="Unix的I-O类型"><a href="#Unix的I-O类型" class="headerlink" title="Unix的I/O类型"></a>Unix的I/O类型</h3><p> 知道上述两组概念之后，我们来看一下Unix下可用的5种I/O模型：</p>
<ul>
<li>阻塞I/O</li>
<li>非阻塞I/O</li>
<li>多路复用I/O</li>
<li>信号驱动I/O</li>
<li>异步I/O</li>
</ul>
<p> 前４种都是同步，只有最后一种是异步I/O.需要注意的是<strong><em>Java NIO依赖于Unix系统的多路复用I/O,对于I/O操作来说，它是同步I/O，但是对于编程模型来说，它是异步网络调用</em></strong>.下面我们就以系统<code>read</code>的调用来介绍不同的I/O类型．<br> 当一个<code>read</code>发生时，它会经历两个阶段:</p>
<ul>
<li>1 等待数据准备</li>
<li>2 将数据从内核内存空间拷贝到进程内存空间中</li>
</ul>
<p> 不同的I/O类型，在这两个阶段中有不同的行为．但是由于这块内容比较多，而且多为表述性的知识，所以这里我们只给出几张图片来解释，具体解释大家可以参看<a href="http://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">这篇博文</a></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201742-netty-0_1280550787I2K8.gif" alt="Blocking I/O"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201742-netty-0_128055089469yL.gif" alt="NonBlocking I/O"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201742-netty-0_1280551028YEeQ.gif" alt="Multiplexing I/O"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201742-netty-0_1280551287S777.gif" alt="Asynchronous I/O"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201742-netty-0_1280551552NVgW.gif" alt="对比"></p>
<h3 id="Java-NIO的Linux底层实现"><a href="#Java-NIO的Linux底层实现" class="headerlink" title="Java NIO的Linux底层实现"></a>Java NIO的Linux底层实现</h3><p> 我们都知道Netty通过JNI的方式提供了Native Socket Transport，为什么<code>Netty</code>要提供自己的Native版本的NIO呢？明明Java NIO底层也是基于<code>epoll</code>调用(最新的版本)的．这里，我们先不明说，大家想一想可能的情况．下列的源码都来自于OpenJDK-8u40-b25版本．</p>
<h4 id="open方法"><a href="#open方法" class="headerlink" title="open方法"></a>open方法</h4><p>&emsp;如果我们顺着<code>Selector.open()</code>方法一个类一个类的找下去，很容易就发现<code>Selector</code>的初始化是由<code>DefaultSelectorProvider</code>根据不同操作系统平台生成的不同的<code>SelectorProvider</code>，对于Linux系统，它会生成<code>EPollSelectorProvider</code>实例，而这个实例会生成<code>EPollSelectorImpl</code>作为最终的<code>Selector</code>实现．<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">class EPollSelectorImpl extends SelectorImpl
{
    .....
    &#x2F;&#x2F; The poll object
    EPollArrayWrapper pollWrapper;
    .....
    EPollSelectorImpl(SelectorProvider sp) throws IOException {
        .....
        pollWrapper = new EPollArrayWrapper();
        pollWrapper.initInterrupt(fd0, fd1);
        .....
    }
    .....
}
</code></pre></p>
<p>&emsp;<code>EpollArrayWapper</code>将Linux的epoll相关系统调用封装成了native方法供<code>EpollSelectorImpl</code>使用．<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">    private native int epollCreate();
    private native void epollCtl(int epfd, int opcode, int fd, int events);
    private native int epollWait(long pollAddress, int numfds, long timeout,
                                 int epfd) throws IOException;
</code></pre></p>
<p> 上述三个native方法就对应Linux下epoll相关的三个系统调用<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-c">&#x2F;&#x2F;创建一个epoll句柄，size是这个监听的数目的最大值．
int epoll_create(int size);
&#x2F;&#x2F;事件注册函数，告诉内核epoll监听什么类型的事件，参数是感兴趣的事件类型，回调和监听的fd
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
&#x2F;&#x2F;等待事件的产生，类似于select调用，events参数用来从内核得到事件的集合
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
</code></pre></p>
<p>&emsp;所以，我们会发现在<code>EpollArrayWapper</code>的构造函数中调用了<code>epollCreate</code>方法，创建了一个epoll的句柄．这样，<code>Selector</code>对象就算创造完毕了．</p>
<h4 id="register方法"><a href="#register方法" class="headerlink" title="register方法"></a>register方法</h4><p>&emsp;与<code>open</code>类似，<code>ServerSocketChannel</code>的<code>register</code>函数底层是调用了<code>SelectorImpl</code>类的<code>register</code>方法，这个<code>SelectorImpl</code>就是<code>EPollSelectorImpl</code>的父类．<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">protected final SelectionKey register(AbstractSelectableChannel ch,
                                      int ops,
                                      Object attachment)
{
    if (!(ch instanceof SelChImpl))
        throw new IllegalSelectorException();
    &#x2F;&#x2F;生成SelectorKey来存储到hashmap中，一共之后获取
    SelectionKeyImpl k = new SelectionKeyImpl((SelChImpl)ch, this);
    &#x2F;&#x2F;attach用户想要存储的对象
    k.attach(attachment);
    &#x2F;&#x2F;调用子类的implRegister方法
    synchronized (publicKeys) {
        implRegister(k);
    }
    &#x2F;&#x2F;设置关注的option
    k.interestOps(ops);
    return k;
}
</code></pre></p>
<p>&emsp;<code>EpollSelectorImpl</code>的相应的方法实现如下，它调用了<code>EPollArrayWrapper</code>的<code>add</code>方法，记录下Channel所对应的fd值,然后将ski添加到<code>keys</code>变量中．在<code>EPollArrayWrapper</code>中有一个byte数组<code>eventLow</code>记录所有的channel的fd值.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">    protected void implRegister(SelectionKeyImpl ski) {
        if (closed)
            throw new ClosedSelectorException();
        SelChImpl ch = ski.channel;
        &#x2F;&#x2F;获取Channel所对应的fd,因为在linux下socket会被当作一个文件，也会有fd
        int fd = Integer.valueOf(ch.getFDVal());
        fdToKey.put(fd, ski);
        &#x2F;&#x2F;调用pollWrapper的add方法,将channel的fd添加到监控列表中
        pollWrapper.add(fd);
        &#x2F;&#x2F;保存到HashSet中，keys是SelectorImpl的成员变量
        keys.add(ski);
    }
</code></pre></p>
<p>&emsp;我们会发现,调用<code>register</code>方法并没有涉及到<code>EpollArrayWrapper</code>中的native方法<code>epollCtl</code>的调用,这是因为他们将这个方法的调用推迟到<code>Select</code>方法中去了.<br>&emsp;</p>
<h4 id="Select方法"><a href="#Select方法" class="headerlink" title="Select方法"></a>Select方法</h4><p>&emsp;和<code>register</code>方法类似,<code>SelectorImpl</code>中的<code>select</code>方法最终调用了其子类<code>EpollSelectorImpl</code>的<code>doSelect</code>方法<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">protected int doSelect(long timeout) throws IOException {
    .....
    try {
        ....
        &#x2F;&#x2F;调用了poll方法,底层调用了native的epollCtl和epollWait方法
        pollWrapper.poll(timeout);
    } finally {
        ....
    }
    ....
    &#x2F;&#x2F;更新selectedKeys,为之后的selectedKeys函数做准备
    int numKeysUpdated = updateSelectedKeys();
    ....
    return numKeysUpdated;
}
</code></pre></p>
<p> 由上述的代码，可以看到，<code>EPollSelectorImpl</code>先调用<code>EPollArrayWapper</code>的<code>poll</code>方法,然后在更新<code>SelectedKeys</code>．其中<code>poll</code>方法会先调用<code>epollCtl</code>来注册先前在<code>register</code>方法中保存的Channel的fd和感兴趣的事件类型，然后<code>epollWait</code>方法等待感兴趣事件的生成,导致线程阻塞.</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">int poll(long timeout) throws IOException {
    updateRegistrations(); &#x2F;&#x2F;&#x2F;&#x2F;先调用epollCtl,更新关注的事件类型
    &#x2F;&#x2F;&#x2F;&#x2F;导致阻塞，等待事件产生
    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);
    .....
    return updated;
}
</code></pre>
<p>&emsp;等待关注的事件产生之后(或在等待时间超过预先设置的最大时间),<code>epollWait</code>函数就会返回.<code>select</code>函数从阻塞状态恢复.</p>
<h4 id="selectedKeys方法"><a href="#selectedKeys方法" class="headerlink" title="selectedKeys方法"></a>selectedKeys方法</h4><p>&emsp;我们先来看<code>SelectorImpl</code>中的<code>selectedKeys</code>方法.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;是通过Util.ungrowableSet生成的,不能添加,只能减少
private Set&lt;SelectionKey&gt; publicSelectedKeys;
public Set&lt;SelectionKey&gt; selectedKeys() {
    ....
    return publicSelectedKeys;
}
</code></pre></p>
<p>&emsp;很奇怪啊,怎麽直接就返回<code>publicSelectedKeys</code>了,难道在<code>select</code>函数的执行过程中有修改过这个变量吗?<br>&emsp;<code>publicSelectedKeys</code>这个对象其实是<code>selectedKeys</code>变量的一份副本,你可以在<code>SelectorImpl</code>的构造函数中找到它们俩的关系,我们再回头看一下<code>select</code>中<code>updateSelectedKeys</code>方法.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">private int updateSelectedKeys() {
    &#x2F;&#x2F;更新了的keys的个数,或在说是产生的事件的个数
    int entries = pollWrapper.updated; 
    int numKeysUpdated = 0;
    for (int i=0; i&lt;entries; i++) {
        &#x2F;&#x2F;对应的channel的fd
        int nextFD = pollWrapper.getDescriptor(i);
        &#x2F;&#x2F;通过fd找到对应的SelectionKey
        SelectionKeyImpl ski = fdToKey.get(Integer.valueOf(nextFD));
        if (ski != null) {
            int rOps = pollWrapper.getEventOps(i);
            &#x2F;&#x2F;更新selectedKey变量,并通知响应的channel来做响应的处理
            if (selectedKeys.contains(ski)) {
                if (ski.channel.translateAndSetReadyOps(rOps, ski)) {
                    numKeysUpdated++;
                }
            } else {
                ski.channel.translateAndSetReadyOps(rOps, ski);
                if ((ski.nioReadyOps() &amp; ski.nioInterestOps()) != 0) {
                    selectedKeys.add(ski);
                    numKeysUpdated++;
                }
            }
        }
    }
    return numKeysUpdated;
}
</code></pre></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;看到这里,详细大家都已经了解到了NIO的底层实现了吧.这里我想在说两个问题.<br>&emsp;一是为什么Netty自己又从新实现了一边native相关的NIO底层方法? 听听Netty的创始人是怎麽说的吧<a href="http://stackoverflow.com/questions/23465401/why-native-epoll-support-is-introduced-in-netty" target="_blank" rel="noopener">链接</a><br>&emsp;二是看这么多源码,花费这么多时间有什么作用呢?我感觉如果从非功利的角度来看,那么就是纯粹的希望了解的更多,有时候看完源码或在理解了底层原理之后,都会用一种恍然大悟的感觉,比如说<code>AQS</code>的原理.如果从目的性的角度来看,那么就是你知道底层原理之后,你的把握性就更强了,如果出了问题,你可以更快的找出来,并且解决.除此之外,你还可以按照具体的现实情况,以源码为模板在自己造轮子,实现一个更加符合你当前需求的版本.<br>&emsp;后续如果有时间,我希望好好了解一下epoll的操作系统级别的实现原理.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/dbc01bc2/" data-id="ckaubqb39002xgr66wrwd7sp8" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Netty源码-二-Netty的Channel和Pipeline" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/815dc153/">Netty源码(二):Netty的Channel和Pipeline</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/815dc153/">
            <time datetime="2017-03-27T13:38:03.000Z" itemprop="datePublished">2017-03-27</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Netty/">Netty</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Netty/">Netty</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 本文主要讲述Netty框架中Channel相关的知识，Netty通过Channel和Pipeline等一些组件提供了所谓的<code>Universal Communication API</code>．与<code>Channel</code>相关的知识点比较多，本篇文章就主要讲解一下<code>Channel</code>和<code>Pipeline</code>的事件处理流原理．<code>Channel</code>,<code>EventLoop</code>和<code>ChannelFuture</code>的相关知识下篇文章中再进行讲述．</p>
<h3 id="官方文档上的Channel"><a href="#官方文档上的Channel" class="headerlink" title="官方文档上的Channel"></a>官方文档上的Channel</h3><p> 官方文档上给出的解释是Channel是与网络Socket相关的或具有一定I/O能力的组件．一个<code>Channel</code>可以给用户提供:</p>
<ul>
<li>当前<code>Channel</code>的状态(比如，是否保存Open状态，是否处于连接状态)</li>
<li><code>Channel</code>的配置参数，比如说buffer的大小</li>
<li><code>Channel</code>支持的相关I/O操作，比如说<code>read</code>,<code>write</code>,<code>connect</code>和<code>bind</code></li>
<li>提供一个<code>ChannelPipeline</code>来处理所有与该<code>Channel</code>相关的I/O事件和请求</li>
</ul>
<p> <code>Channel</code>上进行的所有I/O操作都是异步的，也就是说，所有涉及I/O操作的调用都会立刻返回，并不保证操作完成，而是会返回一个<code>ChannelFuture</code>对象来通知你操作是否完成．<br> Channel是有层级的，这样的话，你就可以很方便的利用其他已有的Channel来构建自己需要的<code>channel</code>,比如说基于<code>SocketChannel</code>来实现关于<code>SSH</code>的<code>Channel</code></p>
<p> 此外，当你完成某些操作之后调用<code>close()</code>或在<code>close(ChannelPromise)</code>是非常重要的，这样能确保你正确的释放了所有资源．</p>
<h4 id="我眼中的Channel"><a href="#我眼中的Channel" class="headerlink" title="我眼中的Channel"></a>我眼中的Channel</h4><p> 首先，我们应该都知道Netty支持很多I/O通信协议:</p>
<ul>
<li>基于TCP的NIO: <code>NioServerSocketChannel</code>,<code>NioSocketChannel</code></li>
<li>基于UDP的NIO:<code>NioDatagramChannel</code></li>
<li>基于TCP的OIO:<code>OioSocketChannel</code>和<code>OioServerSocketChannel</code></li>
<li>基于UDP的OIO:<code>OioDatagramChannel</code><br>如果把关于Channel的类图列出来的话，你会发现支持各种协议的<code>Channel</code>,不信你就看一下这个类图．</li>
</ul>
<p> 这样想一下，<strong><em><code>Channel</code>不就是<code>Netty</code>框架用来封装不同协议逻辑的组件吗?</em></strong>，有了<code>Channel</code>的存在，所有于通信协议相关的逻辑都隐藏在不同的<code>Channel</code>实现里，然后在对外提供相对统一的API.<br> 说道这里，你可能还不知道，即使是<code>OIOChannel</code>,它提供的I/O操作也是异步的．也就是说<strong><em>在Netty框架中，不论是OIO还是NIO模型，读写都会阻塞</em></strong>．这样也体现了<code>Universal Communication API</code>的思想，这就使得我们切换Channel非常方便．我们只要初始化不同的Channel即可．<br><code>ServerBootstrap b = new ServerBootstrap(); 
            b.group(bossGroup, workerGroup)
             .channel(NioServerSocketChannel.class)
ServerBootstrap b = new ServerBootstrap(); 
            b.group(bossGroup, workerGroup)
             .channel(OioServerSocketChannel.class)</code><br> 有关<code>Channel</code>协议相关的底层知识，我们会在下一篇文章时进行介绍．</p>
<h3 id="ChannelHandler和ChannelPipeline"><a href="#ChannelHandler和ChannelPipeline" class="headerlink" title="ChannelHandler和ChannelPipeline"></a>ChannelHandler和ChannelPipeline</h3><p> 只有<code>Channel</code>的支持，还不足以实现<code>Universal Communication API</code>,还需要上述两个类来提供<code>ChannelHandler</code>的编程模式，基于<code>ChannelHandler</code>来开发业务逻辑，而不需要考虑网络通讯方面的事情．<br> Netty源码中一张图形象的描述了这个机制<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017327-netty-stream.png" alt="示意图"></p>
<p>&emsp;Netty中的<code>ChannelPipeline</code>包含两条线路：Upstream和<code>Downstream</code>．Upstream对应上行，接受信息，被动的状态改变，都属于Upstream．Downstream则对应下行，发送消息，主动状态的改变．Upstream对应InBound Handler,Downstream对应Outbound Handler.从Netty内部IO线程接读到IO数据，依次经过N个Handler到达最内部的逻辑处理单元，这种称之为Inbound Handler；从Channel发出IO请求，依次经过M个Handler到达Netty内部IO线程，这种称之为Outbound Handler<br>&emsp;需要注意的是，这个Handler链中消息或在事件不会自动的向下或在向上流动或转发，而是需要由上一个Handler显示的调用<code>ChannelPipeline.sendUp(down)stream</code>来交给下一个Handler来处理．也就是说，每个Handler接受到一个<code>ChannelEvent</code>,处理结束后，如果需要继续处理，那么它需要向下一个或在上一个Handler发起一个事件．</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/815dc153/" data-id="ckaubqb390031gr66xx23fbgg" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Netty源码-一-Netty中的Buffer" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/bf1a30e4/">Netty源码(一):Netty中的Buffer</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/bf1a30e4/">
            <time datetime="2017-03-22T15:09:21.000Z" itemprop="datePublished">2017-03-22</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Netty/">Netty</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Netty/">Netty</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 最近我学习了NIO相关的知识,然后发现了Netty这个基于NIO的网络应用框架,于是就研究起Netty框架源码,来好好体会一下网络框架的设计理念和思想.<br> 这个系列的文章不仅会总结Netty各个模块的源码原理,也会写出一些自己对这些设计的理解和体会.<br> 我基本按照并发编程网上<a href="http://ifeve.com/netty1/" target="_blank" rel="noopener">这个系列文章</a>的顺序来进行系列文章的顺序,不同的是我是基于Netty4.1的源码进行分析和讲解.<br> 为了节约你的时间,本篇文章主要内容如下:</p>
<ul>
<li>Netty的Buffer的内存模型,涉及读写指针</li>
<li>Netty的Buffer框架</li>
<li>Netty的Pool原理,轻量对象池</li>
</ul>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p> Java NIO中的Buffer用于和NIO通道进行交互,数据可以从通道读入缓冲区,也可以从缓冲区写入到通道中.所以说,Buffer其实就是一块可以读写数据的内存,我们将其包装为一个Java对象来提供一系列读写操作.<br> Netty并没有直接使用Java NIO的Buffer实现,而是自己实现了一套Buffer框架来满足自己的业务或者性能需求.</p>
<h3 id="ByteBuf的基本原理"><a href="#ByteBuf的基本原理" class="headerlink" title="ByteBuf的基本原理"></a>ByteBuf的基本原理</h3><h4 id="读写指针的作用"><a href="#读写指针的作用" class="headerlink" title="读写指针的作用"></a>读写指针的作用</h4><p> 不同于NIO Buffer的读写指针共用原理,ByteBuf拥有<code>readerIndex</code>,<code>writerIndex</code>两个指针.下面我们就来详细的讲解一下ByteBuf的内部原理.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">     +-------------------+------------------+------------------+
     | discardable bytes |  readable bytes  |  writable bytes  |
     |                   |     (CONTENT)    |                  |
     +-------------------+------------------+------------------+
     |                   |                  |                  |
     0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity
</code></pre></p>
<p> 从示意图中我们可以看出<code>readerIndex</code>和<code>writerIndex</code>最多可以将整个内容空间划分为三块:<code>废弃区</code>,<code>可读区</code>和<code>可写区</code>.下面我们就来看一下不同操作下的两个指针的变化.</p>
<ul>
<li><p>在初始化状态下,假设capacity为20,<code>readerIndex</code>和<code>writerIndex</code>都为0,整个空间中只存在可写区.此时只能写,不能读,进行读操作会抛出异常.</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">       +---------------------------------------------------------+
       |             writable bytes (got more space)             |
       +---------------------------------------------------------+
       |                                                         |
 readerIndex(0)
  writerIndex(0)                   &lt;=                   capacity
</code></pre>
</li>
<li><p>写入10个字节的数据,<code>writerIndex</code>指向10,<code>readerIndex</code>不会改变,所有内容空间中有可读区和可写区.大小都是10字节.</p>
</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">       +-------------------+------------------+------------------+
       |  readable bytes  |  writable bytes                      |
       |     (CONTENT)    |                                      |
       +--------- --------+------------------+------------------
       |                  |                                      |
     readerIndex(0) &lt;= writerIndex(10)           &lt;=        capacity
</code></pre>
<ul>
<li>读取5个字节的内容,<code>writerIndex</code>不变,<code>readerIndex</code>加5,指向了5.此时内容空间分为了5字节的废弃区,5字节的可读区和10字节的可写区.</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">
 +-------------------+------------------+------------------+
 | discardable bytes |  readable bytes  |  writable bytes  |
 |                   |     (CONTENT)    |                  |
 +-------------------+------------------+------------------+
 |                   |                  |                  |
 0      &lt;=      readerIndex(5)   &lt;=   writerIndex(10)    &lt;=  capacity
</code></pre>
<ul>
<li>调用<code>discardReadBytes</code>方法后,将废弃区的内容舍弃掉,<code>readerIndex</code>又指向了0,<code>writerIndex</code>指向了5,相当于可读区和可写区整体向左平移了5个字节.
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">       +------------------+--------------------------------------+
       |  readable bytes  |    writable bytes (got more space)   |
       +------------------+--------------------------------------+
       |                  |                                      |
  readerIndex (0) &lt;= writerIndex (5)              &lt;=        capacity
</code></pre>
</li>
</ul>
<h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p> OS层次上<code>Zero-copy</code>,就是在操作数据时,不需要将数据buffer从一个内存区域拷贝到另一个内存区域,因为减少了一次内存的拷贝,因此CPU的效率得到了提升.<br> <code>Netty</code>的<code>zero-copy</code>体现在很多方面.比如Buffer的compose,duplicate,slice操作时不会拷贝底层的数据.而是通过ByteBuf对象的组合来实现上述的操作</p>
<ul>
<li><p>Netty提供了<code>CompositeByteBuf</code>类,可以将多个<code>ByteBuf</code>组合成一个逻辑上的Buffer,避免了各个buffer之间的拷贝,<code>CompositeByteBuf</code>并不拥有底层的数据,而是通过拥有两个buffer对象,从这两个buffer对象中获取数据来对外提供看似合并了的数据.比如我们将一份协议数据的头部buffer和消息体buffer合并成一个Buffer.<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017322-netty-compose.png" alt="compose"><br> 如上图所示,所有底层的数据还是存储在header和body这两个真实的buffer中.</p>
</li>
<li><p>对于<code>ByteBuf</code>的<code>slice</code>和<code>duplicate</code>操作也是如此,不同的buffer共享了相同的底层数据,而不是进行底层数据的拷贝.具体使用到的Buffer类型为<code>DuplicatedByteBuf</code>和<code>SlicedByteBuf</code>.谁说是共享的底层数据,但是通过对<code>writerIndex</code>和<code>readerIndex</code>两个指针的操作来实现slice和duplicate的功能.</p>
</li>
<li>Netty使用<code>wrap</code>操作将byte数组转化为<code>ByteBuf</code>对象时,将byte数组包裹到对象中,而不是拷贝数组存放到对象中.</li>
<li>Netty 中使用 FileRegion 实现文件传输的零拷贝, 不过在底层 FileRegion 是依赖于 Java NIO FileChannel.transfer 的零拷贝功能.</li>
</ul>
<h3 id="Pool和Reference-Count"><a href="#Pool和Reference-Count" class="headerlink" title="Pool和Reference Count"></a>Pool和Reference Count</h3><p> 4.0之后的版本实现了高性能的Buffer池,分配策略则是结合了buddy allocation和slab allocation的jemalloc变种，实现类为<code>PoolArena</code>,这样的话,可以在频繁分配和释放Buffer时缓解GC压力,还可以在初始化新buffer时减少内存带宽消耗（初始化时不可避免的要给buffer数组赋初始值).<br> <code>ByteBuf</code>引入了<code>Reference Count</code>机制,你需要在不适用它的时候调用<code>ReferenceCountUtil.release</code>方法来减少它的引用.</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;感觉自己在研究或在阅读源代码时还是有些问题,起始<code>ByteBuf</code>并不是<code>Netty</code>的关键所在,不应该花费这么长时间.以后还是要带着目的来看源码,不能把时间浪费在一些代码细节上.</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><a href="https://segmentfault.com/a/1190000007560884" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007560884</a></li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/bf1a30e4/" data-id="ckaubqb37002ugr66glma11ke" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/5a35e6d9/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/article/5a35e6d9/" class="title">MySQL死锁系列-加锁场景分析</a></p>
                            <p class="item-date"><time datetime="2020-05-21T14:25:30.000Z" itemprop="datePublished">2020-05-21</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/e3e7a535/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/article/e3e7a535/" class="title">带你100% 地了解 Redis 6.0 的客户端缓存</a></p>
                            <p class="item-date"><time datetime="2020-05-10T14:04:45.000Z" itemprop="datePublished">2020-05-10</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/a94bd30a/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/article/a94bd30a/" class="title">MySQL的死锁系列- 锁的类型以及加锁原理</a></p>
                            <p class="item-date"><time datetime="2020-03-31T14:06:26.000Z" itemprop="datePublished">2020-03-31</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/d5009955/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/java-persistent/">java persistent</a></p>
                            <p class="item-title"><a href="/article/d5009955/" class="title">Java 数据持久化系列之池化技术</a></p>
                            <p class="item-date"><time datetime="2020-02-02T13:48:17.000Z" itemprop="datePublished">2020-02-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/75dc863d/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/plan/">plan</a></p>
                            <p class="item-title"><a href="/article/75dc863d/" class="title">2020年，计划目录</a></p>
                            <p class="item-date"><time datetime="2020-01-27T05:00:09.000Z" itemprop="datePublished">2020-01-27</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SICP/">SICP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-persistent/">java persistent</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/plan/">plan</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计/">设计</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">3</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Animation/" style="font-size: 10px;">Animation</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GSON/" style="font-size: 10px;">GSON</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/JUC/" style="font-size: 20px;">JUC</a> <a href="/tags/Jenkins/" style="font-size: 10px;">Jenkins</a> <a href="/tags/Material-Design/" style="font-size: 10px;">Material Design</a> <a href="/tags/MotionEvent/" style="font-size: 10px;">MotionEvent</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 20px;">Netty</a> <a href="/tags/OkHttp/" style="font-size: 15px;">OkHttp</a> <a href="/tags/Raft/" style="font-size: 10px;">Raft</a> <a href="/tags/React-Native/" style="font-size: 10px;">React Native</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/SICP/" style="font-size: 10px;">SICP</a> <a href="/tags/Shader/" style="font-size: 10px;">Shader</a> <a href="/tags/Span/" style="font-size: 15px;">Span</a> <a href="/tags/Spring-Boot/" style="font-size: 15px;">Spring Boot</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/TCP-IP/" style="font-size: 20px;">TCP/IP</a> <a href="/tags/View/" style="font-size: 15px;">View</a> <a href="/tags/View-Architecture/" style="font-size: 10px;">View Architecture</a> <a href="/tags/ViewRoot/" style="font-size: 10px;">ViewRoot</a> <a href="/tags/Window机制/" style="font-size: 10px;">Window机制</a> <a href="/tags/animation/" style="font-size: 10px;">animation</a> <a href="/tags/cas/" style="font-size: 10px;">cas</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/draw/" style="font-size: 10px;">draw</a> <a href="/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/tags/filesystem/" style="font-size: 10px;">filesystem</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/kubernetes/" style="font-size: 10px;">kubernetes</a> <a href="/tags/persistent/" style="font-size: 15px;">persistent</a> <a href="/tags/redis/" style="font-size: 20px;">redis</a> <a href="/tags/scroll/" style="font-size: 15px;">scroll</a> <a href="/tags/spring-cloud/" style="font-size: 10px;">spring-cloud</a> <a href="/tags/事件传递/" style="font-size: 15px;">事件传递</a> <a href="/tags/依赖注入/" style="font-size: 10px;">依赖注入</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/动态编程/" style="font-size: 10px;">动态编程</a> <a href="/tags/反射/" style="font-size: 10px;">反射</a> <a href="/tags/图像处理/" style="font-size: 10px;">图像处理</a> <a href="/tags/实习/" style="font-size: 10px;">实习</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/工具-Linux/" style="font-size: 10px;">工具, Linux</a> <a href="/tags/市场/" style="font-size: 10px;">市场</a> <a href="/tags/并发/" style="font-size: 10px;">并发</a> <a href="/tags/思维/" style="font-size: 10px;">思维</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/文件系统/" style="font-size: 10px;">文件系统</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/注解/" style="font-size: 20px;">注解</a> <a href="/tags/第三方库/" style="font-size: 15px;">第三方库</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a> <a href="/tags/贪婪算法/" style="font-size: 10px;">贪婪算法</a> <a href="/tags/软件设计/" style="font-size: 10px;">软件设计</a> <a href="/tags/锁/" style="font-size: 10px;">锁</a> <a href="/tags/限流/" style="font-size: 15px;">限流</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://www.blueskykong.com/">aoho blog</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2020 历小冰<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
    <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
    // <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    // <script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.1.6/dist/Valine.min.js"></script>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            app_id: 'Py2W9ndz8WJGDduj0id77Yq7-gzGzoHsz',
            app_key: 'cTJCvL6VOQL5ozXfABqDbAyP',
            placeholder: '欢迎大家积极留言交流'
        })
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
    



<link rel="stylesheet" href="/css/prism.css">
<script type="text/javascript" src="/js/prism.js"></script>
<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>