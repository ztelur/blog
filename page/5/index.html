<!DOCTYPE html>
<html lang="Ch">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>程序员历小冰</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta property="og:type" content="website">
<meta property="og:title" content="程序员历小冰">
<meta property="og:url" content="http://remcarpediem.net/page/5/index.html">
<meta property="og:site_name" content="程序员历小冰">
<meta property="og:locale" content="Chinese">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员历小冰">
    

    
        <link rel="alternate" href="/atom.xml" title="程序员历小冰" type="application/atom+xml">
    

    
        <link rel="icon" href="/css/images/avatar.jpeg">
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
    
    
    
        
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f089a91a688633df563c08899e3d893e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    


<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">程序员历小冰</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">主页</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/book">读书</a>
                
                    <a class="main-nav-link" href="/categories/plan">计划</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.jpeg">
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">主页</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/book">读书</a></td>
                
                    <td><a class="main-nav-link" href="/categories/plan">计划</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile" class="profile-fixed">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.jpeg">
            <h2 id="name">历小冰</h2>
            <h3 id="title">后端开发工程师</h3>
            <span id="location"><i class="fa fa-map-marker"></i>中国，南京</span>
            <img id="wechat" src="/css/images/wechat_public.jpg">
            <a id="follow" target="_blank" href="/css/images/wechat_public.jpg">⬆关注公众号⬆</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                90
                <span>posts</span>
            </div>
            <div class="article-info-block">
                61
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/ztelur" target="_blank" title="github" class="tooltip">
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/css/images/wechat.jpeg" target="_blank" title="wechat" class="tooltip">
                            <i class="fa fa-wechat"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/atom.xml" target="_blank" title="rss" class="tooltip">
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-BlockingQueue与Condition原理解析" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/815f6f66/">BlockingQueue与Condition原理解析</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/815f6f66/">
            <time datetime="2017-05-03T02:07:45.000Z" itemprop="datePublished">2017-05-03</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/并发/">并发</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JUC/">JUC</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 我在前段时间写了一篇关于AQS的<a href="http://remcarpediem.com/2017/04/06/AbstractQueuedSynchronizer%E8%B6%85%E8%AF%A6%E7%BB%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">文章</a>，在文章里边我说几乎所有在<code>JUC</code>包中的所有多线程相关的类都和<code>AQS</code>相关，今天我就在这里总结一下另一个依赖于<code>AQS</code>来实现的同步工具类：<code>BlockingQueue</code>。我们主要以<code>ArrayBlockingQueue</code>为主来分析相关的源码。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p> 相信大多数同学都是在学习线程池相关知识时了解到阻塞队列的概念的。知道各种类型的阻塞队列对线程池初始化时的影响。在java doc中这样定义阻塞队列。当从阻塞队列获取元素但是队列为空时，当前线程会阻塞直到另一个线程向阻塞队列中添加一个元素；类似的，当向一个阻塞队列加入元素时，如果队列已经满了，当前线程也会阻塞知道另外一个线程从队列中读取一个元素。阻塞队列一般都是FIFO,用来实现生产者和消费者模式。阻塞队列的方法通过四种不同的方式来处理操作无法被立即完成的情况，这四种情况分别为抛出异常，返回特殊值(null或在是false),阻塞当前线程直到执行结束，最后一种是只阻塞固定时间，然后还未执行成功就放弃操作。这些方法都总结在下边这种表中了。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-condition-BlockingQueue.png" alt="BlockingQueue"></p>
<p> 我们就只分析<code>put</code>和<code>take</code>方法。</p>
<h3 id="put和take函数"><a href="#put和take函数" class="headerlink" title="put和take函数"></a>put和take函数</h3><p> 我们都知道，使用同步队列可以很轻松的实现生产者-消费者模式，其实，同步队列就是按照生产者-消费者的模式来实现的，我们可以将<code>put</code>函数看作生产者的操作，<code>take</code>是消费者的操作。<br> <code>put</code>函数会在队列末尾添加元素，如果队列已经满了，无法添加元素的话，就一直阻塞等待到可以加入为止。函数的源码如下所示。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">    public void put(E e) throws InterruptedException {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly(); &#x2F;&#x2F;先获得锁
        try {
            while (count == items.length) 
            &#x2F;&#x2F;如果队列满了，就NotFull这个condition对象上进行等待
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
    private void enqueue(E x) {
        final Object[] items = this.items;
        items[putIndex] = x;
        &#x2F;&#x2F;这里可以注意的是ArrayBlockingList实际上使用Array实现了一个环形数组，
       &#x2F;&#x2F;当putIndex达到最大时，就返回到起点，继续插入,
       &#x2F;&#x2F;当然，如果此时0位置的元素还没有被取走，
       &#x2F;&#x2F;下次put时，就会因为cout == item.length未被阻塞。
        if (++putIndex == items.length)
            putIndex = 0;
        count++;
        &#x2F;&#x2F;因为插入了元素，通知等待notEmpty事件的线程。
        notEmpty.signal();
    }
</code></pre></p>
<p> 我们会发现put函数也是使用了wait/notify的机制。与一般生产者-消费者的实现方式不同，同步队列使用<code>ReentrantLock</code>和<code>Condition</code>相结合的先获得锁，再等待的机制；而不是<code>synchronized</code>和<code>Object.wait</code>的机制。这里的区别我们下一节再详细讲解。<br> 看完了生产者相关的<code>put</code>函数，我们再来看一下消费者调用的<code>take</code>函数。<code>take</code>函数在队列为空时会被阻塞，一直到阻塞队列加入了新的元素。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">    public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0)
            &#x2F;&#x2F;如果队列为空，那么在notEmpty对象上等待，
            &#x2F;&#x2F;当put函数调用时，会调用notEmpty的notify进行通知。
                notEmpty.await();
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
    private E dequeue() {
        E x = (E) items[takeIndex];
        items[takeIndex] = null; &#x2F;&#x2F;取出takeIndex位置的元素
        if (++takeIndex == items.length)
            &#x2F;&#x2F;如果到了尾部，将指针重新调整到头部
            takeIndex = 0;
        count--;
        ....
        &#x2F;&#x2F;通知notFull对象上等待的线程
        notFull.signal();
        return x;
    }
</code></pre></p>
<h3 id="Condition-await和Object-wait"><a href="#Condition-await和Object-wait" class="headerlink" title="Condition.await和Object.wait"></a>Condition.await和Object.wait</h3><p> 我们发现<code>ArrayBlockingList</code>并没有使用<code>Object.wait</code>，而是使用的<code>Condition.await</code>，这是为什么呢？其中又有哪些原因呢？<br> <code>Condition</code>对象可以提供和<code>Object</code>的<code>wait</code>和<code>notify</code>一样的行为，但是后者必须使用<code>synchronized</code>这个内置的monitor锁，而<code>Condition</code>使用的是<code>RenentranceLock</code>。这两种方式在阻塞等待时都会将相应的锁释放掉，但是<code>Condition</code>的等待可以中断，这是二者唯一的区别。<br>＆emsp;Condition的流程大致如下边两张图所示.</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-condition-condition1.png" alt="await"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-condition-condition2.png" alt="notify"></p>
<p> 我们首先来看一下<code>await</code>函数的实现，详细的讲解都在代码中．</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    &#x2F;&#x2F;在condition wait队列上添加新的节点
    Node node = addConditionWaiter();
    &#x2F;&#x2F;释放当前持有的锁
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    &#x2F;&#x2F;由于node在之前是添加到condition wait queue上的，现在判断这个node
    &#x2F;&#x2F;是否被添加到Sync的获得锁的等待队列上。
    &#x2F;&#x2F;node在condition queue上说明还在等待事件的notify,
    &#x2F;&#x2F;notify函数会将condition queue 上的node转化到Sync的队列上。
    while (!isOnSyncQueue(node)) {
        &#x2F;&#x2F;node还没有被添加到Sync Queue上，说明还在等待事件通知
        &#x2F;&#x2F;所以调用park函数来停止线程执行
        LockSupport.park(this);
        &#x2F;&#x2F;判断是否被中断,线程从park函数返回有两种情况，一种是
        &#x2F;&#x2F;其他线程调用了unpark,另外一种是线程被中断
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    &#x2F;&#x2F;代码执行到这里，已经有其他线程调用notify函数，或则被中断，该线程可以继续执行，但是必须先
    &#x2F;&#x2F;再次获得调用await函数时的锁．acquireQueued函数在AQS文章中做了介绍．
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
  　．．．．
}

final int fullyRelease(Node node) {
    &#x2F;&#x2F;AQS的方法，当前已经在锁中了，所以直接操作
    boolean failed = true;
    try {
        int savedState = getState();
        &#x2F;&#x2F;获取state当前的值，然后保存，以待以后恢复
        if (release(savedState)) {
            failed = false;
            return savedState;
        } else {
            throw new IllegalMonitorStateException();
        }
    } finally {
        if (failed)
            node.waitStatus = Node.CANCELLED;
    }
}

&#x2F;**
 * Checks for interrupt, returning THROW_IE if interrupted
 * before signalled, REINTERRUPT if after signalled, or
 * 0 if not interrupted.
 *&#x2F;
private int checkInterruptWhileWaiting(Node node) {
    &#x2F;&#x2F;中断可能发生在两个阶段中，一是在等待singla,另外一个是在获得signal之后
    return Thread.interrupted() ?
        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
        0;
}

final boolean transferAfterCancelledWait(Node node) {
    &#x2F;&#x2F;这里要和下边的transferForSignal对应着看，这是线程中断进入的逻辑．那边是signal的逻辑
    &#x2F;&#x2F;两边可能有并发冲突，但是成功的一方必须调用enq来进入acquire lock queue中．
    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
        enq(node);
        return true;
    }
    &#x2F;&#x2F;如果失败了，说明transferForSignal那边成功了，等待node 进入acquire lock queue
    while (!isOnSyncQueue(node))
        Thread.yield();
    return false;
}
</code></pre>
<p> <code>signal</code>函数将等待事件最长时间的线程节点从等待condition的队列移动到获得lock的等待队列中．<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public final void signal() {
    &#x2F;&#x2F;
    if (!isHeldExclusively())
    &#x2F;&#x2F;如果当前线程没有获得锁，抛出异常
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        &#x2F;&#x2F;将Condition wait queue中的第一个node转移到acquire lock queue中．
        doSignal(first);
}

private void doSignal(Node first) {
    do {
　　 &#x2F;&#x2F;由于生产者的signal在有消费者等待的情况下，必须要通知
        &#x2F;&#x2F;一个消费者，所以这里有一个循环，直到队列为空
        &#x2F;&#x2F;把first 这个node从condition queue中删除掉
        &#x2F;&#x2F;condition queue的头指针指向node的后继节点，如果node后续节点为null,那么也将尾指针也置为null
        if ( (firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &amp;&amp;
             (first = firstWaiter) != null);
    &#x2F;&#x2F;transferForSignal将node转而添加到Sync的acquire lock 队列
}

final boolean transferForSignal(Node node) {
    &#x2F;&#x2F;如果设置失败，说明该node已经被取消了,所以返回false,让doSignal继续向下通知其他未被取消的node
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;
    &#x2F;&#x2F;将node添加到acquire lock　queue中．
    Node p = enq(node);
    int ws = p.waitStatus;
    &#x2F;&#x2F;需要注意的是这里的node进行了转化
    &#x2F;&#x2F;ws&gt;0代表canceled的含义所以直接unpark线程
    &#x2F;&#x2F;如果compareAndSetWaitStatus失败，所以直接unpark,让线程继续执行await中的
    &#x2F;&#x2F;进行isOnSyncQueue判断的while循环,然后进入acquireQueue函数．
    &#x2F;&#x2F;这里失败的原因可能是Lock其他线程释放掉了锁，同步设置p的waitStatus
    &#x2F;&#x2F;如果compareAndSetWaitStatus成功了呢？那么该node就一直在acquire lock queue中
    &#x2F;&#x2F;等待锁被释放掉再次抢夺锁，然后再unparｋ
    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
</code></pre></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;后边一篇文章主要讲解如何自己使用<code>AQS</code>来创建符合自己业务需求的锁，请大家继续关注我的文章啦．一起进步偶．</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/815f6f66/" data-id="ck7kgwyi8001irasenpmmx51y" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-LongAdder解析" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/d29e90d8/">LongAdder解析</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/d29e90d8/">
            <time datetime="2017-04-21T14:38:05.000Z" itemprop="datePublished">2017-04-21</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/并发/">并发</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JUC/">JUC</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>＆emsp;对<code>LongAdder</code>的最初了解是从Coolshell上的一篇文章中获得的，但是一直都没有深入的了解过其实现，只知道它相较于<code>AtomicLong</code>来说，更加适合读多写少的并发情景。今天，我们就研究一下<code>LongAdder</code>的原理，探究一下它如此高效的原因。</p>
<h3 id="基本原理和思想"><a href="#基本原理和思想" class="headerlink" title="基本原理和思想"></a>基本原理和思想</h3><p> 我们都知道<code>AtomicLong</code>是通过无限循环不停的采取CAS的方法去设置value，直到成功为止。那么当并发数比较多或出现更新热点时，就会导致CAS的失败机率变高，重试次数更多，越多的线程重试，CAS失败的机率越高，形成恶性循环，从而降低了效率。而LongAdder的原理就是降低对value更新的并发数，也就是将对单一value的变更压力分散到多个value值上，降低单个value的“热度”<br> 我们知道<code>LongAdder</code>的大致原理之后，再来详细的了解一下它的具体实现，其中也有很多值得借鉴的并发编程的技巧。</p>
<h3 id="Add操作"><a href="#Add操作" class="headerlink" title="Add操作"></a>Add操作</h3>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public void add(long x) {
    Cell[] as; long b, v; int m; Cell a;
    if ((as = cells) != null || !casBase(b = base, b + x)) { &#x2F;&#x2F;step1
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) &lt; 0 || &#x2F;&#x2F;step2
            (a = as[getProbe() &amp; m]) == null ||  &#x2F;&#x2F;step3
            !(uncontended = a.cas(v = a.value, v + x))) &#x2F;&#x2F;step4
            longAccumulate(x, null, uncontended); &#x2F;&#x2F; step5
    }
}
</code></pre>
<p> <code>cells</code>是<code>LongAdder</code>的父类<code>Striped64</code>中的<code>Cell</code>数组类型的成员变量。每个<code>Cell</code>对象中都包含一个value值，并提供对这个value值的CAS操作。<br> 我们来看一下<code>casBase</code>函数相关的源码吧。我们可以认为变量<code>base</code>就是第一个value值，也是基础value变量。先调用casBase函数来cas一下base变量，如果成功了，就不需要在进行下面比较复杂的算法，<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">    final boolean casBase(long cmp, long val) {
        return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);
    }
</code></pre></p>
<p> 然后我们继续看step2第二层条件语句中执行的逻辑。如果cells数组为null或为空,就直接调用<code>longAccumulate</code>方法。因为cells为null或在为空，说明cells未完全初始化，所以调用<code>longAccumulate</code>进行初始化。否则继续判断。<br> 如果cells中已经有对象了，那么执行step3。我们先来理解一下<code>getProbe() &amp; m</code>的这个操作吧。我们可以首先将这个操作当作一次计算”hash”值,然后将cells中这个位置的Cell对象赋值给变量a。然后判断a是否为null,如果不为null,那么就调用Cell对象自己的cas方法去设置value值。如果a为null,或在cas赋值发生冲突，那么也是开始调用<code>longAccumulate</code>方法。</p>
<h3 id="LongAccumulate方法"><a href="#LongAccumulate方法" class="headerlink" title="LongAccumulate方法"></a>LongAccumulate方法</h3><p> <code>longAccumulate</code>函数比较复杂，带有我的注释的代码已经贴在了文章后边，这里我们就只讲一下其中比较关键的一些技巧和思想．<br> 首先，我们都知道只有当对<code>base</code>的cas操作失败之后，<code>LongAdder</code>才引入<code>Cell</code>数组．所以在<code>longAccumulate</code>中就是对<code>Cell</code>数组进行操作．分别涉及了数组的初始化，扩容和设置某个位置的Cell对象等操作．<br> 在这段代码中，关于cellBusy的cas操作构成了一个SpinLock,这就是经典的SpinLock的编程技巧，大家可以学习一下．</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">final void longAccumulate(long x, LongBinaryOperator fn,
                             boolean wasUncontended) {
       int h;
       if ((h = getProbe()) == 0) { &#x2F;&#x2F;获取PROBE变量，探针变量，与当前运行的线程相关，不同线程不同
           ThreadLocalRandom.current(); &#x2F;&#x2F;初始化PROBE变量，和getProbe都使用Unsafe类提供的原子性操作。
           h = getProbe();
           wasUncontended = true;
       }
       boolean collide = false;
       for (;;) { &#x2F;&#x2F;cas经典无限循环，不断尝试
           Cell[] as; Cell a; int n; long v;
           if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) { &#x2F;&#x2F; cells不为null,并且数组size大于0
           &#x2F;&#x2F;表示cells已经初始化了
               if ((a = as[(n - 1) &amp; h]) == null) { &#x2F;&#x2F;通过与操作计算出来需要操作的Cell对象的坐标
                   if (cellsBusy == 0) { &#x2F;&#x2F;volatile 变量，用来实现spinLock,来在初始化和resize cells数组时使用。
                   &#x2F;&#x2F;当cellsBusy为0时，表示当前可以对cells数组进行操作。 
                       Cell r = new Cell(x);&#x2F;&#x2F;将x值直接赋值给Cell对象
                       if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {&#x2F;&#x2F;如果这个时候cellsBusy还是0
                       &#x2F;&#x2F;就cas将其设置为非０，如果成功了就是获得了spinLock的锁．可以对cells数组进行操作．
                       &#x2F;&#x2F;如果失败了，就会再次执行一次循环
                           boolean created = false;
                           try {
                               Cell[] rs; int m, j;
                               &#x2F;&#x2F;判断cells是否已经初始化，并且要操作的位置上没有cell对象．
                               if ((rs = cells) != null &amp;&amp;
                                   (m = rs.length) &gt; 0 &amp;&amp;
                                   rs[j = (m - 1) &amp; h] == null) {
                                   rs[j] = r;　&#x2F;&#x2F;将之前创建的值为x的cell对象赋值到cells数组的响应位置．
                                   created = true;
                               }
                           } finally {
                               &#x2F;&#x2F;经典的spinLock编程技巧，先获得锁，然后try finally将锁释放掉
                               &#x2F;&#x2F;将cellBusy设置为0就是释放锁．
                               cellsBusy = 0;
                           }
                           if (created)
                               break;　&#x2F;&#x2F;如果创建成功了，就是使用x创建了新的cell对象，也就是新创建了一个分担热点的value
                           continue; 
                       }
                   }
                   collide = false; &#x2F;&#x2F;未发生碰撞
               }
               else if (!wasUncontended)&#x2F;&#x2F;是否已经发生过一次cas操作失败
                   wasUncontended = true; &#x2F;&#x2F;设置成true,以便第二次进入下一个else if 判断
               else if (a.cas(v = a.value, ((fn == null) ? v + x :
                                            fn.applyAsLong(v, x))))
                  　&#x2F;&#x2F;fn是操作类型，如果是空，就是相加，所以让a这个cell对象中的value值和x相加，然后在cas设置，如果成果
                  &#x2F;&#x2F;就直接返回
                   break;
               else if (n &gt;= NCPU || cells != as)
               　　&#x2F;&#x2F;如果cells数组的大小大于系统的可获得处理器数量或在as不再和cells相等．
                   collide = false;            &#x2F;&#x2F; At max size or stale
               else if (!collide)
                   collide = true;
               else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {
               　　&#x2F;&#x2F;再次获得cellsBusy这个spinLock,对数组进行resize
                   try {
                       if (cells == as) {&#x2F;&#x2F;要再次检测as是否等于cells以免其他线程已经对cells进行了操作．
                           Cell[] rs = new Cell[n &lt;&lt; 1]; &#x2F;&#x2F;扩容一倍
                           for (int i = 0; i &lt; n; ++i)
                               rs[i] = as[i];
                           cells = rs;&#x2F;&#x2F;赋予cells一个新的数组对象
                       }
                   } finally {
                       cellsBusy = 0;
                   }
                   collide = false;
                   continue;
               }
               h = advanceProbe(h);&#x2F;&#x2F;由于使用当前探针变量无法操作成功，所以重新设置一个,再次尝试
           }
           else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) {
           &#x2F;&#x2F;cells数组未初始化，获得cellsBusy　lock,来初始化
               boolean init = false;
               try {                           &#x2F;&#x2F; Initialize table
                   if (cells == as) {
                       Cell[] rs = new Cell[2];
                       rs[h &amp; 1] = new Cell(x); &#x2F;&#x2F;设置x的值为cell对象的value值
                       cells = rs;
                       init = true;
                   }
               } finally {
                   cellsBusy = 0;
               }
               if (init)
                   break;
           }&#x2F;&#x2F;如果初始化数组失败了，那就再次尝试一下直接cas base变量，如果成功了就直接返回
           else if (casBase(v = base, ((fn == null) ? v + x :
                                       fn.applyAsLong(v, x))))
               break;                          &#x2F;&#x2F; Fall back on using base
       }
   }
</code></pre>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;本篇文章写的不是很好，我写完之后又看了一遍coolshell上的这篇关于<code>LongAdder</code>的<a href="http://coolshell.cn/articles/11454.html" target="_blank" rel="noopener">文章</a>，感觉自己没有人家写的那么简介明了。我对代码细节的注释和投入太多了。其实很多代码大家都可以看懂，并不需要大量的代码片段加注释。以后要注意一下。之后会接着研究一下JUC包中的其他类，希望大家多多关注。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/d29e90d8/" data-id="ck7kgwyio002grasese69c8fe" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-分布式一致性算法Paxos" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/5635585c/">分布式一致性算法Paxos</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/5635585c/">
            <time datetime="2017-04-16T06:42:35.000Z" itemprop="datePublished">2017-04-16</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/分布式/">分布式</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/算法/">算法</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 最近在学习zookeeper原理的时候了解到了paxos算法,看了几篇文章之后还是感觉有些迷糊,后来看了知行学社的<a href="http://www.tudou.com/programs/view/e8zM8dAL6hM/" target="_blank" rel="noopener">paxos视频</a>才对这个算法有了一定的了解,这里就做一下总结.</p>
<h3 id="Paxos简介"><a href="#Paxos简介" class="headerlink" title="Paxos简介"></a>Paxos简介</h3><p> Paxos是Lamport于1990年提出的一种基于消息传递而具有高度容错特性的分布式一致性算法.这个算法是分布式中最为重要的算法,Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法,那就是Paxos,其他算法都是残次品.具体Paxos算法的详细内涵和故事背景大家可以参考知乎上的<a href="https://www.zhihu.com/question/19787937" target="_blank" rel="noopener">回答</a>;</p>
<h3 id="Paxos的使用场景和假设"><a href="#Paxos的使用场景和假设" class="headerlink" title="Paxos的使用场景和假设"></a>Paxos的使用场景和假设</h3><p> 我们都知道基于消息传递通信模型的分布式系列,不可避免的会发生以下错误:进程可能会慢,被杀死或在重启,消息可能会有延迟,丢失和重复.Paxos算法解决的问题就是在一个可能发生上述异常的分布式系统中如何就某个值达成一致,保证无论发生以上任何异常,都不会破坏决议的一致性。但是Paxos算法也有一定的使用假设。一个假设是在消息传递的过程中不会出现拜占庭将军问题：即虽然有可能一个消息被传递两次，但是绝对不会出现错误的消息。另一个假设是提议不会被反对，只能被同意或在被更新的提议替换。<br> Paxos协议中有三种角色，每个节点可以扮演多个角色：</p>
<ul>
<li>倡议者(Proposer):提议者可以提出提议(数值或在操作命令)以供投票表决。</li>
<li>接受者(Acceptor):接受者可以对提议者提出的提议进行投票表决，提议有超过半数的接收者投票即被选中。</li>
<li>学习者(Learner):学习者无投票者，只是从接收者那里获取哪个提议被选中。</li>
</ul>
<p> 在Paxos算法中，一个或在多个Proposer都可以并发的提出提议；系统必须针对所有提议中的某个提议达成一致（超过半数大的接受者选中）；最多只能对一个确定的提议达成一致；只要超过半数的节点存活且可以互相通信，整个系统一定可以达成一致，即选择一个确定的提议。<br> 如果直接讲解Paxos算法，大家可能会有些难以理解，这里我们就按着视频里的顺序，先从简单的分布式一致性算法开始，然后不断进行优化，最后将其演变成Paxos算法。</p>
<h3 id="图解Paxos主要流程"><a href="#图解Paxos主要流程" class="headerlink" title="图解Paxos主要流程"></a>图解Paxos主要流程</h3><p> Paxoso算法分为两个的阶段，我们就将其分别记为Phase1和Phase2.每个Proposer都持有一个独有的变量epoch,每个Acceptor都保存三个状态：lastest_prepared__epoch,accepted_epoch和accepted_value.lastest_prepared_epoch是指Acceptor授予访问权的Proposer的epoch值，accepted_epoch是Acceptor接受提议的Proposer的epoch值，而accepted_value就是Acceptor接受的提议值喽，他们的初始值都为null。</p>
<h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><p> Phase1过程中，Proposer向Acceptor发起<code>Prepare(epoch)</code>请求来获取访问权。将自己的epoch发送给Acceptor.而Acceptor只会接受比lastest_prepared_epoch更大的epoch,并给予访问权，并将epoch记录到lastest_prepared_epoch的值中，返回当前的accepted_epoch和accepted_value的值。在初始化状态下，二者都是null,所以返回的是<null,null>。如果epoch小于lastest_prepared_epoch则不授予访问权，并返回<error>。<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-paxos-paxos1.png" alt="phase1"><br> 如上图所示，Proposer1向5个Acceptor发送了Prepare(#1)的请求，其中前三个请求顺利到达，Acceptor授予访问权，返回<null,null>，并修改lastest_prepared_epoch为1。而后两个请求发生了网络延迟,一直未到达相应的Acceptor。<br> 在阶段一中，Proposer需要获得半数以上的Acceptor的访问权和对应的一组value的取值才会进行第二阶段，这样才会确保，一个Proposer提出的确定的议案会被另外一个Proposer发现，从而在阶段二中会进行正确的操作。</null,null></error></null,null></p>
<h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><p> 第二阶段采取“后者认同前者”的原则进行。在肯定旧epoch无法生成确定性取值时，新的epoch会提交自己的取值，不会冲突；一旦旧epoch形成了确定性取值，那么该proposer一定可以获得该取值，并且会认同该取值，不会破坏。<br> 如果Proposer在第一阶段获取的value值都是null,则旧epoch无法形成确定性取值，此时让自己的<epoch,v>成为确定性取值：</epoch,v></p>
<ul>
<li>向epoch对应的所有acceptor提交取值<epoch,v></epoch,v></li>
<li>如果收到半数以上的成功应答，则返回<ok,v></ok,v></li>
<li>否则返回<error></error></li>
</ul>
<p> 如果value的取值不为null,则认同最大accepted_epoch对应的取值f,使<epoch，f>成为确定性取值，其中epoch是自己的epoch.</epoch，f></p>
<ul>
<li>如果f出现半数以上，则说明f已经是确定性取值了，直接返回<ok,f></ok,f></li>
<li>否则，向epoch所对应的acceptor提交取值<epoch,f></epoch,f></li>
</ul>
<p> Acceptor在接收到accept(epoch,V)的请求之后，先查看epoch是不是自己记录的lastest_prepared_epoch，如果是则设置<accepted_epoch,accepted_value> = <prepared_epoch,v> 。否在则会返回error</prepared_epoch,v></accepted_epoch,accepted_value></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-paxos-paxos2.png" alt="paxos2"></p>
<p> 如上图所示，由于在阶段一中Proposer1接受到的<accepted_epoch>和<accepted_value>值都为null,所以，决定将自己的值设置为确定值，于是发送accept(1,V1)请求。Acceptor1接受到了这个请求，检查lastest_prepared_epoch也等于1,所以将自己存储的<accepted_epoch,accepted_value>设置为<1,v1>。而Proposer1的另外两个accept请求发生了网络延迟。<br> 如果此时，Proposer2向Acceptor进行propose会怎么样呢？我们来模拟propose来分析一下。</1,v1></accepted_epoch,accepted_value></accepted_value></accepted_epoch></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-paxos-paxos3.png" alt="paxos3"></p>
<p> 如上图所示，Proposer2向Acceptor发送了prepare(#2)的请求，Acceptor1先检测一下发现2大于现在的lastest_prepared_epoch,所以同意发送访问权，将lastest_prepared_epoch修改为2，并将自己保存的accepted_epoch和acceped_value返回给Proposer2；Acceptor3的操作也是类似，只不过因为Proposer1发送的accept请求发生了延迟，所以Acceptor3返回的是<null,null>；而Acceptor5的操作和我们在文章第一张图中的Acceptor1的操作相同，他们都是第一次接收到prepare请求。<br> 然后Proposer2进行第二阶段的操作，从所有的返回数据中，找到accepted_epoch最大的那个accepted_value.这里就是Acceptor返回的<1,v1>，所以，Proposer2会尽力让V1成为确定值，所以它向Acceptor发送accept(2,V1)的请求。然后Acceptor1,Acceptor3,Acceptor5三个Acceptor接受了这个accept请求，更新自己的<accepted_epoch,accepted_value>。此时，已经有三个acceptor形成了一致性的值，所以V1就成了整个系统的确定性取值。<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017416-paxos-paxos7.png" alt="paxos7.png"></accepted_epoch,accepted_value></1,v1></null,null></p>
<p> 那么Proposer1对Acceptor3发送的accept请求在此时达到Acceptor3会怎么样呢？Acceptor3发现当前lastest_prepared_epoch是2,所以直接拒绝了这个请求。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p> 不清楚大家现在对Paxos算法的过程是否已经有了清楚的了解啊？那么我来问几个问题，大家可以考虑一下：</p>
<ul>
<li>在本文的情景下，假如Proposer2向Acceptor2,3,4发送了prepare请求，而不是向Acceptor1,3,5发送的请求，会怎么样呢？</li>
<li>为什么强调prepare阶段时必须接受到一般以上Acceptor的返回，才能进行第二阶段?<br>&emsp;后续希望能够分析一下<code>Zookeeper</code>关于Paxos的具体使用场景和算法，希望大家多多关注。</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/5635585c/" data-id="ck7kgwykp005zrase1ol9e5pn" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-AbstractQueuedSynchronizer超详细原理解析" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/d2edd1b8/">AbstractQueuedSynchronizer超详细原理解析</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/d2edd1b8/">
            <time datetime="2017-04-06T13:50:01.000Z" itemprop="datePublished">2017-04-06</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/并发/">并发</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JUC/">JUC</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 今天我们来研究学习一下<code>AbstractQueuedSynchronizer</code>类的相关原理,<code>java.util.concurrent</code>包中很多类都依赖于这个类所提供的队列式的同步器,比如说常用的<code>ReentranLock</code>,<code>Semaphore</code>和<code>CountDownLatch</code>等.<br> 为了方便理解,我们以一段使用<code>ReentranLock</code>的代码为例,讲解<code>ReentranLock</code>每个方法中有关<code>AQS</code>的使用.</p>
<h3 id="ReentranLock示例"><a href="#ReentranLock示例" class="headerlink" title="ReentranLock示例"></a>ReentranLock示例</h3><p> 我们都知道<code>ReentranLock</code>的加锁行为和<code>Synchronized</code>类似,都是可重入的锁,但是二者的实现方式确实完全不同的,我们之后也会讲解<code>Synchronized</code>的原理.<strong><em>除此之外,Synchronized的阻塞无法被中断,而ReentrantLock则提供了可中断的阻塞</em></strong>下面的代码是<code>ReentranLock</code>的相关API,我们就以此为顺序,依次讲解.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">ReentrantLock lock = new ReentrantLock();
lock.lock();
lock.unlock();
</code></pre></p>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p> ReentranLock分为公平锁和非公平锁.二者的区别就在获取锁是否和排队顺序相关.我们都知道,如果当前锁被另一个线程持有,那么当前申请锁的线程会被挂起等待,然后加入一个等待队列里.理论上,先调用<code>lock</code>函数被挂起等待的线程应该排在等待队列的前端,后调用的就排在后边.如果此时,锁被释放,需要通知等待线程再次尝试获取锁,公平锁会让最先进入队列的线程获得锁,而非公平锁则会唤醒所有线程,让它们再次尝试获取锁,所以可能会导致后来的线程先获得了锁,则就是非公平.</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre>
<p> 我们会发现<code>FairSync</code>和<code>NonfairSync</code>都继承了<code>Sync</code>类,而<code>Sync</code>的父类就是<code>AbstractQueuedSynchronizer</code>.但是<code>AQS</code>的构造函数是空的,并没有任何操作.<br> 之后的源码分析,如果没有特别说明,就是指公平锁.</p>
<h3 id="lock操作"><a href="#lock操作" class="headerlink" title="lock操作"></a>lock操作</h3><p> <code>ReentranLock</code>的<code>lock</code>函数如下所示,直接调用了<code>sync</code>的<code>lock</code>函数.也就是调用了<code>FairSync</code>的<code>lock</code>函数.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">    &#x2F;&#x2F;ReentranLock
    public void lock() {
        sync.lock();
    }
    &#x2F;&#x2F;FairSync
    final void lock() {
        acquire(1);&#x2F;&#x2F;调用了AQS的acquire函数,这是关键函数之一
    }
</code></pre></p>
<p> 好,我们接下来就正式开始<code>AQS</code>相关的源码分析了,<code>acquire</code>函数你可以将其理解为获取一个同一时间只能有一个函数获取的量,这个量就是锁概念的抽象化.我们先分析代码,你慢慢就会明白其中的含义.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp; &#x2F;&#x2F;tryAcquire先尝试获取&quot;锁&quot;,&#x2F;&#x2F;如果成功,直接返回,失败继续执行后续代码
        &#x2F;&#x2F;addWaiter是给当前线程创建一个节点,并将其加入等待队列
        &#x2F;&#x2F;acquireQueued是当线程已经加入等待队列之后的行为.
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre></p>
<p> <code>tryAcquire</code>,<code>addWaiter</code>和<code>acquireQueued</code>都是十分重要的函数,我们接下来依次学习一下这些函数,理解它们的作用.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F;AQS类中的变量.
private volatile int state;
&#x2F;&#x2F;这是FairSync的实现,AQS中未实现,子类按照自己的需要实现该类
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    &#x2F;&#x2F;获取AQS中的state变量,代表抽象概念的锁.
    int c = getState();
    if (c == 0) { &#x2F;&#x2F;值为0,那么当前独占性变量还未被线程占有
        if (!hasQueuedPredecessors() &amp;&amp; &#x2F;&#x2F;如果当前阻塞队列上没有先来的线程在等待,UnfairSync这里的实现就不一致
            compareAndSetState(0, acquires)) {
            &#x2F;&#x2F;成功cas,那么代表当前线程获得该变量的所有权,也就是说成功获得锁
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        &#x2F;&#x2F;如果该线程已经获取了独占性变量的所有权,那么根据重入性
        &#x2F;&#x2F;原理,将state值进行加1,表示多次lock
        &#x2F;&#x2F;由于已经获得锁,该段代码只会被一个线程同时执行,所以不需要
        &#x2F;&#x2F;进行任何并行处理
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    &#x2F;&#x2F;上述情况都不符合,说明获取锁失败
    return false;
}
</code></pre></p>
<p> 由上述代码我们可以发现,<code>tryAcquire</code>就是尝试获取那个线程独占的变量<code>state</code>.state的值表示其状态:如果是0,那么当前还没有线程独占此变量;否在就是已经有线程独占了这个变量,也就是代表已经有线程获得了锁.但是这个时候要再进行一次判断,看是否是当前线程自己获得的这个锁,如果是,那么就增加state的值.</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201746-aqs-AQS1.png" alt="ReentranLock获得锁"></p>
<p> 这里有几点需要说明一下,首先是<code>compareAndSetState</code>函数,这是使用CAS操作来设置<code>state</code>的值,而且state值设置了<code>volatile</code>修饰符,通过这两点来确保修改state的值不会出现多线程问题.然后是公平锁和非公平锁的区别问题,在<code>UnfairSync</code>的<code>nonfairTryAcquire</code>函数中不会在相同的位置上调用<code>hasQueuedPredecessors</code>来判断当前是否已经有线程在排队等待获得锁.<br> 如果<code>tryAcquire</code>返回<code>true</code>,那么就是获取锁成功,如果返回false,那么就是未获得锁.需要加入阻塞等待队列.我们下面就来看一下<code>addWaiter</code>的相关操作</p>
<h3 id="等待锁的阻塞队列"><a href="#等待锁的阻塞队列" class="headerlink" title="等待锁的阻塞队列"></a>等待锁的阻塞队列</h3><p> 将保存当前线程信息的节点加入到等待队列的相关函数中涉及到了无锁队列的相关算法,由于在<code>AQS</code>中只是将节点添加到队尾,使用到的无锁算法也相对简单.真正的无锁队列的算法我们等到分析<code>ConcurrentSkippedListMap</code>时在进行讲解.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    &#x2F;&#x2F;先使用快速如列法来尝试一下,如果失败,则进行更加完备的如列算法.
    Node pred = tail;&#x2F;&#x2F;列尾指针
    if (pred != null) {
        node.prev = pred; &#x2F;&#x2F;步骤1:该节点的前趋指针指向tail
        if (compareAndSetTail(pred, node)){ &#x2F;&#x2F;步骤二:cas将尾指针指向该节点
            pred.next = node;&#x2F;&#x2F;步骤三:如果成果,让旧列尾节点的next指针指向该节点.
            return node;
        }
    }
    &#x2F;&#x2F;cas失败,或在pred == null时调用enq
    enq(node);
    return node;
}
private Node enq(final Node node) {
    for (;;) { &#x2F;&#x2F;cas无锁算法的标准for循环,不停的尝试
        Node t = tail;
        if (t == null) { &#x2F;&#x2F;初始化
            if (compareAndSetHead(new Node())) &#x2F;&#x2F;需要注意的是head是一个哨兵的作用,并不代表某个要获取锁的线程节点
                tail = head;
        } else {
            &#x2F;&#x2F;和addWaiter中一致,不过有了外侧的无限循环,不停的尝试,自旋锁
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre></p>
<p> 通过调用<code>addWaiter</code>函数,<code>AQS</code>将当前线程加入到了等待队列,但是还没有阻塞当前线程的执行,接下来我们就来分析一下<code>acquireQueued</code>函数.</p>
<h3 id="等待队列节点的操作"><a href="#等待队列节点的操作" class="headerlink" title="等待队列节点的操作"></a>等待队列节点的操作</h3><p> 由于进入阻塞状态的操作会降低执行效率,所以,<code>AQS</code>会尽力避免试图获取独占性变量的线程进入阻塞状态.所以,当线程加入等待队列之后,<code>acquireQueued</code>会执行一个for循环,每次都判断当前节点是否应该获得这个变量(在队首了),如果不应该获取或在再次尝试获取失败,那么就调用<code>shouldParkAfterFailedAcquire</code>判断是否应该进入阻塞状态,如果当前节点之前的节点已经进入阻塞状态了,那么就可以判定当前节点不可能获取到锁,为了防止CPU不停的执行for循环,消耗CPU资源,调用<code>parkAndCheckInterrupt</code>函数来进入阻塞状态.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) { &#x2F;&#x2F;一直执行,知道获取锁,返回.
            final Node p = node.predecessor(); 
            &#x2F;&#x2F;node的前驱是head,就说明,node是将要获取锁的下一个节点.
            if (p == head &amp;&amp; tryAcquire(arg)) { &#x2F;&#x2F;所以再次尝试获取独占性变量
                setHead(node); &#x2F;&#x2F;如果成果,那么就将自己设置为head
                p.next = null; &#x2F;&#x2F; help GC
                failed = false;
                return interrupted;&#x2F;&#x2F;此时,还没有进入阻塞状态,所以直接返回false,表示不需要中断
            }
            &#x2F;&#x2F;判断是否要进入阻塞状态.如果`shouldParkAfterFailedAcquire`返回true,表示需要进入阻塞
            &#x2F;&#x2F;调用parkAndCheckInterrupt,否在表示还可以再次尝试获取锁,继续进行for循环
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                &#x2F;&#x2F;调用parkAndCheckInterrupt进行阻塞,然后返回是否为中断状态
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL) &#x2F;&#x2F;前一个节点在等待独占性变量释放的通知,所以,当前节点可以阻塞
        return true;
    if (ws &gt; 0) { &#x2F;&#x2F;前一个节点处于取消获取独占性变量的状态,所以,可以跳过去
        &#x2F;&#x2F;返回false
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {
        &#x2F;&#x2F;将上一个节点的状态设置为signal,返回false,
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this); &#x2F;&#x2F;将AQS对象自己传入
    return Thread.interrupted();
}
</code></pre></p>
<h3 id="阻塞和中断"><a href="#阻塞和中断" class="headerlink" title="阻塞和中断"></a>阻塞和中断</h3><p> 由上述分析,我们知道了<code>AQS</code>通过调用<code>LockSupport</code>的<code>park</code>方法来执行阻塞当前进程的操作.其实,这里的阻塞就是线程不再执行的含义.通过调用这个函数,线程进入阻塞状态,上述的<code>lock</code>操作也就阻塞了.等待中断或在独占性变量被释放.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public static void park(Object blocker) {
    Thread t = Thread.currentThread();
    setBlocker(t, blocker);&#x2F;&#x2F;设置阻塞对象,用来记录线程被谁阻塞的,用于线程监控和分析工具来定位
    UNSAFE.park(false, 0L);&#x2F;&#x2F;让当前线程不再被线程调度,就是当前线程不再执行.
    setBlocker(t, null);
}
</code></pre></p>
<p> 关于中断的相关知识,我们以后再说,就继续沿着<code>AQS</code>的主线,看一下释放独占性变量的相关操作吧.</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201746-aqs-AQS2.png" alt="ReentrantLock未获得阻塞,加入队列"></p>
<h3 id="unlock操作"><a href="#unlock操作" class="headerlink" title="unlock操作"></a>unlock操作</h3><p> 与<code>lock</code>操作类似,<code>unlock</code>操作调用了<code>AQS</code>的<code>relase</code>方法,参数和调用<code>acquire</code>时一样,都是1.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public final boolean release(int arg) {
    if (tryRelease(arg)) { &#x2F;&#x2F;释放独占性变量,起始就是将status的值减1,因为acquire时是加1
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);&#x2F;&#x2F;唤醒head的后继节点
        return true;
    }
    return false;
}
</code></pre></p>
<p> 由上述代码可知,release就是先调用<code>tryRelease</code>来释放独占性变量,如果成果,那么就看一下是否有等待锁的阻塞线程,如果有,就调用<code>unparkSuccessor</code>来唤醒他们.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">protected final boolean tryRelease(int releases) {
    &#x2F;&#x2F;由于只有一个线程可以获得独占先变量,所以,所有操作不需要考虑多线程
    int c = getState() - releases; 
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) { &#x2F;&#x2F;如果等于0,那么说明锁应该被释放了,否在表示当前线程有多次lock操作.
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre></p>
<p> 我们可以看到<code>tryRelease</code>中的逻辑也体现了可重入锁的概念,只有等到<code>state</code>的值为1时,才代表锁真正被释放了.所以独占性变量<code>state</code>的值就代表锁的有无.当<code>state=0</code>时,表示锁未被占有,否在表示当前锁已经被占有.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">private void unparkSuccessor(Node node) {
    .....
     &#x2F;&#x2F;一般来说,需要唤醒的线程就是head的下一个节点,但是如果它获取锁的操作被取消,或在节点为null时
     &#x2F;&#x2F;就直接继续往后遍历,找到第一个未取消的后继节点.
    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
</code></pre></p>
<p> 调用了<code>unpark</code>方法后,进行<code>lock</code>操作被阻塞的线程就恢复到运行状态,就会再次执行<code>acquireQueued</code>中的无限for循环中的操作,再次尝试获取锁.</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201746-aqs-AQS3.png" alt="ReentrantLock释放锁并通知阻塞线程恢复执行"></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p> 有关<code>AQS</code>和<code>ReentrantLock</code>的分析就差不多结束了,不得不说,我第一次看到AQS的实现时真是震惊,以前都认为<code>Synchronized</code>和<code>ReentrantLock</code>的实现原理是一致的,都是依靠java虚拟机的功能实现的,没有想到还有<code>AQS</code>这样一个背后大Boss在提供帮助啊.学习了这个类的原理,我们对JUC的很多类的分析就简单了很多,此外,<code>AQS</code>涉及的<code>CAS</code>操作和无锁队列的算法也为我们学习其他无锁算法提供了基础.<strong><em>知识的海洋是无限的啊!</em></strong></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/d2edd1b8/" data-id="ck7kgwyhe000arasekxklf12z" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Netty源码-三-I-O模型和Java-NIO底层原理" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/dbc01bc2/">Netty源码(三):I/O模型和Java NIO底层原理</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/dbc01bc2/">
            <time datetime="2017-04-02T15:11:13.000Z" itemprop="datePublished">2017-04-02</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Netty/">Netty</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Netty/">Netty</a>, <a class="tag-link" href="/tags/epoll/">epoll</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> <a href="http://remcarpediem.com/2017/03/27/Netty%E6%BA%90%E7%A0%81-%E4%BA%8C-Netty%E7%9A%84Channel%E5%92%8CPipeline/" target="_blank" rel="noopener">上一篇文章</a>我们主要讲解了Netty的<code>Channel</code>和<code>Pipeline</code>，了解到不同的<code>Channel</code>可以提供基于不同网络协议的通信处理．既然涉及到网络通信，就不得不说一下多线程，同步异步相关的知识了．Netty的网络模型是多线程的<code>Reactor</code>模式，所有I/O请求都是异步调用，我们今天就来探讨一下一些基础概念和Java NIO的底层机制．<br> 为了节约你的时间，本文主要内容如下：</p>
<ul>
<li>异步，阻塞的概念</li>
<li>操作系统I/O的类型</li>
<li>Java NIO的Linux底层实现</li>
</ul>
<h3 id="异步，同步，阻塞，非阻塞"><a href="#异步，同步，阻塞，非阻塞" class="headerlink" title="异步，同步，阻塞，非阻塞"></a>异步，同步，阻塞，非阻塞</h3><p> <strong><em>同步和异步关注的是消息通信机制</em></strong>，所谓同步就是调用者进行调用后，在没有得到结果之前，该调用一直不会返回，但是一旦调用返回，就得到了返回值，<strong><em>同步就是指调用者主动等待调用结果</em></strong>；而异步则相反，执行调用之后直接返回，所以可能没有返回值，等到有返回值时，由被调用者通过状态，通知来通知调用者．<strong>异步就是指被调用者来通知调用者调用结果就绪*</strong>．<strong><em>所以，二者在消息通信机制上有所不同，一个是调用者检查调用结果是否就绪，一个是被调用者通知调用者结果就绪</em></strong><br> <strong><em>阻塞和非阻塞关注的是程序在等待调用结果(消息，返回值)时的状态</em></strong>．阻塞调用是指在调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会继续执行．非阻塞调用是指在不能立刻得到结构之前，调用线程不会被挂起，还是可以执行其他事情．<br> 两组概念相互组合就有四种情况，分别是同步阻塞，同步非阻塞，异步阻塞，异步非阻塞．我们来举个例子来分别类比上诉四种情况．<br> 比如你要从网上下载一个1G的文件，按下下载按钮之后，如果你一直在电脑旁边，等待下载结束，这种情况就是同步阻塞；如果你不需要一直呆在电脑旁边，你可以去看一会书，但是你还是隔一段时间来查看一下下载进度，这种情况就是同步非阻塞；如果你一直在电脑旁边，但是下载器在下载结束之后会响起音乐来提醒你，这就是异步阻塞；但是如果你不呆在电脑旁边，去看书，下载器下载结束后响起音乐来提醒你，那么这种情况就是异步非阻塞．</p>
<h3 id="Unix的I-O类型"><a href="#Unix的I-O类型" class="headerlink" title="Unix的I/O类型"></a>Unix的I/O类型</h3><p> 知道上述两组概念之后，我们来看一下Unix下可用的5种I/O模型：</p>
<ul>
<li>阻塞I/O</li>
<li>非阻塞I/O</li>
<li>多路复用I/O</li>
<li>信号驱动I/O</li>
<li>异步I/O</li>
</ul>
<p> 前４种都是同步，只有最后一种是异步I/O.需要注意的是<strong><em>Java NIO依赖于Unix系统的多路复用I/O,对于I/O操作来说，它是同步I/O，但是对于编程模型来说，它是异步网络调用</em></strong>.下面我们就以系统<code>read</code>的调用来介绍不同的I/O类型．<br> 当一个<code>read</code>发生时，它会经历两个阶段:</p>
<ul>
<li>1 等待数据准备</li>
<li>2 将数据从内核内存空间拷贝到进程内存空间中</li>
</ul>
<p> 不同的I/O类型，在这两个阶段中有不同的行为．但是由于这块内容比较多，而且多为表述性的知识，所以这里我们只给出几张图片来解释，具体解释大家可以参看<a href="http://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">这篇博文</a></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201742-netty-0_1280550787I2K8.gif" alt="Blocking I/O"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201742-netty-0_128055089469yL.gif" alt="NonBlocking I/O"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201742-netty-0_1280551028YEeQ.gif" alt="Multiplexing I/O"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201742-netty-0_1280551287S777.gif" alt="Asynchronous I/O"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201742-netty-0_1280551552NVgW.gif" alt="对比"></p>
<h3 id="Java-NIO的Linux底层实现"><a href="#Java-NIO的Linux底层实现" class="headerlink" title="Java NIO的Linux底层实现"></a>Java NIO的Linux底层实现</h3><p> 我们都知道Netty通过JNI的方式提供了Native Socket Transport，为什么<code>Netty</code>要提供自己的Native版本的NIO呢？明明Java NIO底层也是基于<code>epoll</code>调用(最新的版本)的．这里，我们先不明说，大家想一想可能的情况．下列的源码都来自于OpenJDK-8u40-b25版本．</p>
<h4 id="open方法"><a href="#open方法" class="headerlink" title="open方法"></a>open方法</h4><p>&emsp;如果我们顺着<code>Selector.open()</code>方法一个类一个类的找下去，很容易就发现<code>Selector</code>的初始化是由<code>DefaultSelectorProvider</code>根据不同操作系统平台生成的不同的<code>SelectorProvider</code>，对于Linux系统，它会生成<code>EPollSelectorProvider</code>实例，而这个实例会生成<code>EPollSelectorImpl</code>作为最终的<code>Selector</code>实现．<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">class EPollSelectorImpl extends SelectorImpl
{
    .....
    &#x2F;&#x2F; The poll object
    EPollArrayWrapper pollWrapper;
    .....
    EPollSelectorImpl(SelectorProvider sp) throws IOException {
        .....
        pollWrapper = new EPollArrayWrapper();
        pollWrapper.initInterrupt(fd0, fd1);
        .....
    }
    .....
}
</code></pre></p>
<p>&emsp;<code>EpollArrayWapper</code>将Linux的epoll相关系统调用封装成了native方法供<code>EpollSelectorImpl</code>使用．<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">    private native int epollCreate();
    private native void epollCtl(int epfd, int opcode, int fd, int events);
    private native int epollWait(long pollAddress, int numfds, long timeout,
                                 int epfd) throws IOException;
</code></pre></p>
<p> 上述三个native方法就对应Linux下epoll相关的三个系统调用<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-c">&#x2F;&#x2F;创建一个epoll句柄，size是这个监听的数目的最大值．
int epoll_create(int size);
&#x2F;&#x2F;事件注册函数，告诉内核epoll监听什么类型的事件，参数是感兴趣的事件类型，回调和监听的fd
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
&#x2F;&#x2F;等待事件的产生，类似于select调用，events参数用来从内核得到事件的集合
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
</code></pre></p>
<p>&emsp;所以，我们会发现在<code>EpollArrayWapper</code>的构造函数中调用了<code>epollCreate</code>方法，创建了一个epoll的句柄．这样，<code>Selector</code>对象就算创造完毕了．</p>
<h4 id="register方法"><a href="#register方法" class="headerlink" title="register方法"></a>register方法</h4><p>&emsp;与<code>open</code>类似，<code>ServerSocketChannel</code>的<code>register</code>函数底层是调用了<code>SelectorImpl</code>类的<code>register</code>方法，这个<code>SelectorImpl</code>就是<code>EPollSelectorImpl</code>的父类．<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">protected final SelectionKey register(AbstractSelectableChannel ch,
                                      int ops,
                                      Object attachment)
{
    if (!(ch instanceof SelChImpl))
        throw new IllegalSelectorException();
    &#x2F;&#x2F;生成SelectorKey来存储到hashmap中，一共之后获取
    SelectionKeyImpl k = new SelectionKeyImpl((SelChImpl)ch, this);
    &#x2F;&#x2F;attach用户想要存储的对象
    k.attach(attachment);
    &#x2F;&#x2F;调用子类的implRegister方法
    synchronized (publicKeys) {
        implRegister(k);
    }
    &#x2F;&#x2F;设置关注的option
    k.interestOps(ops);
    return k;
}
</code></pre></p>
<p>&emsp;<code>EpollSelectorImpl</code>的相应的方法实现如下，它调用了<code>EPollArrayWrapper</code>的<code>add</code>方法，记录下Channel所对应的fd值,然后将ski添加到<code>keys</code>变量中．在<code>EPollArrayWrapper</code>中有一个byte数组<code>eventLow</code>记录所有的channel的fd值.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">    protected void implRegister(SelectionKeyImpl ski) {
        if (closed)
            throw new ClosedSelectorException();
        SelChImpl ch = ski.channel;
        &#x2F;&#x2F;获取Channel所对应的fd,因为在linux下socket会被当作一个文件，也会有fd
        int fd = Integer.valueOf(ch.getFDVal());
        fdToKey.put(fd, ski);
        &#x2F;&#x2F;调用pollWrapper的add方法,将channel的fd添加到监控列表中
        pollWrapper.add(fd);
        &#x2F;&#x2F;保存到HashSet中，keys是SelectorImpl的成员变量
        keys.add(ski);
    }
</code></pre></p>
<p>&emsp;我们会发现,调用<code>register</code>方法并没有涉及到<code>EpollArrayWrapper</code>中的native方法<code>epollCtl</code>的调用,这是因为他们将这个方法的调用推迟到<code>Select</code>方法中去了.<br>&emsp;</p>
<h4 id="Select方法"><a href="#Select方法" class="headerlink" title="Select方法"></a>Select方法</h4><p>&emsp;和<code>register</code>方法类似,<code>SelectorImpl</code>中的<code>select</code>方法最终调用了其子类<code>EpollSelectorImpl</code>的<code>doSelect</code>方法<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">protected int doSelect(long timeout) throws IOException {
    .....
    try {
        ....
        &#x2F;&#x2F;调用了poll方法,底层调用了native的epollCtl和epollWait方法
        pollWrapper.poll(timeout);
    } finally {
        ....
    }
    ....
    &#x2F;&#x2F;更新selectedKeys,为之后的selectedKeys函数做准备
    int numKeysUpdated = updateSelectedKeys();
    ....
    return numKeysUpdated;
}
</code></pre></p>
<p> 由上述的代码，可以看到，<code>EPollSelectorImpl</code>先调用<code>EPollArrayWapper</code>的<code>poll</code>方法,然后在更新<code>SelectedKeys</code>．其中<code>poll</code>方法会先调用<code>epollCtl</code>来注册先前在<code>register</code>方法中保存的Channel的fd和感兴趣的事件类型，然后<code>epollWait</code>方法等待感兴趣事件的生成,导致线程阻塞.</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">int poll(long timeout) throws IOException {
    updateRegistrations(); &#x2F;&#x2F;&#x2F;&#x2F;先调用epollCtl,更新关注的事件类型
    &#x2F;&#x2F;&#x2F;&#x2F;导致阻塞，等待事件产生
    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);
    .....
    return updated;
}
</code></pre>
<p>&emsp;等待关注的事件产生之后(或在等待时间超过预先设置的最大时间),<code>epollWait</code>函数就会返回.<code>select</code>函数从阻塞状态恢复.</p>
<h4 id="selectedKeys方法"><a href="#selectedKeys方法" class="headerlink" title="selectedKeys方法"></a>selectedKeys方法</h4><p>&emsp;我们先来看<code>SelectorImpl</code>中的<code>selectedKeys</code>方法.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;是通过Util.ungrowableSet生成的,不能添加,只能减少
private Set&lt;SelectionKey&gt; publicSelectedKeys;
public Set&lt;SelectionKey&gt; selectedKeys() {
    ....
    return publicSelectedKeys;
}
</code></pre></p>
<p>&emsp;很奇怪啊,怎麽直接就返回<code>publicSelectedKeys</code>了,难道在<code>select</code>函数的执行过程中有修改过这个变量吗?<br>&emsp;<code>publicSelectedKeys</code>这个对象其实是<code>selectedKeys</code>变量的一份副本,你可以在<code>SelectorImpl</code>的构造函数中找到它们俩的关系,我们再回头看一下<code>select</code>中<code>updateSelectedKeys</code>方法.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">private int updateSelectedKeys() {
    &#x2F;&#x2F;更新了的keys的个数,或在说是产生的事件的个数
    int entries = pollWrapper.updated; 
    int numKeysUpdated = 0;
    for (int i=0; i&lt;entries; i++) {
        &#x2F;&#x2F;对应的channel的fd
        int nextFD = pollWrapper.getDescriptor(i);
        &#x2F;&#x2F;通过fd找到对应的SelectionKey
        SelectionKeyImpl ski = fdToKey.get(Integer.valueOf(nextFD));
        if (ski != null) {
            int rOps = pollWrapper.getEventOps(i);
            &#x2F;&#x2F;更新selectedKey变量,并通知响应的channel来做响应的处理
            if (selectedKeys.contains(ski)) {
                if (ski.channel.translateAndSetReadyOps(rOps, ski)) {
                    numKeysUpdated++;
                }
            } else {
                ski.channel.translateAndSetReadyOps(rOps, ski);
                if ((ski.nioReadyOps() &amp; ski.nioInterestOps()) != 0) {
                    selectedKeys.add(ski);
                    numKeysUpdated++;
                }
            }
        }
    }
    return numKeysUpdated;
}
</code></pre></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;看到这里,详细大家都已经了解到了NIO的底层实现了吧.这里我想在说两个问题.<br>&emsp;一是为什么Netty自己又从新实现了一边native相关的NIO底层方法? 听听Netty的创始人是怎麽说的吧<a href="http://stackoverflow.com/questions/23465401/why-native-epoll-support-is-introduced-in-netty" target="_blank" rel="noopener">链接</a><br>&emsp;二是看这么多源码,花费这么多时间有什么作用呢?我感觉如果从非功利的角度来看,那么就是纯粹的希望了解的更多,有时候看完源码或在理解了底层原理之后,都会用一种恍然大悟的感觉,比如说<code>AQS</code>的原理.如果从目的性的角度来看,那么就是你知道底层原理之后,你的把握性就更强了,如果出了问题,你可以更快的找出来,并且解决.除此之外,你还可以按照具体的现实情况,以源码为模板在自己造轮子,实现一个更加符合你当前需求的版本.<br>&emsp;后续如果有时间,我希望好好了解一下epoll的操作系统级别的实现原理.</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/dbc01bc2/" data-id="ck7kgwyis002rrasencojitpg" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Netty源码-二-Netty的Channel和Pipeline" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/815dc153/">Netty源码(二):Netty的Channel和Pipeline</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/815dc153/">
            <time datetime="2017-03-27T13:38:03.000Z" itemprop="datePublished">2017-03-27</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Netty/">Netty</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Netty/">Netty</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 本文主要讲述Netty框架中Channel相关的知识，Netty通过Channel和Pipeline等一些组件提供了所谓的<code>Universal Communication API</code>．与<code>Channel</code>相关的知识点比较多，本篇文章就主要讲解一下<code>Channel</code>和<code>Pipeline</code>的事件处理流原理．<code>Channel</code>,<code>EventLoop</code>和<code>ChannelFuture</code>的相关知识下篇文章中再进行讲述．</p>
<h3 id="官方文档上的Channel"><a href="#官方文档上的Channel" class="headerlink" title="官方文档上的Channel"></a>官方文档上的Channel</h3><p> 官方文档上给出的解释是Channel是与网络Socket相关的或具有一定I/O能力的组件．一个<code>Channel</code>可以给用户提供:</p>
<ul>
<li>当前<code>Channel</code>的状态(比如，是否保存Open状态，是否处于连接状态)</li>
<li><code>Channel</code>的配置参数，比如说buffer的大小</li>
<li><code>Channel</code>支持的相关I/O操作，比如说<code>read</code>,<code>write</code>,<code>connect</code>和<code>bind</code></li>
<li>提供一个<code>ChannelPipeline</code>来处理所有与该<code>Channel</code>相关的I/O事件和请求</li>
</ul>
<p> <code>Channel</code>上进行的所有I/O操作都是异步的，也就是说，所有涉及I/O操作的调用都会立刻返回，并不保证操作完成，而是会返回一个<code>ChannelFuture</code>对象来通知你操作是否完成．<br> Channel是有层级的，这样的话，你就可以很方便的利用其他已有的Channel来构建自己需要的<code>channel</code>,比如说基于<code>SocketChannel</code>来实现关于<code>SSH</code>的<code>Channel</code></p>
<p> 此外，当你完成某些操作之后调用<code>close()</code>或在<code>close(ChannelPromise)</code>是非常重要的，这样能确保你正确的释放了所有资源．</p>
<h4 id="我眼中的Channel"><a href="#我眼中的Channel" class="headerlink" title="我眼中的Channel"></a>我眼中的Channel</h4><p> 首先，我们应该都知道Netty支持很多I/O通信协议:</p>
<ul>
<li>基于TCP的NIO: <code>NioServerSocketChannel</code>,<code>NioSocketChannel</code></li>
<li>基于UDP的NIO:<code>NioDatagramChannel</code></li>
<li>基于TCP的OIO:<code>OioSocketChannel</code>和<code>OioServerSocketChannel</code></li>
<li>基于UDP的OIO:<code>OioDatagramChannel</code><br>如果把关于Channel的类图列出来的话，你会发现支持各种协议的<code>Channel</code>,不信你就看一下这个类图．</li>
</ul>
<p> 这样想一下，<strong><em><code>Channel</code>不就是<code>Netty</code>框架用来封装不同协议逻辑的组件吗?</em></strong>，有了<code>Channel</code>的存在，所有于通信协议相关的逻辑都隐藏在不同的<code>Channel</code>实现里，然后在对外提供相对统一的API.<br> 说道这里，你可能还不知道，即使是<code>OIOChannel</code>,它提供的I/O操作也是异步的．也就是说<strong><em>在Netty框架中，不论是OIO还是NIO模型，读写都会阻塞</em></strong>．这样也体现了<code>Universal Communication API</code>的思想，这就使得我们切换Channel非常方便．我们只要初始化不同的Channel即可．<br><code>ServerBootstrap b = new ServerBootstrap(); 
            b.group(bossGroup, workerGroup)
             .channel(NioServerSocketChannel.class)
ServerBootstrap b = new ServerBootstrap(); 
            b.group(bossGroup, workerGroup)
             .channel(OioServerSocketChannel.class)</code><br> 有关<code>Channel</code>协议相关的底层知识，我们会在下一篇文章时进行介绍．</p>
<h3 id="ChannelHandler和ChannelPipeline"><a href="#ChannelHandler和ChannelPipeline" class="headerlink" title="ChannelHandler和ChannelPipeline"></a>ChannelHandler和ChannelPipeline</h3><p> 只有<code>Channel</code>的支持，还不足以实现<code>Universal Communication API</code>,还需要上述两个类来提供<code>ChannelHandler</code>的编程模式，基于<code>ChannelHandler</code>来开发业务逻辑，而不需要考虑网络通讯方面的事情．<br> Netty源码中一张图形象的描述了这个机制<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017327-netty-stream.png" alt="示意图"></p>
<p>&emsp;Netty中的<code>ChannelPipeline</code>包含两条线路：Upstream和<code>Downstream</code>．Upstream对应上行，接受信息，被动的状态改变，都属于Upstream．Downstream则对应下行，发送消息，主动状态的改变．Upstream对应InBound Handler,Downstream对应Outbound Handler.从Netty内部IO线程接读到IO数据，依次经过N个Handler到达最内部的逻辑处理单元，这种称之为Inbound Handler；从Channel发出IO请求，依次经过M个Handler到达Netty内部IO线程，这种称之为Outbound Handler<br>&emsp;需要注意的是，这个Handler链中消息或在事件不会自动的向下或在向上流动或转发，而是需要由上一个Handler显示的调用<code>ChannelPipeline.sendUp(down)stream</code>来交给下一个Handler来处理．也就是说，每个Handler接受到一个<code>ChannelEvent</code>,处理结束后，如果需要继续处理，那么它需要向下一个或在上一个Handler发起一个事件．</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/815dc153/" data-id="ck7kgwyj6002vrase5gumhyj4" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Netty源码-一-Netty中的Buffer" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/bf1a30e4/">Netty源码(一):Netty中的Buffer</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/bf1a30e4/">
            <time datetime="2017-03-22T15:09:21.000Z" itemprop="datePublished">2017-03-22</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Netty/">Netty</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Netty/">Netty</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 最近我学习了NIO相关的知识,然后发现了Netty这个基于NIO的网络应用框架,于是就研究起Netty框架源码,来好好体会一下网络框架的设计理念和思想.<br> 这个系列的文章不仅会总结Netty各个模块的源码原理,也会写出一些自己对这些设计的理解和体会.<br> 我基本按照并发编程网上<a href="http://ifeve.com/netty1/" target="_blank" rel="noopener">这个系列文章</a>的顺序来进行系列文章的顺序,不同的是我是基于Netty4.1的源码进行分析和讲解.<br> 为了节约你的时间,本篇文章主要内容如下:</p>
<ul>
<li>Netty的Buffer的内存模型,涉及读写指针</li>
<li>Netty的Buffer框架</li>
<li>Netty的Pool原理,轻量对象池</li>
</ul>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p> Java NIO中的Buffer用于和NIO通道进行交互,数据可以从通道读入缓冲区,也可以从缓冲区写入到通道中.所以说,Buffer其实就是一块可以读写数据的内存,我们将其包装为一个Java对象来提供一系列读写操作.<br> Netty并没有直接使用Java NIO的Buffer实现,而是自己实现了一套Buffer框架来满足自己的业务或者性能需求.</p>
<h3 id="ByteBuf的基本原理"><a href="#ByteBuf的基本原理" class="headerlink" title="ByteBuf的基本原理"></a>ByteBuf的基本原理</h3><h4 id="读写指针的作用"><a href="#读写指针的作用" class="headerlink" title="读写指针的作用"></a>读写指针的作用</h4><p> 不同于NIO Buffer的读写指针共用原理,ByteBuf拥有<code>readerIndex</code>,<code>writerIndex</code>两个指针.下面我们就来详细的讲解一下ByteBuf的内部原理.<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">     +-------------------+------------------+------------------+
     | discardable bytes |  readable bytes  |  writable bytes  |
     |                   |     (CONTENT)    |                  |
     +-------------------+------------------+------------------+
     |                   |                  |                  |
     0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity
</code></pre></p>
<p> 从示意图中我们可以看出<code>readerIndex</code>和<code>writerIndex</code>最多可以将整个内容空间划分为三块:<code>废弃区</code>,<code>可读区</code>和<code>可写区</code>.下面我们就来看一下不同操作下的两个指针的变化.</p>
<ul>
<li><p>在初始化状态下,假设capacity为20,<code>readerIndex</code>和<code>writerIndex</code>都为0,整个空间中只存在可写区.此时只能写,不能读,进行读操作会抛出异常.</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">       +---------------------------------------------------------+
       |             writable bytes (got more space)             |
       +---------------------------------------------------------+
       |                                                         |
 readerIndex(0)
  writerIndex(0)                   &lt;=                   capacity
</code></pre>
</li>
<li><p>写入10个字节的数据,<code>writerIndex</code>指向10,<code>readerIndex</code>不会改变,所有内容空间中有可读区和可写区.大小都是10字节.</p>
</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">       +-------------------+------------------+------------------+
       |  readable bytes  |  writable bytes                      |
       |     (CONTENT)    |                                      |
       +--------- --------+------------------+------------------
       |                  |                                      |
     readerIndex(0) &lt;= writerIndex(10)           &lt;=        capacity
</code></pre>
<ul>
<li>读取5个字节的内容,<code>writerIndex</code>不变,<code>readerIndex</code>加5,指向了5.此时内容空间分为了5字节的废弃区,5字节的可读区和10字节的可写区.</li>
</ul>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">
 +-------------------+------------------+------------------+
 | discardable bytes |  readable bytes  |  writable bytes  |
 |                   |     (CONTENT)    |                  |
 +-------------------+------------------+------------------+
 |                   |                  |                  |
 0      &lt;=      readerIndex(5)   &lt;=   writerIndex(10)    &lt;=  capacity
</code></pre>
<ul>
<li>调用<code>discardReadBytes</code>方法后,将废弃区的内容舍弃掉,<code>readerIndex</code>又指向了0,<code>writerIndex</code>指向了5,相当于可读区和可写区整体向左平移了5个字节.
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">       +------------------+--------------------------------------+
       |  readable bytes  |    writable bytes (got more space)   |
       +------------------+--------------------------------------+
       |                  |                                      |
  readerIndex (0) &lt;= writerIndex (5)              &lt;=        capacity
</code></pre>
</li>
</ul>
<h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p> OS层次上<code>Zero-copy</code>,就是在操作数据时,不需要将数据buffer从一个内存区域拷贝到另一个内存区域,因为减少了一次内存的拷贝,因此CPU的效率得到了提升.<br> <code>Netty</code>的<code>zero-copy</code>体现在很多方面.比如Buffer的compose,duplicate,slice操作时不会拷贝底层的数据.而是通过ByteBuf对象的组合来实现上述的操作</p>
<ul>
<li><p>Netty提供了<code>CompositeByteBuf</code>类,可以将多个<code>ByteBuf</code>组合成一个逻辑上的Buffer,避免了各个buffer之间的拷贝,<code>CompositeByteBuf</code>并不拥有底层的数据,而是通过拥有两个buffer对象,从这两个buffer对象中获取数据来对外提供看似合并了的数据.比如我们将一份协议数据的头部buffer和消息体buffer合并成一个Buffer.<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017322-netty-compose.png" alt="compose"><br> 如上图所示,所有底层的数据还是存储在header和body这两个真实的buffer中.</p>
</li>
<li><p>对于<code>ByteBuf</code>的<code>slice</code>和<code>duplicate</code>操作也是如此,不同的buffer共享了相同的底层数据,而不是进行底层数据的拷贝.具体使用到的Buffer类型为<code>DuplicatedByteBuf</code>和<code>SlicedByteBuf</code>.谁说是共享的底层数据,但是通过对<code>writerIndex</code>和<code>readerIndex</code>两个指针的操作来实现slice和duplicate的功能.</p>
</li>
<li>Netty使用<code>wrap</code>操作将byte数组转化为<code>ByteBuf</code>对象时,将byte数组包裹到对象中,而不是拷贝数组存放到对象中.</li>
<li>Netty 中使用 FileRegion 实现文件传输的零拷贝, 不过在底层 FileRegion 是依赖于 Java NIO FileChannel.transfer 的零拷贝功能.</li>
</ul>
<h3 id="Pool和Reference-Count"><a href="#Pool和Reference-Count" class="headerlink" title="Pool和Reference Count"></a>Pool和Reference Count</h3><p> 4.0之后的版本实现了高性能的Buffer池,分配策略则是结合了buddy allocation和slab allocation的jemalloc变种，实现类为<code>PoolArena</code>,这样的话,可以在频繁分配和释放Buffer时缓解GC压力,还可以在初始化新buffer时减少内存带宽消耗（初始化时不可避免的要给buffer数组赋初始值).<br> <code>ByteBuf</code>引入了<code>Reference Count</code>机制,你需要在不适用它的时候调用<code>ReferenceCountUtil.release</code>方法来减少它的引用.</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;感觉自己在研究或在阅读源代码时还是有些问题,起始<code>ByteBuf</code>并不是<code>Netty</code>的关键所在,不应该花费这么长时间.以后还是要带着目的来看源码,不能把时间浪费在一些代码细节上.</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><a href="https://segmentfault.com/a/1190000007560884" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007560884</a></li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/bf1a30e4/" data-id="ck7kgwyiq002nrase7k4fg92g" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-关于Android-MVP模式的思考" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/eca06a79/">关于Android MVP模式的思考</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/eca06a79/">
            <time datetime="2017-03-12T09:09:22.000Z" itemprop="datePublished">2017-03-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/框架/">框架</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 这一周对现有的Android项目进行了框架重构，使用MVP模式来重新构建整个项目和包结构。今天就来总结一下我在这个过程中理解和实践吧。</p>
<h3 id="MVP概述"><a href="#MVP概述" class="headerlink" title="MVP概述"></a>MVP概述</h3><p> MVP是指Model，View和Presenter的缩写，是MVC模式的一种改进版。MVP是一种非常适合Android应用的开发模式，它<strong>将把逻辑相关代码从presentation Layer中分离出去</strong>，所以，所有界面应该显示什么和界面如何显示这些是相互分离的，  在理想状态下，MVP模式可以随意切换视图显示的形式。<br> 但是，需要首先声明的是，MVP并不是<strong>一个框架模式</strong>，它只负责presentation Layer。在Android项目中，还可能存在Domain Layer和Data Layer，它们分别负责业务逻辑和数据存储。关于三个layer的讨论，可以查看<a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="noopener">clear Architecture</a>。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017312-mvp-mvp.png" alt="mvp.png"></p>
<h4 id="The-presenter"><a href="#The-presenter" class="headerlink" title="The presenter"></a>The presenter</h4><p> The presenter充当的是view和model模块中间人的角色。它从model模块获得数据并发送给view模块。<strong>但是不同于MVC，presenter模块也决定用户和界面交互时界面如何响应</strong>。</p>
<h4 id="The-View"><a href="#The-View" class="headerlink" title="The View"></a>The View</h4><p> View模块，一般由Activity或者Fragment实现，每个View实例一般都包含一个presenter实例的引用，并负责实例化presenter。理想情况下，你可以使用dagger来实现依赖注入。view的任务就是当用户操作界面时，调用presenter实例的功能来进行响应。</p>
<h4 id="The-Model"><a href="#The-Model" class="headerlink" title="The Model"></a>The Model</h4><p> 在设计良好的分层架构中，model应该只是domain layer和业务逻辑的入口，比如说，<a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">clear architecture</a>。但是你也可以把所有界面显示无关的逻辑都作为model。</p>
<h3 id="MVP示例"><a href="#MVP示例" class="headerlink" title="MVP示例"></a>MVP示例</h3><p> 关于MVP架构的实例有很多，比如<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">google官方架构</a>。这里我就给出一下我重构项目一个模块的类图，然后大致说一下实现。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017312-mvp-webwxgetmsgimg.jpg" alt="webwxgetmsgimg.jpg"></p>
<p>&emsp;首先定义了<code>BaseView</code>和<code>BasePresenter</code>两个接口，实现了<code>BaseActivity</code>和<code>BaseFragment</code>两个基础类。需要注意的是，因为每个View都需要持有一个特定类型的presenter对象，所以，在<code>BaseView</code>定义时，使用了范型。除此之外，你可以在<code>initPresenter</code>函数中构造出所需要的presenter对象。<code>showLoading</code>和<code>stopLoading</code>函数是所有视图进行网络数据加载时所需要的方法，其具体使用场景后边可以看到，这里这两个接口是在<code>BaseActivity</code>中实现的。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public interface BaseView&lt;T&gt; {
    void showLoading();
    void stopLoading();
    void initPresnter();
    T getPresenter();
}

public interface BasePresenter {

}

public class BaseActivity extends Activity{
    public void showLoading() {
    }

    public void stopLoading() {
    }
}

public class BaseFragment extends Fragment {
    public void showLoading() {

    }

    public void stopLoading() {

    }
}
</code></pre>
<p>&emsp;然后是data模块中的相关类和接口的定义。我们在<code>DataContract</code>接口中定义所有相关的view和data。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public interface DataContract {
    interface DataView extends BaseView&lt;DataPresenter&gt; {
        void showFragment(BaseFragment fragment);
    }
    interface DataPresenter extends BasePresenter {
        void switchToDataList();
        void switchToDataTree();
    }
    interface DataListView extends BaseView&lt;DataListPresenter&gt; {
        void showDataList(List&lt;String&gt; data);
    }
    interface DataListPresenter extends BasePresenter {
        void loadDataList();
    }
    interface DataTreeView extends BaseView&lt;DataTreePresenter&gt; {}
    interface DataTreePresenter extends BasePresenter {}
}
</code></pre></p>
<p>&emsp;在<code>DataContract</code>接口中，我们可以清晰的看到这个模块中所有的view和presenter类型和他们的接口。这样无疑可以帮助其他程序员快速了解本模块的业务逻辑。下面，我们来看一下<code>DataListFragmnet</code>和<code>DataListPresenter</code>的实现。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public class DataListFragment extends BaseFragment implements DataContract.DataListView {
    private DataContract.DataListPresenter mPresenter;
    @Override
    public void initPresnter() {
        mPresenter = new DataListPresenter(this);
    }
    @Override
    public DataContract.DataListPresenter getPresenter() {
        return mPresenter;
    }
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        initPresnter();
        &#x2F;&#x2F;需要加载数据或者接收到界面点击事件时，调用presenter接口进行初始化或者响应。
        mPresenter.loadDataList();
    }
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_data_list, container, false);
    }
    @Override
    public void showDataList(List&lt;String&gt; data) {
        &#x2F;&#x2F;将数据传给adapter等数据展示的视图
    }
}

public class DataListPresenter implements DataContract.DataListPresenter {
    private DataContract.DataListView mView;
    public DataListPresenter(DataContract.DataListView view) {
        super();
        this.mView = view;
    }

    @Override
    public void loadDataList() {
        &#x2F;&#x2F;调用baseview的接口，这些接口实现在baseFragment或者BaseActivity中
        mView.showLoading();
        &#x2F;&#x2F;getdata from network
        mView.stopLoading();
        mView.showDataList(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;));
    }
}
</code></pre>
<p>&emsp;上述代码中有很多可以好好思考的地方。首先是<code>showLoading</code>和<code>stopLoading</code>这两个函数。这两个函数接口定义在<code>BaseView</code>,实现在<code>BaseFragment</code>，所以当<code>DataListFragment</code>继承了<code>BaseFragment</code>并且实现了<code>BaseView</code>时，它并不需要再次定义上述两个接口，毕竟在一个app中，网络加载时的laoding动画一般都是一致的。然后是view和presenter之间函数调用的问题。首先，view在需要初始化或者需要处理点击事件时，需要调用presenter的函数，而不是自己来进行处理。而且二者之间的数据传递必须是presenter调用view的接口传递给view数据，而不是view调用presenter接口获得数据然后自己展示。</p>
<h3 id="MVP实践中的问题和思考"><a href="#MVP实践中的问题和思考" class="headerlink" title="MVP实践中的问题和思考"></a>MVP实践中的问题和思考</h3><p>&emsp;在实现MVP的过程中，我发现有些模块的代码很容易重构为MVP模式，而有些模块的代码却需要花费大量的时间。那些难重构的模块的所有代码都写在了Activity类中，而那些容易重构的模块已经做了逻辑代码和视图代码的分离。可以说，MVP模式不就是将视图和逻辑分离嘛，你不使用MVP模式，也可以按照自己的理解进行良好的设计。但是，当一个团队开发项目时，问题就变得不同了。不同程序员的水平有一定差异，你无法通过他们的水平来确保他们代码都是良好设计的。<strong>你必须通过MVP模式来强制他们去思考如何分离界面和逻辑,否则，他们估计会把所有代码都写在Activity类中</strong>。我认为这是所谓模式和框架的第一层好处，也就是<strong>强迫程序员使用一个种良好的思维方式去思考如何进行代码组织</strong>。<br>&emsp;第二点的思考是，模式其实就是良好的代码思考的结晶，如何写出内聚的函数？如何写入内聚的类？如何让模块之间耦合小？如何命名？很多模式都是对这些问题思考结果的总和。<br>&emsp;如果大家对MVP或者移动开发框架有什么思考，欢迎在文章底下进行评论。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/eca06a79/" data-id="ck7kgwyko005xrase9c806fl0" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-《暗时间》摘要一" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/b3904609/">《暗时间》摘要一</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/b3904609/">
            <time datetime="2017-02-09T13:58:10.000Z" itemprop="datePublished">2017-02-09</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/思维/">思维</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;我阅读刘未鹏学长的博客文章已经很长时间了，今年过年前买了这本《暗时间》，希望能够充分的理解和学习他思维相关的知识和见解。我在去年也读过了一些书籍，但是都是匆匆阅读，很少有思考和反思；不能光读书，还要进行必要的思考，否则只是海绵型的学习模型，以后要做读书笔记和读后感。</p>
<h3 id="理智和情感"><a href="#理智和情感" class="headerlink" title="理智和情感"></a>理智和情感</h3><p>&emsp;这一章主要介绍了“一脑还是两脑”的问题。总所众知，我们的大脑分为左右两个半脑，不同的半脑的不同区域我们身体的不同部位。那么我们的思维是否也是如此？当我们进行思考或者做出决策时，这些大脑活动都来自于同一个区域吗？<br>&emsp;作者在本章的开始列举了很多因为大脑特定区域受伤而导致失去自控力和行为能力的例子，来证明我们大脑思维的分区域处理。作者将其分为情绪思维和理性思维。不同的大脑皮层区域负责二者，这些区域形成的时间不同。管理情绪思维的大脑皮层几乎从动物时代就存在了，但是理性思维的大脑皮层则是很晚才进化而来的。所以，理性思维区域要弱于情绪思维区域，这就导致了</p>
<blockquote>
<p>只要我们的情绪大脑首先认定了一件事情，我们那点可怜的理性思维便很容易屈从于情绪大脑发下的命令——把事情往利于自己的方向解释</p>
</blockquote>
<p>&emsp;细细想来，这使得生活中很多事情都得以解释。比如说，当人们为了一件事情付出了金钱，社会关系，很多很多以后，这些既有的付出便对他们的思维产生越来越强大的影响，我们的思维会被迫为自己的行为做出合理的解释，这也是为什么一些被骗钱的老年人会一次有一次的打给骗子越来越多的钱。在文章中，刘将其总结为</p>
<blockquote>
<p>只要一种解释是对自己有利的，我们便不想去推敲和反驳，再漏洞百出的事情看上去也不无可能，而且只要一种解释是有可能的，我们就认定其一定是的，强大的情绪大脑会阻止理性大脑去往深入了想。而对于对自己不利的解释，我们或者忽略，或者则会异常仔细去推敲，抓住一个漏洞则相信已完全推翻了该解释。</p>
<p>社会心理学研究发现，我们会对那些对自己有利的证据不加细查，而对那些对自己不利的证据则死抠烂打揪住一点小辫子就不放；同样，我们还会倾向于勤劳收集有利证据，并忽视不利证据。事实是，当我们内心的天平早已经倾斜了之后，看来荒谬无比的理由也变得光辉灿烂，别人很有道理的反驳也能被抠出“致命”漏洞。</p>
</blockquote>
<p>&emsp;文章的后半部分是关于如何克服这种人类心理的先天漏斗的和习惯的。大脑都是用进废退的，越经常使用的区域会越来越强大。如果你总是用情绪用事，不假思索，那么这种思维习惯便会越来强大，如果你总是理性思考，那么这样的思维习惯也会越来越强大。作者还提到了对于习惯的一些思考。</p>
<blockquote>
<p>惯之所以难以改变，就是因为习惯是自我巩固的，越用越强，越强越用。要想从既有习惯中跳出来，必然要依赖于外界的力量——对于心理机制的知识</p>
<p>能够改变既有的习惯，依靠的不是自制力，而是知识</p>
<p>很多时候我们无法自制是因为情绪大脑并不知道也并不承认这件事情是错误的。举个最稀松平常的例子，去学习还是去玩游戏（并不是提倡不玩游戏，这里只是说在你希望自己能够不玩游戏做点别的事情的那些时候，你能够成功地实现自己的愿望而不是纠结半天并败下阵来。），理智上我们倾向于认为学习是件“好”事情，游戏则常常是件“不好”的事情，然而情感上，我们认为学习是痛苦的，游戏是开心的。而开心的的确确就是一件好事情，痛苦就是一件不好的事情。两个大脑模块的声音完全相反。如果你无法说服你的情绪大脑，那么所谓的自制就是强迫和纠结，天人交战，正如前文所说，最后败下阵来的也往往是理性大脑</p>
</blockquote>
<p>&emsp;习惯的养成单靠自制力确实很难。关于例子，我想到了自己以前尝试早起的事情。每次想要早起的头一天晚上，我都下定决心明天要早起，但是一旦到了该起床的时间，我竟然总是可以找出理由来说服自己不需要早起，这个例子也和作者提出的玩游戏的例子很象，就是情绪大脑战胜了理性大脑。</p>
<h3 id="一直以来伴随我的一些学习习惯"><a href="#一直以来伴随我的一些学习习惯" class="headerlink" title="一直以来伴随我的一些学习习惯"></a>一直以来伴随我的一些学习习惯</h3><p>&emsp;作者列举了一些自己的学习习惯，很多都很重要，但是我只列出对我感触最大的几条，再加上自己的思考。</p>
<blockquote>
<p>看书只看经典，不解释。</p>
<p>做读书笔记，一是将自己阅读的时候的思考总结下来，二是将书中好的例子摘抄下来。我认为，人和人学习的差距不在资质上，而是在花在思考的时间和思考的广度。</p>
</blockquote>
<p>&emsp;做读书笔记其实只是形式，重要的总结和回顾！现在是信息时代，人们每天得到的信息量很大很大，我们要学会总结，在总结过程中思考，将别人的知识转换为自己的见解。而回顾则是为了更好的思考，所谓温故而知新就是这个道理。</p>
<blockquote>
<p>提到思考，我有一个小习惯。利用走路和吃饭的时候思考。这样一来往往不知不觉中多出大量的思考时间。</p>
</blockquote>
<p>&emsp;利用小片时间，很多文章中都有，这些都不提，我想要说的是，人们有些时候不去做一些事情，不是因为他不想做，而是因为他们根本没有想到可以做这些事情。回想自己的走路和吃饭时候，不过我还是喜欢吃饭就是吃饭，走路就是走路，想那么多，万一吃了墨怎么办？</p>
<blockquote>
<p>学习一项知识，必须要问自己三个重要的问题：1它的本质是什么？2它的第一原则是什么?3它的知识结构是什么？</p>
<p>关于习惯的养成，必须要说明的：经常看到有些人评论说，说说容易，做起来哪有那么容易啊（另一个无关习惯的“说起来容易做起来难”则是因为纸上谈兵不可能算计到所有现实中的因素，但那是另一个问题）。对此我要说的是，做起来当然不容易，所谓江山易改，本性难移。人的性格和认识事物的框架是长期积累养成的，并且人们非常珍视自己的信念（英语里面表达不相信某个东西叫做“I don’t buy it”）。从进化心理学上这是有依据的，一个经过时间检验的信念往往是更靠谱的。只不过可惜的是靠谱不代表最佳，一个信念能让你活下来并不代表能让你活得最好（详见<a href="http://www.douban.com/subject/1128662/" target="_blank" rel="noopener">《Mene Genes》</a>，更多的例子参见<a href="http://www.douban.com/subject/2383735/" target="_blank" rel="noopener">《How we know what isn’t so》</a>）。我们评判一个信念的标准是<a href="http://en.wikipedia.org/wiki/Satisficing" target="_blank" rel="noopener">satisficing</a>原则（即足够，能行就好，这个术语不是我提的，是大牛<a href="http://en.wikipedia.org/wiki/Herbert_A._Simon" target="_blank" rel="noopener">Herbert Simon</a>提的），并不是optimizing原则。话说回来，为什么说起来容易做起来难，是因为“说”只是理性上承认正确，并没有考虑到我们每个人大脑中居住的那个非理性自我。这个<a href="http://www.douban.com/subject/1193622/" target="_blank" rel="noopener">自我</a>以强大的情绪力量为动机，以习惯为己任，每时每刻都<a href="http://www.douban.com/subject/2990015/" target="_blank" rel="noopener">驱使着</a>我们的行为。因为它掌握了“情绪”这个武器，所以我们只能时时拿它当大爷。不记得是哪位哲学家说的了，理性是感性的奴隶。那么，是不是就是说无法克服既有习惯了？以我的经验（以及观察到的别人的经验），还是可以的。第一条就是认识到习惯的改变绝不是一天两天的事情，承认它的难度。第二条就是如果你真想改掉习惯，就需要在过程中常常注意观察自己的行为，否则习惯会以一种你根本觉察不到的方式左右你的行为让你功亏一篑。有一个认知技巧也许可以缓解更改习惯过程中的不适：即把居住在内心的那个非理性自我当成你自己的孩子（你要去培养他），或者你的对手（你要去打败他）也行。总之不能当成自己，因为每个人都不想改变自己。这里转一个认知技巧的例子：李笑来老师在<a href="http://www.xiaolai.net/?p=484" target="_blank" rel="noopener">《把时间当作朋友》</a>（顺便也推荐这本开放电子书）中<a href="http://www.xiaolai.net/?p=463" target="_blank" rel="noopener">提到</a>他一个朋友用另一个认知技巧来克服背单词的枯燥的</p>
</blockquote>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/b3904609/" data-id="ck7kgwykh005grasecvml1tjb" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Android性能优化-一-TraceView" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/e21717d9/">Android性能优化(一):TraceView</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/e21717d9/">
            <time datetime="2016-12-31T08:18:03.000Z" itemprop="datePublished">2016-12-31</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/工具/">工具</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;最近，我准备好好研究一下Android性能优化方面的相关知识，准备从应用流畅度开始，边看《移动App性能评测与优化》边自己实践，希望可以补足一下自己在优化这方面的空白。<br>&emsp;工欲善其事必先利其器，我先学习了TraceView这个大神器的使用方法。下面就来总结一下。<br>&emsp;为了节省你的时间，本文主要内容如下：</p>
<ul>
<li>TraceView两种使用方法</li>
<li>TraceView各项数据的含义</li>
</ul>
<h3 id="TraceView使用方法"><a href="#TraceView使用方法" class="headerlink" title="TraceView使用方法"></a>TraceView使用方法</h3><p>&emsp;TraceView有两种使用方法，一种是在DDMS上手动操作进行使用，还有一种方法是使用代码生成trace文件，然后在使用DDMS打开文件。我们以检测一个启动很慢的Activity为例来介绍。在应用中点击个人中心按钮，跳转到个人中心页面，但是这个过程有明显的卡顿。我们分别使用两个方法来检测这个过程。<br>&emsp;第一种方法是最简单也是最常用的使用方法。点击DDMS左侧的Start Method Profiling按钮(具体位置如图1,三个小箭头和红点的那个按钮)。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/20161231-tools-TraceView.png" alt="图1:TraceView启动按钮位置"></p>
<p>&emsp;然后点击个人应用中心按钮，等待个人中心页面显示出来，然后再次点击那个按钮，DDMS就会自动显示出如图2的界面。</p>
<p>&emsp;第一种方法很方便，但是精准度不够，当你希望有更加精确的检测时，你就可以使用第二种方法。在你要检测的代码过程中开始调用<code>android.os.Debug.startMethodTracing()</code>方法,然后在过程的末尾调用<code>android.os.Debug.stopMethodTracing()</code>方法。等到这段代码执行完之后，系统就会在手机的<code>/sdcard</code>文件夹下生成一个trace文件。你可以使用DDMS或者adb将其复制到你的电脑上，然后用DDMS工具打开。<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/20161231-tools-data.png" alt="图2:TraceView数据展示"></p>
<h3 id="TraceView各项数据分析"><a href="#TraceView各项数据分析" class="headerlink" title="TraceView各项数据分析"></a>TraceView各项数据分析</h3><p>&emsp;我很久之前就接触过TraceView，但是当时并没有完全理解它所展示的所有数据的具体含义，没有感受到它的强大之处。下面，我总结一下它的各项数据的含义和自己的理解。<br>&emsp;首先，我们可以看到一行表头，其中不同的项代表不同的内容。我们接下来一一进行解释。</p>
<h4 id="Incl-Cpu-Time"><a href="#Incl-Cpu-Time" class="headerlink" title="Incl Cpu Time"></a>Incl Cpu Time</h4><p><code>Incl Cpu Time</code>表示这个函数从开始被执行到执行结束的时间。这个时间包括这个函数中调用其他函数所花费的时间。也就是说，这个函数和函数中所有子函数的一共执行时间。举个例子：<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">  public void example() {
    a();
    b();
  }
</code></pre></p>
<p>&emsp;<code>Incl Cpu Time</code>就表示<code>example</code>函数执行的总时间，假如说<code>example</code>方法执行的时间为10ms,函数a执行了3ms,方法b执行了６ms，调用<code>example</code>方法的函数执行的总时间为100ms。最终计算出来的<code>Incl Cpu Time</code>比率为：</p>
<ul>
<li>example 10%</li>
<li>a 30%</li>
<li>b 60%</li>
</ul>
<p>&emsp;通过这个指标，我们可以看到一个函数的所有时间的占比，这个指标一般不会用到，因为我们一般都先查看所有函数的<code>Excl Cpu Time</code>指标。但是当你需要精确了解各个函数总执行时间并优化时，你还是需要先从这个函数入手。比如说优化应用冷启动时间，这个时候并没有明显的有较长<code>Excl Cpu Time</code>的函数，你需要对目标函数进行一点一点的分析和优化。而不是像寻找明显卡顿原因时的直接找<code>Excl Cpu Time</code>指标最大的函数。</p>
<h4 id="Excl-Cpu-Time"><a href="#Excl-Cpu-Time" class="headerlink" title="Excl Cpu Time"></a>Excl Cpu Time</h4><p>&emsp;理解了<code>Incl Cpu Time</code>，我们就可以轻易理解这个指标的含义啦。还是上边那个例子。我们可以计算出各个函数的<code>Incl Cpu Time</code>比例。</p>
<ul>
<li>example (10 - 3 -6)/100 = 1%</li>
<li>a 30%</li>
<li>b 60%<br>&emsp;从例子上来看，一个方法的<code>Excl Cpu Time</code>等于它的<code>Incl Cpu Time</code>减去它所有子函数的<code>Incl Cpu Time</code>。</li>
</ul>
<h4 id="Incl-Real-Time-和-Excl-Real-Time"><a href="#Incl-Real-Time-和-Excl-Real-Time" class="headerlink" title="Incl Real Time 和 Excl Real Time"></a>Incl Real Time 和 Excl Real Time</h4><p>&emsp;对这两条指标的理解主要涉及到对<code>Cpu time</code>和<code>Real time</code>的理解。Cpu Time 应该是某个方法占用CPU的时间;而Real Time 应该是这个方法的实际运行时间。因为Cpu的上下文切换，阻塞，等待等原因，Real Time 一般长于Cpu Time。</p>
<h4 id="Calls-Recur-Calls-Total"><a href="#Calls-Recur-Calls-Total" class="headerlink" title="Calls+Recur Calls/Total"></a>Calls+Recur Calls/Total</h4><p>&emsp;这个指标表示这个方法执行的总次数。Calls表示这个函数的调用次数，而Recur Calls表示递归调用次数。</p>
<h4 id="Cpu-Time-Calls-Real-Time-Calls"><a href="#Cpu-Time-Calls-Real-Time-Calls" class="headerlink" title="Cpu Time/Calls Real Time/Calls"></a>Cpu Time/Calls Real Time/Calls</h4><p>&emsp;这两个指标表示方法的每次调用的平均执行时间。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;有关TraceView的内容就介绍到这里，了解工具的使用只是开始，我们还需多在实践中应用这些工具，比如开发过程中发现有页面比较卡顿，那么我们就可以使用TraceView去检测一下！！！</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/e21717d9/" data-id="ck7kgwyhv000zrasek08cwfef" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/d5009955/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/java-persistent/">java persistent</a></p>
                            <p class="item-title"><a href="/article/d5009955/" class="title">Java 数据持久化系列之池化技术</a></p>
                            <p class="item-date"><time datetime="2020-02-02T13:48:17.000Z" itemprop="datePublished">2020-02-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/75dc863d/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/plan/">plan</a></p>
                            <p class="item-title"><a href="/article/75dc863d/" class="title">2020年，计划目录</a></p>
                            <p class="item-date"><time datetime="2020-01-27T05:00:09.000Z" itemprop="datePublished">2020-01-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/24b8edbf/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Redis/">Redis</a></p>
                            <p class="item-title"><a href="/article/24b8edbf/" class="title">Redis Cluster 的数据分片机制</a></p>
                            <p class="item-date"><time datetime="2019-12-21T13:24:26.000Z" itemprop="datePublished">2019-12-21</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/1dd72ef8/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Redis/">Redis</a></p>
                            <p class="item-title"><a href="/article/1dd72ef8/" class="title">Redis 命令执行过程(下)</a></p>
                            <p class="item-date"><time datetime="2019-12-11T15:09:14.000Z" itemprop="datePublished">2019-12-11</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/4cc1fb9/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Redis/">Redis</a></p>
                            <p class="item-title"><a href="/article/4cc1fb9/" class="title">Redis 命令执行过程(上)</a></p>
                            <p class="item-date"><time datetime="2019-12-09T14:25:54.000Z" itemprop="datePublished">2019-12-09</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SICP/">SICP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-persistent/">java persistent</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/plan/">plan</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计/">设计</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">3</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Animation/" style="font-size: 10px;">Animation</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GSON/" style="font-size: 10px;">GSON</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/JUC/" style="font-size: 20px;">JUC</a> <a href="/tags/Jenkins/" style="font-size: 10px;">Jenkins</a> <a href="/tags/Material-Design/" style="font-size: 10px;">Material Design</a> <a href="/tags/MotionEvent/" style="font-size: 10px;">MotionEvent</a> <a href="/tags/Netty/" style="font-size: 20px;">Netty</a> <a href="/tags/OkHttp/" style="font-size: 15px;">OkHttp</a> <a href="/tags/Raft/" style="font-size: 10px;">Raft</a> <a href="/tags/React-Native/" style="font-size: 10px;">React Native</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/SICP/" style="font-size: 10px;">SICP</a> <a href="/tags/Shader/" style="font-size: 10px;">Shader</a> <a href="/tags/Span/" style="font-size: 15px;">Span</a> <a href="/tags/Spring-Boot/" style="font-size: 15px;">Spring Boot</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/TCP-IP/" style="font-size: 20px;">TCP/IP</a> <a href="/tags/View/" style="font-size: 15px;">View</a> <a href="/tags/View-Architecture/" style="font-size: 10px;">View Architecture</a> <a href="/tags/ViewRoot/" style="font-size: 10px;">ViewRoot</a> <a href="/tags/Window机制/" style="font-size: 10px;">Window机制</a> <a href="/tags/animation/" style="font-size: 10px;">animation</a> <a href="/tags/cas/" style="font-size: 10px;">cas</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/draw/" style="font-size: 10px;">draw</a> <a href="/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/tags/filesystem/" style="font-size: 10px;">filesystem</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/kubernetes/" style="font-size: 10px;">kubernetes</a> <a href="/tags/persistent/" style="font-size: 15px;">persistent</a> <a href="/tags/redis/" style="font-size: 20px;">redis</a> <a href="/tags/scroll/" style="font-size: 15px;">scroll</a> <a href="/tags/spring-cloud/" style="font-size: 10px;">spring-cloud</a> <a href="/tags/事件传递/" style="font-size: 15px;">事件传递</a> <a href="/tags/依赖注入/" style="font-size: 10px;">依赖注入</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/动态编程/" style="font-size: 10px;">动态编程</a> <a href="/tags/反射/" style="font-size: 10px;">反射</a> <a href="/tags/图像处理/" style="font-size: 10px;">图像处理</a> <a href="/tags/实习/" style="font-size: 10px;">实习</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/工具-Linux/" style="font-size: 10px;">工具, Linux</a> <a href="/tags/市场/" style="font-size: 10px;">市场</a> <a href="/tags/并发/" style="font-size: 10px;">并发</a> <a href="/tags/思维/" style="font-size: 10px;">思维</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/文件系统/" style="font-size: 10px;">文件系统</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/注解/" style="font-size: 20px;">注解</a> <a href="/tags/第三方库/" style="font-size: 15px;">第三方库</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a> <a href="/tags/贪婪算法/" style="font-size: 10px;">贪婪算法</a> <a href="/tags/软件设计/" style="font-size: 10px;">软件设计</a> <a href="/tags/锁/" style="font-size: 10px;">锁</a> <a href="/tags/限流/" style="font-size: 15px;">限流</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://www.blueskykong.com/">aoho blog</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2020 历小冰<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
	<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
	<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
	<script>
		var gitment = new Gitment({
			owner: 'lexburner',
			repo: 'lexburner.github.io',
			oauth: {
				client_id: 'd5fc3e1150477a0d433d',
				client_secret: 'aa94acd5f130281051b9e703c19b4c6d878e90c4',
			},
		})
		gitment.render('commentContainer')
	</script>
	



    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
    



<link rel="stylesheet" href="/css/prism.css">
<script type="text/javascript" src="/js/prism.js"></script>
<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>