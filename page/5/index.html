
 <!DOCTYPE HTML>
<html lang="Chinese">
<head>
  <meta charset="UTF-8">
  
    <title>Carpediem</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="remCarpediem">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Carpediem">
<meta property="og:url" content="http://ztelur.github.io/page/5/index.html">
<meta property="og:site_name" content="Carpediem">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Carpediem">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="Carpediem" type="application/atom+xml">
    
    
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Carpediem">Carpediem</a></h1>
				<h2 class="blog-motto">blog of nobody</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:ztelur.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/02/04/图解Android事件传递之View篇/" title="图解Android事件传递之View篇" itemprop="url">图解Android事件传递之View篇</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2016-02-04T09:09:01.000Z" itemprop="datePublished"> 发表于 2016-02-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;最近放假在家里闲着，想好好研究一下android的事件传递机制。于是便抓来<code>View</code>,<code>ViewGroup</code>这些类的源代码来看；有很多疑惑，又在网上找到了几篇比较好的介绍事件传递机制的文章阅读了一番。然后想着最好把学习到的知识输出一遍，画成视图，写下这篇博文。<br>&emsp;除了图片，我还在源码上进行了注释，提交到了github上去。<a href="https://github.com/ztelur/AOSP-analysis/tree/master/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92" target="_blank" rel="external">我的github</a></p>
<h4 id="View的dispatchTouchEvent"><a href="#View的dispatchTouchEvent" class="headerlink" title="View的dispatchTouchEvent"></a>View的dispatchTouchEvent</h4><p><img src="http://7xrxif.com1.z0.glb.clouddn.com/touch-view1.png" alt="View-dispatchTouchEvent.png"></p>
<h4 id="View的onTouchEvent"><a href="#View的onTouchEvent" class="headerlink" title="View的onTouchEvent"></a>View的onTouchEvent</h4><p><img src="http://7xrxif.com1.z0.glb.clouddn.com/touch-view2.png" alt="View-onTouchEvent1.png"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/touch-view3.png" alt="View-onTouchEvent2.png"></p>
<h4 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h4><ul>
<li><a href="http://wangkuiwu.github.io/2015/01/05/TouchEvent-Sample-02-View/" target="_blank" rel="external">一位大神的博文，他的文章系列都值得看一看</a></li>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/9097463" target="_blank" rel="external">郭大神的博客</a></li>
<li><a href="http://www.infoq.com/cn/articles/android-event-delivery-mechanism" target="_blank" rel="external">很详细但有错误的地方的一篇经典文章</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/事件传递/">事件传递</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/02/04/图解Android事件传递之View篇/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/02/04/图解Android事件传递之View篇/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/02/02/《Redis设计和实现》读书笔记1-简单动态字符串/" title="《Redis设计和实现》读书笔记1-简单动态字符串" itemprop="url">《Redis设计和实现》读书笔记1-简单动态字符串</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2016-02-02T14:38:59.000Z" itemprop="datePublished"> 发表于 2016-02-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;临近过年，我离开了实习了4个多月的扇贝。临走前，导师赠送给我一本《Redis设计和实现》，于是心血来潮，想读一读这本书，然后仿照书中介绍的原理实现一个小型的数据库。这是redis系列的第一篇博文，希望我可以坚持下去，不要虎头蛇尾。</p>
<h4 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h4><p>&emsp;我们都知道Redis是由纯c代码编写而成的，而c语言中的原生字符串有很多的缺陷，不利于大型工程的使用。于是Redis的作者便自己实现一套字符串数据结构，就是sds.h/sdshdr结构。</p>
<h4 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sdshdr &#123;</span><br><span class="line">  <span class="comment">// 记录sdshdr中数组已经使用的数量</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="comment">// 记录sdshdr中数组未使用的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;<code>sdshdr</code>的定义如代码所示，其中<code>buf</code>属性为一个char类型的数组，数组的前五个字节分别保存着’R’,’e’,’d’,’i’,’s’五个字符，最后一个字符则保存则空字符串’\0’。之所以在数组尾部保存空字符，是为了可以使用一些c语言的字符串函数库中的函数。</p>
<h4 id="SDS与c字符串的区别"><a href="#SDS与c字符串的区别" class="headerlink" title="SDS与c字符串的区别"></a>SDS与c字符串的区别</h4><h5 id="常数时间内获得字符串长度"><a href="#常数时间内获得字符串长度" class="headerlink" title="常数时间内获得字符串长度"></a>常数时间内获得字符串长度</h5><p>&emsp;我们都知道，在c中，字符串就是一个末尾有一个’\0’的一维数组，它并不记录本身的长度。所以，每次想要获取其长度时，都需要遍历整个数组，时间复杂度就为O(n)；而SDS因为本身就有<code>len</code>这个字段，并且在SDS被修改时，会自动改变<code>len</code>字段，所以获得字符串长度的时间复杂度为O(1).</p>
<h5 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h5><p>&emsp;因为c的字符串没有任何安全保证，当我们使用<code>strcat</code>函数来拼接字符串时，如果目标字符串没有被分配足够空间的话，就会造成缓冲区溢出。而在SDS中，当然是每次修改都会进行缓冲区溢出检测，所以不会出现类似问题。</p>
<h5 id="减少修改字符串时带来的内存重新分配次数"><a href="#减少修改字符串时带来的内存重新分配次数" class="headerlink" title="减少修改字符串时带来的内存重新分配次数"></a>减少修改字符串时带来的内存重新分配次数</h5><p>&emsp;这一条应该是使用SDS最大的优势所在啦。因为c语言中的字符串都是无法修改的，所以每次拼接或者裁剪字符串都会导致新的字符串数据结构的生成，从而需要新的内存分配或者释放部分内存。由于内存分配很消耗时间，所以使用c语言的字符串会导致数据库性能低下。<br>&emsp;而SDS会通过空间预分配和惰性空间释放来减少内存分配或者释放的次数。<br>&emsp;内存预分配是指每次需要对SDS进行空间扩展时，程序不仅分配SDS所必须要的空间，还会额外分配一些空间，将其大小赋值给’free’属性。如果需要分配的大小为n，额外分配的空间为e，总共分配空间为t,那么(默认单位为字节)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = n &lt; 1MB ? n:1MB</span><br><span class="line">t = n &lt; 1MB ? n + n + 1 ? n + 1MB + 1</span><br></pre></td></tr></table></figure></p>
<p>&emsp;这样的话，下次再进行字符串拼接时，额外的空间就会被使用上，从而避免额外的一次内存分配。<br>&emsp;而惰性内存回收则是指裁剪字符串时，释放出来的额外空间并不会立刻被回收，而是继续保存，只是修改<code>len</code>和’free’属性，等到字符串再次被修改时使用。</p>
<h5 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h5><p>&emsp;由于c语言字符串以’\0’来判断字符串的结束，所以无法保存一些图片，音频，视频这些可能写入’\0’的二进制数据。</p>
<h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>&emsp;书里的内容很简单，希望自己也可以实现一个简单的string类型吧，不过不清楚java中String对象的实现欧，以后可以了解一下。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/c/">c</a>►<a class="article-category-link" href="/categories/c/数据结构/">数据结构</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/string/">string</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/02/02/《Redis设计和实现》读书笔记1-简单动态字符串/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/02/02/《Redis设计和实现》读书笔记1-简单动态字符串/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/01/16/师者的教导/" title="师者的教导" itemprop="url">师者的教导</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2016-01-16T09:48:11.000Z" itemprop="datePublished"> 发表于 2016-01-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;最近一段时间,我一边在扇贝实习,一边跟着学校里的导师进行本科毕业设计.在公司里,mentor言传身教的教导我写出更简洁和具有统一风格的代码;在学校里,导师耳提面命的教导我如何一步一步的进行科研论设计.虽然很忙碌,但是却收获很多.</p>
<h4 id="做好本职工作是否足够好"><a href="#做好本职工作是否足够好" class="headerlink" title="做好本职工作是否足够好?"></a>做好本职工作是否足够好?</h4><p>&emsp;扇贝公司是一个小厂,没有测试,设计给出的设计图和标注也不时会有些问题.我之前对此也有点不满,认为不给出标注或者色值会拖延开发进度,有时为了调整一个界面的margin,padding或者字号就要花费很长时间.但是mentor却认为这对我来说是一个很好的机会.因为我之前在腾讯实习时,设计给出的界面图很规范,使用dp进行标注,并且会有不同屏幕大小的标注.但是那样就养成了一种毫不思考和关心UI设计,交互设计,只是负责把设计的界面100%的实现出来就可以啦的习惯.但是在扇贝,我们可以和设计进行交流,提出更好的界面设计.为此我特定学习了一个Google力推的Material Design风格.<strong>好的员工,一定不是只做好了本职工作</strong>.我之前总是自以为是的认为快速就实现各类需求就是很好,却完全没有思考需求中设计和产品方面的考虑.</p>
<h4 id="你思维是否有局限性"><a href="#你思维是否有局限性" class="headerlink" title="你思维是否有局限性?"></a>你思维是否有局限性?</h4><p>&emsp;本周公司举行了年会,我们android组的成员和产品组的三个妹子一起表演一段舞蹈.我们可真不是跳舞的料啊,全靠妹子带领.于是我们约定在周六下午去公司再排练一下.mentor也真是把工作上的习惯带到了舞蹈排练中啊.一开始排练,就开始定下接下来半天中每1个小时的安排和任务.不过这样确实很有效果,虽然当时听他一本正经的说每个小时任务时感到十分搞笑.然后第二天时,他又一本正经的来找我,说我们忘记了一件事情.在我正在疑惑时,他说:”我们排练时把会议室的桌子移动啦,然后排练结束后没有把它恢复原位.”.说实话,当时我的心中有一万个草泥马飞奔而过啊.不过后来想一想,mentor这些做事情的思维或者规范确实有很多好处.我们那天下午舞蹈练的就很好,然后在年会中获得表演奖第三名.<strong>做事情都是有通用技巧的,很多时候,你只是没有想到需要使用技巧去做事</strong>.举个例子吧.每天中午吃完饭,我一般都会和同事在公司打乒乓球.我技术很不好,希望多练练,逐渐打好乒乓球.但是好像我除了每天去打乒乓球之外好像再没有做什么额外的事情,没有做那些让我在练习过程中能更好的提高的事情.为什么不找个视频学习一下打乒乓球的技巧,然后再在练习中进行对应的训练呢?这样不比你每次上去胡乱打要好的多吗?生活中这样的例子很多很多.</p>
<h4 id="你的弱项在哪里-怎么办"><a href="#你的弱项在哪里-怎么办" class="headerlink" title="你的弱项在哪里?怎么办?"></a>你的弱项在哪里?怎么办?</h4><p>&emsp;最近学校里的导师带着我在做程序缺陷分析方面的研究,想依此来写一篇本科毕业论文.在这期间,我犯了很多很多错误,现在回想起来还真是不应该.而且老师也善意的支持了我的优点和缺点,认为我多在涉及缺点的方面下功夫.<br>&emsp;首先,我和导师一周见一次面,讨论这一周内项目的进展和下一周的计划.其实,这样的交谈我应该每周都做一次记录的,但是我没有,导致项目进行到一半,再回顾早期讨论的内容,很多细节都不太记得啦.<strong>很多事情,要及时做好记录,回顾,和总结</strong>.这一点也可以用在工作中.每完成一个需求,其实可以做一次总结,把期间学习到的新知识(大概就是你google搜索到的代码逻辑)和犯的错误总结一下.<br>&emsp;然后导师认为我表达能力有问题,经常无法准确表达自己的观点,而且经常让别人无法理解自己话语的含义.所以他让我需要注意一下这方面.他还认为我的动手能力和理解能力都很强,但是表达能力有限,所以经常分配一些写作任务给我(就是把实验目的,计划,方案,原理写成文章的任务),依此来训练我.<strong>知道自己的强项和弱项,并进行提升</strong><br>&emsp;上一周导师和我讨论了写论文的比较重要的步骤或者过程.首先是这个观点或者题目是否有意义,是否值得做;然后是什么样的实现数据可以支持你的观;最后是如何实验来得出数据.<strong>三个过程的重要程度依此降低,如果前边的过程出现问题,那么后边过程所付出的努力就白费啦.</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;十分感谢两位老师的教育和指导.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/杂记/">杂记</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/01/16/师者的教导/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/01/16/师者的教导/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/01/01/Material-Design-标注图/" title="Material Design 标注图" itemprop="url">Material Design 标注图</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2016-01-01T10:40:33.000Z" itemprop="datePublished"> 发表于 2016-01-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;最近发现自己在实现产品需求时,在界面元素的细节部分把握不够准确,经常被leader告知需要微调一下界面元素的各类尺寸.虽然导致这个因素的最重要的原因是我场的设计太懒,不给标注,但是作为一个终端工程师,了解并掌握足够的设计相关的知识还是十分必要的,于是最近就开始研究其google的Material Design设计风格.<br>&emsp;本篇文章主要是收集一些MD风格的设计标注图和注意事项,主要内容都来自于<a href="http://www.uisdc.com/comprehensive-material-design-note#" target="_blank" rel="external">重磅教程！帮你全面彻底搞定MATERIAL DESIGN的学习笔记</a>.</p>
<blockquote>
<p>MD风格的精髓在于<br>把物理世界的体验带进屏幕,去掉现实的杂质和随机性,保留保留其最原始纯净的形态、空间关系、变化与过渡，配合虚拟世界的灵活特性，还原最贴近真实的体验，达到简洁与直观的效果</p>
</blockquote>
<p>&emsp;其实以我现在的理解就是:</p>
<ul>
<li>界面元素的层次性</li>
<li>交互时强调带有意义并且具有现实特性的动画</li>
<li>两种纯色作为应用的基本颜色</li>
</ul>
<p>&emsp;这篇只是收藏MD风格中关于一些特定界面元素的标注图以备以后使用</p>
<h4 id="文字排版"><a href="#文字排版" class="headerlink" title="文字排版"></a>文字排版</h4><p>常用字号：</p>
<ul>
<li>12sp 小字提示</li>
<li>14sp（桌面端13sp） 正文/按钮文字</li>
<li>16sp（桌面端15sp） 小标题</li>
<li>20sp Appbar文字</li>
<li>24sp 大标题</li>
<li>34sp/45sp/56sp/112sp 超大号文字</li>
</ul>
<p>&emsp;长篇幅正文，每行建议60字符（英文）左右。短文本，建议每行30字符（英文）左右。</p>
<h4 id="常用尺寸"><a href="#常用尺寸" class="headerlink" title="常用尺寸"></a>常用尺寸</h4><blockquote>
<p>所有可操作元素最小点击区域尺寸：48dp X 48dp。<br>  栅格系统的最小单位是8dp，一切距离、尺寸都应该是8dp的整数倍。以下是一些常见的尺寸与距离：</p>
</blockquote>
<ul>
<li>顶部状态栏高度：24dp</li>
<li>Appbar最小高度：56dp</li>
<li>底部导航栏高度：48dp</li>
<li>悬浮按钮尺寸：56x56dp/40x40dp</li>
<li>用户头像尺寸：64x64dp/40x40dp</li>
<li>小图标点击区域：48x48dp</li>
<li>侧边抽屉到屏幕右边的距离：56dp</li>
<li>卡片间距：8dp</li>
<li>分隔线上下留白：8dp</li>
<li>大多元素的留白距离：16dp</li>
<li>屏幕左右对齐基线：16dp</li>
<li><p>文字左侧对齐基线：72dp<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_a-33.png" alt="enter image description here"></p>
<h4 id="Button-sheets"><a href="#Button-sheets" class="headerlink" title="Button sheets"></a>Button sheets</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_button_sheet_1.png" alt="enter image description here"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_button_sheet_2.png" alt="enter image description here"></p>
<h4 id="Buttons"><a href="#Buttons" class="headerlink" title="Buttons"></a>Buttons</h4><p>&emsp;按钮分为悬浮按钮,凸起按钮和扁平按钮</p>
</li>
<li><p>悬浮按钮的操作都是正向操作</p>
</li>
<li>建议只用一个悬浮按钮</li>
<li>悬浮按钮可以贴在纸片边缘或者接缝处，但不要贴在对话框、侧边抽屉和菜单的边缘</li>
<li>悬浮按钮不能被其他元素盖住，也不能挡住其他按钮</li>
<li>列表滚动至底部时，悬浮按钮应该隐藏，防止它挡住列表项<br>悬浮按钮的位置不能随意摆放，可以贴着左右两边的对齐基线</li>
</ul>
<h4 id="Cards"><a href="#Cards" class="headerlink" title="Cards"></a>Cards</h4><ul>
<li>卡片统一带有2dp的圆角</li>
<li>同时展现多种不同内容</li>
<li>卡片内容之间不需要进行比较</li>
<li>包含了长度不确定的内容，比如评论</li>
<li>包含丰富的内容与操作项，比如赞、滚动条、评论</li>
<li>本该是列表，但文字超过3行</li>
<li><p>本该是网格，但需要展现更多文字<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_cards_1.png" alt="enter image description here"></p>
<h4 id="Dialogs"><a href="#Dialogs" class="headerlink" title="Dialogs"></a>Dialogs</h4></li>
<li><p>注意有些对话框点击周围会消失,但是有些是不会消失的</p>
</li>
<li><p>对话框的四周留白比较大，通常是24dp。<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_dialog_1.png" alt="enter image description here"></p>
<h4 id="Dividers"><a href="#Dividers" class="headerlink" title="Dividers"></a>Dividers</h4></li>
<li><p>列表中有头像、图片等元素时，使用内嵌分隔线，左端与文字对齐。</p>
</li>
<li>没有头像、图标等元素时，需要用通栏分隔线。</li>
<li>谨慎使用分隔线，留白和小标题也能起到分隔作用。能用留白的地方，优先使用留白。分隔线的层级高于留白。</li>
</ul>
<h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><ul>
<li><p>列表由行构成，行内包含瓦片。如果列表项内容文字超过3行，请改用卡片。如果列表项的主要区别在于图片，请改用网格。<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_list_1.png" alt="enter image description here"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_list_2.png" alt="enter image description here"></p>
<h4 id="Pickers"><a href="#Pickers" class="headerlink" title="Pickers"></a>Pickers</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_pickers_1.png" alt="日期选择器"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_pickers_1.png" alt="时间选择器"></p>
<h4 id="Progress-amp-activity"><a href="#Progress-amp-activity" class="headerlink" title="Progress &amp; activity"></a>Progress &amp; activity</h4></li>
<li><p>进度条分为确定时间和不确定时间,不同的类型,动画效果不同</p>
</li>
<li>进度条可以使用在一些本来就有的元素上,比如悬浮按钮</li>
</ul>
<h4 id="Snackbars"><a href="#Snackbars" class="headerlink" title="Snackbars"></a>Snackbars</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_snackbars_1.png" alt="snackbars尺寸"></p>
<h4 id="Text-fields"><a href="#Text-fields" class="headerlink" title="Text fields"></a>Text fields</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_text_fields_1.png" alt="Text1"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_text_fields_2.png" alt="Text2"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_text_fields_3.png" alt="Text3"></p>
<h4 id="NavigatorBar"><a href="#NavigatorBar" class="headerlink" title="NavigatorBar"></a>NavigatorBar</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_navigator_1.png" alt="navigator尺寸"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计/">设计</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Material-Design/">Material Design</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/01/01/Material-Design-标注图/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/01/01/Material-Design-标注图/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/12/Android文件存储位置简述/" title="Android文件存储位置简述" itemprop="url">Android文件存储位置简述</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-12-12T09:11:54.000Z" itemprop="datePublished"> 发表于 2015-12-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;最近一段时间,工作和学习方面都比较忙,所以,博客方面有一段时间没有投入时间啦,今天学习了一下android文件存储方面的知识,主要是<code>Internal Storage</code>和<code>External Storage</code>的相关特性.主要知识来自android的官方文档和其他人的博客.</p>
<h4 id="Internal-Storage"><a href="#Internal-Storage" class="headerlink" title="Internal Storage"></a>Internal Storage</h4><p>&emsp;一般来说,你可以直接存储文件在机器的internal storage中,存储在这个位置的文件是私有的,其他应用无法获得.但是当用户卸载你的应用时,文件就被删除啦.</p>
<blockquote>
<p>通过<code>openFileOutput()</code>传入文件的名字和操作模式,就可以获得<code>FileOutputStream</code>,然后就可以<code>write()</code>,然后<code>close</code>啦.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String FILENAME = <span class="string">"hello_file"</span>;</span><br><span class="line">String string = <span class="string">"hello world!"</span>;</span><br><span class="line"></span><br><span class="line">FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);</span><br><span class="line">fos.write(string.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure></p>
<p><code>MODE_PRIVATE</code>模式会创建或者替换同名文件,并让文件变为私有的,其他的一些模式还有<code>MODE_APPEND</code>(追加模式),<code>MODE_WORLD_READABLE</code>(全局可读)和<code>MODE_WORLD_WRITEABLE</code>(全局可写).<br>通过<code>OpenFileInput()</code>函数可以进行文件的读取.</p>
</blockquote>
<p>&emsp;Android的内部存储路径为/data/data/packagename/,加入你的应用名为com.example.test,那么这个路径就为/data/data/com.example.test,这个路径下一般会有files,cache和你自己生成的文件夹.那么如下的操作返回的路径如下</p>
<ul>
<li>Context.getFileDir(),获得/data/data/com.example.test/files这个文件夹的File对象</li>
<li>Context.openFileInput()和Context.openFileOutput,读取的是files文件夹下的文件</li>
<li>Context.fileList(),返回的是files下的所有文件名</li>
<li>Context.deleteFile(),删除files下指定名称的文件</li>
<li>Context.getCacheDir(),该方法返回的是/data/data/com.example.test/cache的File对象.当Android的内部存储容量过低时,android会自动清除缓存文件.</li>
<li>getDir(String name,int mode),返回的是/data/data/com.example.test/下指定名称的文件夹的File对象</li>
</ul>
<h4 id="External-Storage"><a href="#External-Storage" class="headerlink" title="External Storage"></a>External Storage</h4><p>&emsp;所有android设备都会提供外部存储,你可以用来保存文件,但是存储在外部存储的文件是完全公开的,并且可以被用户修改,外部存储可能无法获得,并且存储的文件的安全性很低,会被修改或者删除.<br>&emsp;获得    外部存储的访问权必须需要申请<code>READ_EXTERNAL_STORAGE</code>或者<code>WRITE_EXTERNAL_STORAGE</code>权限,如果申请了写权限,那么相应的读权限也获得啦.如果是Android 6.0,那么权限的申请可能就更加麻烦 :<a href="http://jijiaxin89.com/2015/08/30/Android-s-Runtime-Permission/" target="_blank" rel="external">6.0新的权限管理系统</a><br>&emsp;在使用外部存储设备之前,必须先检查外部存储设备的挂载情况,然后再进行文件操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Checks if external storage is available for read and write */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExternalStorageWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Checks if external storage is available to at least read */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExternalStorageReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state) ||</span><br><span class="line">        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;如果你想存储一些可以和其他应用共享的文件时,一般存储在共享的文件夹中,比如<code>Music/</code>,’Pictures/‘,’Ringtones/‘通过<code>Environment.getExternalStoragePublicDirectory</code>,传递给其文件夹的类型,比如<code>DIRECTORY_MUSIC</code>,<code>DIRECTORY_PICTURES</code>,就可以获得响应文件夹的File对象.<br>&emsp;当你不想其他应用读取你的文件时,你可能需要使用私有文件夹.通过<code>getExternalFilesDir()</code>,并传递给其子文件夹的type,就可以打开响应的文件夹,在4.4之后,读取私有文件夹下的文件,是不需要外部存储设备权限的.<br>&emsp;外部存储设备的路径一般都以/mnt/sdcard开始,如下的一些函数获得路径如下:</p>
<ul>
<li>getExternalCacheDir() 获得/mnt/sdcard/Android/data/com.example.test/cache 文件夹的File对象</li>
<li>getExternalFilesDir(type)获得/mnt/sdcard/Android/data/com.example.test/files文件夹下响应子文件夹的File对象</li>
<li>Environment.getExternalStorageDiretory() 获得的是/mnt/sdcard文件夹的File对象</li>
<li>Environment.getDataDirectory() 获得是的/data文件夹的File对象,需要注意的是,/data/data/Android/就是内部存储文件夹啦.</li>
<li>Environment.getDownloadCacheDirectory() 获得的是/cache文件夹的File对象.</li>
</ul>
<p>参考文章:</p>
<ul>
<li><a href="http://blog.csdn.net/ljh347917444/article/details/16984199" target="_blank" rel="external">android 系统文件路径.sdcard路径.外部路径</a> </li>
<li><a href="http://developer.android.com/intl/zh-cn/guide/topics/data/data-storage.html#filesInternal" target="_blank" rel="external">Android Doc</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/文件系统/">文件系统</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/12/12/Android文件存储位置简述/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/12/12/Android文件存储位置简述/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/18/OkHttp解析系列-重定向和出错重试/" title="OkHttp解析系列-重定向和出错重试" itemprop="url">OkHttp解析系列-重定向和出错重试</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-11-18T14:00:10.000Z" itemprop="datePublished"> 发表于 2015-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emps;这是OkHttp系列博文的第一篇，之前写过一篇草稿，介绍OkHttp的整体框架，但是感觉涉及的知识太多，无法在一篇中讲述清楚，所以，之后的博文都只关注某一方面的知识，争取文章短小精悍。<br>&emsp;今天主要研究一下OkHttp发送<code>Http</code>请求过程中的重定向和出错重试，主要涉及的源码文件有<code>Call.java``HttpEngine.java</code>。<br>&emsp;我们今天研究<code>Call</code>的<code>Response getResponse(Request request, boolean forWebSocket) throws IOException</code>函数，它是你调用<code>Call.execute()</code>返回<code>Response</code>所调用的核心函数，主要功能是新建一个<code>HttpEngine</code>发送<code>Request</code>然后处理出错重试和重定向问题。</p>
<h4 id="设置Headers"><a href="#设置Headers" class="headerlink" title="设置Headers"></a>设置Headers</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy body metadata to the appropriate request headers.</span></span><br><span class="line">  RequestBody body = request.body();</span><br><span class="line">  <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Request.Builder requestBuilder = request.newBuilder();<span class="comment">//拷贝了内部数据</span></span><br><span class="line"></span><br><span class="line">    MediaType contentType = body.contentType();</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">    <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request = requestBuilder.build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;这是函数的第一部分，主要是将<code>RequestBody</code>的一些元数据拷贝到<code>Header</code>的首部中,主要是<code>Content-Type</code>和<code>Transfer-Encoding</code>。<code>Content-Type</code>相信大家都了解，标示<code>RequestBody</code>的<code>Mime-Type</code>，格式为<code>主类型/子类型</code>，比如<code>text/xml</code>。而<code>Transfer-Encoding</code>是表示一种网络传输的方式，想具体了解的同学可以看一下这个链接<a href="https://imququ.com/post/transfer-encoding-header-in-http.html" target="_blank" rel="external">点我</a>.</p>
<h4 id="出错重试"><a href="#出错重试" class="headerlink" title="出错重试"></a>出错重试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the initial HTTP engine. Retries and redirects need new engine for each attempt.</span></span><br><span class="line">    <span class="comment">// 建立一个初始的http 引擎，每次重试和重定向都需要新的引擎</span></span><br><span class="line">    engine = <span class="keyword">new</span> HttpEngine(client, request, <span class="keyword">false</span>, <span class="keyword">false</span>, forWebSocket, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>; <span class="comment">//连续发送请求</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (canceled) &#123; <span class="comment">//如果被取消啦</span></span><br><span class="line">        engine.releaseConnection();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        engine.sendRequest();</span><br><span class="line">        engine.readResponse();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RequestException e) &#123;</span><br><span class="line">        <span class="comment">// The attempt to interpret the request failed. Give up.</span></span><br><span class="line">        <span class="keyword">throw</span> e.getCause();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        HttpEngine retryEngine = engine.recover(e); <span class="comment">//重试引擎</span></span><br><span class="line">        <span class="keyword">if</span> (retryEngine != <span class="keyword">null</span>) &#123;</span><br><span class="line">          engine = retryEngine;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Give up; recovery is not possible.</span></span><br><span class="line">        <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        HttpEngine retryEngine = engine.recover(e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (retryEngine != <span class="keyword">null</span>) &#123;</span><br><span class="line">          engine = retryEngine;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Give up; recovery is not possible.</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">      .......</span><br></pre></td></tr></table></figure>
<p>&emsp;在这段代码中，<code>OkHttp</code>建立一个<code>HttpEngine</code>对象来负责<code>Http</code>层级的请求的发送和回复的接收，<code>HttpEngine</code>会在之后的博文中详细讲解。然后进入了一个<code>while</code>循环,这个循环其实主要是处理重定向问题的。我们在这一节中主要关注<code>catch</code>中的逻辑，这是用于处理出错重试的逻辑。由于外层有一个<code>while</code>循环，所以在<code>catch</code>中尝试获得<code>retryEngine</code>，如果有就<code>continue</code>,没有就抛出异常。</p>
<h4 id="重定向处理"><a href="#重定向处理" class="headerlink" title="重定向处理"></a>重定向处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Response response = engine.getResponse();</span><br><span class="line">      <span class="comment">// followUp这个是优化http connection的使用率的吗？</span></span><br><span class="line">      Request followUp = engine.followUpRequest();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!forWebSocket) &#123; <span class="comment">//如果没有followup并且不是为了websocket</span></span><br><span class="line">          engine.releaseConnection();<span class="comment">//关闭连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!engine.sameConnection(followUp.httpUrl())) &#123; <span class="comment">//如果followup的httpUrl不是同一个连接,也就是</span></span><br><span class="line">        <span class="comment">//schema，host or port 有一个不同</span></span><br><span class="line">        engine.releaseConnection();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//复用了上一次的connection啊！！！！</span></span><br><span class="line">      Connection connection = engine.close();</span><br><span class="line">      request = followUp;</span><br><span class="line">      <span class="comment">//继续处理，有可能是重定向啦</span></span><br><span class="line">      engine = <span class="keyword">new</span> HttpEngine(client, request, <span class="keyword">false</span>, <span class="keyword">false</span>, forWebSocket, connection, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">          response);</span><br></pre></td></tr></table></figure>
<p>&emsp;这里我们可以看到<code>Http</code>重定向的机制。<code>Request request = engine.followUpRequest()</code>来获得重定向需要发送的<code>Request</code>，如果没有或者重定向次数大于<code>MAX_FOLLOW_UPS</code>就不会重新发送重定向请求。然后判断重定向请求和原请求的HttpUrl是否相同，否则也不会发送重定向请求。然后<code>Connection connection = engine.close()</code>会释放资源并且复用上次的连接，然后新建一个<code>HttpEngine</code>然后继续<code>While</code>循环发送请求。</p>
<h4 id="重定向状态码解析"><a href="#重定向状态码解析" class="headerlink" title="重定向状态码解析"></a>重定向状态码解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">followUpRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (userResponse == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  Proxy selectedProxy = getRoute() != <span class="keyword">null</span></span><br><span class="line">      ? getRoute().getProxy()</span><br><span class="line">      : client.getProxy();</span><br><span class="line">  <span class="keyword">int</span> responseCode = userResponse.code();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (responseCode) &#123;</span><br><span class="line">    <span class="keyword">case</span> HTTP_PROXY_AUTH: <span class="comment">//407 Proxy authentication required 要先经过代理服务器认证</span></span><br><span class="line">      <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// fall-through</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_UNAUTHORIZED: <span class="comment">//401 没有身份认证</span></span><br><span class="line">      <span class="keyword">return</span> OkHeaders.processAuthHeader(client.getAuthenticator(), userResponse, selectedProxy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> HTTP_PERM_REDIRECT:<span class="comment">// 308</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_TEMP_REDIRECT: <span class="comment">//307</span></span><br><span class="line">      <span class="comment">// "If the 307 or 308 status code is received in response to a request other than GET</span></span><br><span class="line">      <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span></span><br><span class="line">      <span class="keyword">if</span> (!userRequest.method().equals(<span class="string">"GET"</span>) &amp;&amp; !userRequest.method().equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="comment">//如果不是get和head 那么就不能自动转发</span></span><br><span class="line">      <span class="comment">// fall-through</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_MULT_CHOICE: <span class="comment">//300</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_MOVED_PERM:<span class="comment">// 301</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_MOVED_TEMP:<span class="comment">//302</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_SEE_OTHER: <span class="comment">//303</span></span><br><span class="line">      <span class="comment">// Does the client allow redirects?</span></span><br><span class="line">      <span class="keyword">if</span> (!client.getFollowRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//如果不允许重定向</span></span><br><span class="line"></span><br><span class="line">      String location = userResponse.header(<span class="string">"Location"</span>);<span class="comment">//从response的头部获得的location</span></span><br><span class="line">      <span class="keyword">if</span> (location == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      HttpUrl url = userRequest.httpUrl().resolve(location);<span class="comment">//使用request的解析location</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Don't follow redirects to unsupported protocols.</span></span><br><span class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If configured, don't follow redirects between SSL and non-SSL.</span></span><br><span class="line">      <span class="keyword">boolean</span> sameScheme = url.scheme().equals(userRequest.httpUrl().scheme());</span><br><span class="line">      <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.getFollowSslRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Redirects don't include a request body.</span></span><br><span class="line">      Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.permitsRequestBody(userRequest.method())) &#123;</span><br><span class="line">        requestBuilder.method(<span class="string">"GET"</span>, <span class="keyword">null</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Type"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></span><br><span class="line">      <span class="comment">// is potentially annoying to the application layer since they have no</span></span><br><span class="line">      <span class="comment">// way to retain them.</span></span><br><span class="line">      <span class="keyword">if</span> (!sameConnection(url)) &#123;</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Authorization"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> requestBuilder.url(url).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;这一段就是根据回复的状态码生成重定向请求的代码逻辑。</p>
<ul>
<li>HTTP_PROXY_AUTH 407  表示需要经过代理服务器认证 ，这时抛出异常，不进行重定向</li>
<li>HTTP_UNAUTHORIZED 401 身份未认证</li>
<li>HTTP_PERM_REDIRECT 308 HTTP_TEMP_REDIRECT 307 这两种状态码时，只有当请求的<code>method</code>不为<code>GET</code>和<code>HEAD</code>时不进行重定向，否则按照下边一列状态码的方式处理</li>
<li>HTTP_MULT_CHOICE  300 HTTP_MOVED_PERM 301 HTTP_MOVED_TEMP 302 HTTP_SEE_OTHER 303 当是这些状态码时，先判断是否运行重定向，然后获得<code>Response</code>中的<code>Location</code>首部的值，然后用<code>HttpUrl</code>去解析，如果是<code>host</code>不同，那么去掉所有的认证首部，这是为了安全。<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4>&emsp;今天所总结的只是<code>Http</code>的重定向部分和<code>OkHttp</code>中的关于重定向的逻辑部分。之后会陆陆续续的继续总结关于<code>Http</code>的知识。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/NetWork/">NetWork</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/OkHttp/">OkHttp</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/18/OkHttp解析系列-重定向和出错重试/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/18/OkHttp解析系列-重定向和出错重试/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/07/OkHttp解析系列-开篇/" title="OkHttp解析系列-开篇" itemprop="url">OkHttp解析系列-开篇</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-11-07T03:55:04.000Z" itemprop="datePublished"> 发表于 2015-11-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>&emsp;前几天使用<code>react-native</code>遇到了底层<code>okhttp</code>库<code>cookie</code>无法保存的问题，由于自己对http和<code>okhttp</code>也不是很了解.所以想开一个系列的博文，借助详细解析<code>okhttp</code>的详细解析来梳理一下http相关的知识。</p>
<h4 id="Okhttp"><a href="#Okhttp" class="headerlink" title="Okhttp"></a>Okhttp</h4><p>&emsp;<code>Okhttp</code>是很火而且效率很好的一个android的网络库，被很多app或者开源库使用或者集成，比如<code>react-native</code>,官网地址如下<a href="http://square.github.io/okhttp/" target="_blank" rel="external">戳我</a>.</p>
<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p>&emsp;事先声明，我画的这张UML类图不够标准，正方形的虚线边框是我自己添加上去的，只是逻辑上或者概念上的分类，标示这些类大致是属于哪个模块的，而且也没有添加各个类之间的依赖关系。之所以使用这张图，主要是希望表面<code>okhttp</code>代码的不同模块吧。也算为以后的博客进行内容区分。<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/okhttpOkHttp%E5%8D%9A%E5%AE%A2.jpg" alt="enter image description here"></p>
<h4 id="Okhttp模块"><a href="#Okhttp模块" class="headerlink" title="Okhttp模块"></a>Okhttp模块</h4><p>&emsp;之后的博客，就会按照上图的不同模块来进行，首先是<code>OkHttp</code>的主要框架模块，然后是请求和响应相关的模块，然后是关于http机制的模块，最后是关于http报文格式的模块。现在计划是如此，可能在博文之间会添加一些http知识。就这么愉快的决定啦。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/NetWork/">NetWork</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/OkHttp/">OkHttp</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/07/OkHttp解析系列-开篇/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/07/OkHttp解析系列-开篇/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/04/React-Native-Android-Cookie-Problem/" title="React Native Android Cookie Problem" itemprop="url">React Native Android Cookie Problem</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-11-04T05:50:31.000Z" itemprop="datePublished"> 发表于 2015-11-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>&emsp;最近使用react native 来写一个公司内部使用的app，使用<code>fetch</code>去登陆，发现在android平台上无法获取cookie，iOS平台上却可以。即使是<code>response.headers.get()</code>也获得不了相关信息。于是上网google并且阅读源码，终于找到了问题出现的原因和解决方案。</p>
<h4 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h4><p>&emsp;我们查看<code>native react</code>的<code>fetch.js</code>的代码，发现它的底层是使用<code>XmlHttpRequest</code>来实现的，然后再次找到’XmlHttpRequest’的相关源码，发现了三个文件<code>XMLHttpRequest.android.js</code>,<code>XMLHttpRequest.ios.js</code>和<code>XMLHttpRequestBase.js</code>。我们主要研究了android相关的文件。<br>&emsp;先看’XMLHttpRequest.android.js’。它继承了<code>XMLHttpRequestBase</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XMLHttpRequest</span> <span class="keyword">extends</span> <span class="title">XMLHttpRequestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  _requestId: ?number;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>._requestId = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sendImpl(method: ?string, url: ?string, headers: <span class="built_in">Object</span>, data: any): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'string'</span>) &#123;</span><br><span class="line">      body = &#123;string: data&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> FormData) &#123;</span><br><span class="line">      body = &#123;</span><br><span class="line">        formData: data.getParts().map((part) =&gt; &#123;</span><br><span class="line">          part.headers = convertHeadersMapToArray(part.headers);</span><br><span class="line">          <span class="keyword">return</span> part;</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      body = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//RCTNetWorking是android的native module，使用okhttp实现，我们之后会看到相关的代码</span></span><br><span class="line">    <span class="keyword">this</span>._requestId = RCTNetworking.sendRequest(</span><br><span class="line">      method,</span><br><span class="line">      url,</span><br><span class="line">      convertHeadersMapToArray(headers),</span><br><span class="line">      body,</span><br><span class="line">      <span class="keyword">this</span>.callback.bind(<span class="keyword">this</span>)<span class="comment">//这里是调用native module的回调，具体callback实现在XMLHttpRequestBase中。</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  abortImpl(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._requestId &amp;&amp; RCTNetworking.abortRequest(<span class="keyword">this</span>._requestId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;通过源码，我们可以了解，<code>XMLHttpRequest</code>就是通过Android Native Module 来发送网络请求的，然后会回调到<code>callback</code>函数中。我们接下来看看一下<code>callback</code>函数.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">callback(status: number, responseHeaders: ?<span class="built_in">Object</span>, responseText: string): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._aborted) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.status = status;</span><br><span class="line">  <span class="keyword">this</span>.setResponseHeaders(responseHeaders || &#123;&#125;);</span><br><span class="line">  <span class="keyword">this</span>.responseText = responseText;</span><br><span class="line">  <span class="keyword">this</span>.setReadyState(<span class="keyword">this</span>.DONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;这里我们发现<code>callback</code>回调有三个参数,<code>status</code>,<code>responseHeaders</code>和<code>responseText</code>,那么为什么在外层的<code>fetch</code>会拿不到<code>header</code>中的<code>cookie</code>呢？这里就需要研究android native module的实现啦。<br>&emsp;<code>RCTNetworking</code>对应的java文件为<code>NetworkingModule.java</code>，找到这个文件，直接看<code>sendRequest</code>函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReactMethod</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(</span><br><span class="line">    String method,</span><br><span class="line">    String url,</span><br><span class="line">    <span class="keyword">int</span> requestId,</span><br><span class="line">    ReadableArray headers,</span><br><span class="line">    ReadableMap data,</span><br><span class="line">    <span class="keyword">final</span> Callback callback)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//....... 无关代码省略</span></span><br><span class="line">  mClient.newCall(requestBuilder.build()).enqueue(</span><br><span class="line">      <span class="keyword">new</span> com.squareup.okhttp.Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (mShuttingDown) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          callback.invoke(<span class="number">0</span>, <span class="keyword">null</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (mShuttingDown) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// TODO(5472580) handle headers properly</span></span><br><span class="line">          String responseBody;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            responseBody = response.body().string();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// The stream has been cancelled or closed, nothing we can do</span></span><br><span class="line">            <span class="comment">//这里是重点，我们发现第二个参数本该传递header,但是现在确实传的null，导致上层的js代码无法获得header!!!!</span></span><br><span class="line">            callback.invoke(<span class="number">0</span>, <span class="keyword">null</span>, e.getMessage());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          callback.invoke(response.code(), <span class="keyword">null</span>, responseBody);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####解决方案<br>&emsp;在<code>fetch</code>或者<code>XMLHttpRequest</code>拿不到头部信息的问题找到了，那么如何让react native android实现cookie呢？<br>&emsp;方案有两套，一是：<code>callback.invoke</code>时把头部信息传递上去，让js层去做cookie的相关逻辑；二是:给<code>Okhttp</code>添加<code>CookieHandler</code>让<code>Okhttp</code>自己管理<code>Cookie</code>。<br>&emsp;第二套方案是我在github上看到的<a href="https://github.com/facebook/react-native/pull/3723/files" target="_blank" rel="external">github相关讨论和code</a>，相关代码在github上已经被merge到master上去啦，相信不久之后，新版本的<code>React Native Android</code>就可以把这个坑填上啦。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/React-Native/">React Native</a><a href="/tags/Cookie/">Cookie</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/04/React-Native-Android-Cookie-Problem/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/04/React-Native-Android-Cookie-Problem/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/28/Window和WindowManager解析/" title="Window和WindowManager解析" itemprop="url">Window和WindowManager解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-10-28T07:35:51.000Z" itemprop="datePublished"> 发表于 2015-10-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;这几天阅读了《Android开发艺术探索》的关于Window和WindowManager的章节,特此写一片博文来整理和总结一下学到的知识.<br>&emsp;说到Window,大家都会想到所有的视图,包括Activity,Dialog,Toast,它们实际上都是附加在Window上的,Window是这些视图的管理者.今天我们就来具体将一下这些视图是如何附加在Window上的,Window有是如何管理这些视图的.</p>
<h4 id="Window的属性和类别"><a href="#Window的属性和类别" class="headerlink" title="Window的属性和类别"></a>Window的属性和类别</h4><p>&emsp;当我们通过WindowManager添加Window时,可以通过WindowManger.LayoutParams来确定Window的属性和类别.其中Flags参数标示Window的属性,我们列出几个比较常见的属性:</p>
<ul>
<li><p><code>FLAG_NOT_FOCUSABLE</code> 这个参数表示Window不需要获取焦点,也不需要接收任何输入事件</p>
</li>
<li><p><code>FLAG_NOT_TOUCH_MODAL</code> 这个参数表示当前Window区域之外的点击事件传递给底层Window,区域之内的点击事件自己处理,一般默认开启</p>
</li>
<li><p><code>FLAG_SHOW_WHEN_LOCKED</code> 这个属性可以让Window显示在锁屏界面上<br>&emsp;Window不仅有属性,还有类型.Type参数表示Window的类型,分别为应用Window(activity对应的),子window(dialog对应的),和系统Window(Toast和系统通知栏).Window是分层的,每个window都有z-ordered,层级大的window会覆盖层级小的window,其大小关系为系统window&gt;子window&gt;应用window.所以系统window总会显示在最上边,但是使用系统window是需要声明相应的权限的.这一点需要注意.</p>
<h4 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h4><p>&emsp;我们先来看一下WindowManager的接口,对其接口函数的了解有助于我们更好的理解Window的类别和属性.<br>&emsp;WindowManger实现了ViewManager这个接口,所提供的主要函数只有三个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params);</span><br><span class="line">public void updateViewLayout(View view, ViewGroup.LayoutParams params);</span><br><span class="line">public void removeView(View view);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;而且通过阅读源码,我们会发现所有的操作都是交由WindowManagerGloalal来进行.之后的小节我会依次介绍.这一节先讲一下它的比较重要的成员变量.<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 存储所有window所对应的view</span><br><span class="line">    private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();</span><br><span class="line">    // 存在window所对应的viewRootImpl</span><br><span class="line">    private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line">    // 存储了所有window对应的布局参数</span><br><span class="line">    private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">            new ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line">    // 存储了那些正在被删除的view对象,调用了removeVIew,但是没有完成的</span><br><span class="line">    private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;();</span><br></pre></td></tr></table></figure></p>
<h4 id="Window的添加过程"><a href="#Window的添加过程" class="headerlink" title="Window的添加过程"></a>Window的添加过程</h4><p>&emsp;这是WindowManagerGlobal的对应接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">           Display display, Window parentWindow)</span><br></pre></td></tr></table></figure>
<p>&emsp;创建ViewRootImpl,并将View添加到相应的列表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建ViewRootImpl,然后将下述对象添加到列表中</span><br><span class="line">root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line">       view.setLayoutParams(wparams);//设置Params</span><br><span class="line">       mViews.add(view);//window列表添加</span><br><span class="line">       mRoots.add(root);//ViewRootImpl列表添加</span><br><span class="line">       mParams.add(wparams);//布局参数列表添加</span><br></pre></td></tr></table></figure>
<p>&emsp;通过ViewRootImpl来更新界面完成window的添加过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 添加啦!!!!!!!!这是通过ViewRootImpl的setView来完成</span><br><span class="line">root.setView(view, wparams, panelParentView);</span><br></pre></td></tr></table></figure>
<p>&emsp;在ViewRootImpl的setView函数中,会调用requestLayout来完成异步刷新,然后在requestLayout<br>中调用scheduleTraversals来进行view绘制.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   	public void requestLayout() &#123;</span><br><span class="line">       if (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">           checkThread();</span><br><span class="line">           mLayoutRequested = true;</span><br><span class="line">           scheduleTraversals(); // 实际View绘制的入口</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;最后通过WindowSession来完成Window的添加过程,它是一个Binder对象,通过IPC调用来添加window.<br>&emsp;所以,Window的添加请求就交给WindowManagerService去处理,在其内部为每个应用保留一个单独的Session.</p>
<h4 id="Window的删除过程"><a href="#Window的删除过程" class="headerlink" title="Window的删除过程"></a>Window的删除过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void removeView(View view, boolean immediate) &#123;</span><br><span class="line">    if (view == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;view must not be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        int index = findViewLocked(view, true); //先找到view的index</span><br><span class="line">        View curView = mRoots.get(index).getView();</span><br><span class="line">        removeViewLocked(index, immediate);</span><br><span class="line">        if (curView == view) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new IllegalStateException(&quot;Calling with view &quot; + view</span><br><span class="line">                + &quot; but the ViewAncestor is attached to &quot; + curView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;removeView先通过findViewLocked来查找待删除的View的索引,然后用removeViewLocked来做进一步删除.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void removeViewLocked(int index, boolean immediate) &#123;</span><br><span class="line">    ViewRootImpl root = mRoots.get(index); //获得当前的view的viewRootImpl</span><br><span class="line">    View view = root.getView();</span><br><span class="line"></span><br><span class="line">    if (view != null) &#123; //先让imm下降</span><br><span class="line">        InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">        if (imm != null) &#123;</span><br><span class="line">            imm.windowDismissed(mViews.get(index).getWindowToken());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean deferred = root.die(immediate); //die方法只是发送一个请求删除的消息之后就就返回</span><br><span class="line">    if (view != null) &#123;</span><br><span class="line">        view.assignParent(null);</span><br><span class="line">        if (deferred) &#123;</span><br><span class="line">            mDyingViews.add(view);//加入dyingView</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;在WindowManager中提供了两种删除接口removeVIew()和removeViewImmediate(),它们分别表示异步和同步删除.而异步操作中会调用die函数,来发送一个MSG_DIE消息来异步删除,ViewRootImpl的Handler会调用doDie(),而如果是同步删除,那么就直接调用doDie(),然后在removeView函数中把View添加到mDyingViews中.</p>
<h4 id="Window的更新"><a href="#Window的更新" class="headerlink" title="Window的更新"></a>Window的更新</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">      	.....</span><br><span class="line">final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</span><br><span class="line">       view.setLayoutParams(wparams);</span><br><span class="line">       synchronized (mLock) &#123;</span><br><span class="line">           int index = findViewLocked(view, true);</span><br><span class="line">           ViewRootImpl root = mRoots.get(index);</span><br><span class="line">           mParams.remove(index);</span><br><span class="line">           mParams.add(index, wparams);</span><br><span class="line">           root.setLayoutParams(wparams, false);//这是主要的方法</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;在setLayoutParams中会调用scheduleTraversals来重新绘制.</p>
<h4 id="Window的创建过程"><a href="#Window的创建过程" class="headerlink" title="Window的创建过程"></a>Window的创建过程</h4><p>&emsp;不同类型的Window的创建过程不同,这里我只来讲一下Activity的Window的创建过程.在Window的启动过程中,会调用attach()函数来为其关联运行过程中所依赖的一系列上下文环境变量.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mWindow = PolicyManager.makeNewWindow(this);</span><br><span class="line">mWindow.setCallback(this);</span><br></pre></td></tr></table></figure>
<p>&emsp;Window对象是通过PolicyManager的makeNewWindow方法实现的,由于Activity实现了Window的Callback接口,因此当Window接收到外界的状态改变时就会回调Activity的对应方法.而我们去追寻Window的具体实现类,会发现它就是PhoneWindow,而Activity中最常用的setContentView方法的具体操作都是在PhoneWindow的相应方法中实现的.</p>
<p>&emsp;如果没有DecorView,那么就创建它.DecorView是一个FrameLayout,是Activity中的顶级View,一般包括标题栏和内容栏,而且内容栏的id为android.R.id.content,而DecorView的创建过程由installDecor完成,内部会通过generateDecor方法来直接创建DecorView</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (mContentParent == null) &#123; //如何没有DecorView,那么就新建一个</span><br><span class="line">           installDecor();</span><br><span class="line">       &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">           mContentParent.removeAllViews();</span><br><span class="line">       &#125;</span><br><span class="line"> 	if (mDecor == null) &#123;</span><br><span class="line">           mDecor = generateDecor(); //直接new出一个DecorView返回</span><br><span class="line">           ......</span><br><span class="line">       &#125;</span><br><span class="line">       if (mContentParent == null) &#123;</span><br><span class="line">           //[window] 这一步也是很重要的.</span><br><span class="line">           mContentParent = generateLayout(mDecor); </span><br><span class="line">           .......</span><br><span class="line">           &#125;</span><br><span class="line">       .......</span><br></pre></td></tr></table></figure>
<p>&emsp;而在generateLayout中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//根据不同的style生成不同的decorview啊</span><br><span class="line">       View in = mLayoutInflater.inflate(layoutResource, null);</span><br><span class="line">       // 加入到deco中,所以应该是其第一个child</span><br><span class="line">       decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">       mContentRoot = (ViewGroup) in; </span><br><span class="line">       //给DecorView的第一个child是mContentView</span><br><span class="line">       // 这是获得所谓的content</span><br><span class="line">       ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br></pre></td></tr></table></figure></p>
<p>  &emsp;将View添加到DecorView的mContentParent中,这步只需要一条语句就可,具体内部细节就不说啦.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//第二步,将layout添加到mContentParent</span><br><span class="line">       mLayoutInflater.inflate(layoutResID, mContentParent);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;然后就是回调Acitivity的onContentChanged方法通知Activity视图已经改变了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final Callback cb = getCallback();</span><br><span class="line">       if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">           cb.onContentChanged();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;经历了上述三个步骤,DecorView已经创建并初始化完毕,并且Activity的布局文件已经成功添加到DecorView的mContentParent中,但是DecorView并没有添加到WindowManager中去,也无法接收外界的输入,只有到Acitivity的makeVisible()被调用时,DecorView才真正完成了添加和显示过程.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//DecorView正式添加并显示</span><br><span class="line">void makeVisible() &#123;</span><br><span class="line">   if (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = true;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;这篇博文主要是读书笔记式的总结,本来想写一些自己的东西,但是研究的太浅,并且语言组织上还是有不足,以后还需要注意和继续努力啦.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/源码分析/">源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android/">Android</a><a href="/tags/Window机制/">Window机制</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/10/28/Window和WindowManager解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/10/28/Window和WindowManager解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/17/生活学习记录一-RxJava-实习感悟/" title="生活学习记录一:RxJava+实习感悟" itemprop="url">生活学习记录一:RxJava+实习感悟</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-10-17T09:54:47.000Z" itemprop="datePublished"> 发表于 2015-10-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;很久之前就希望自己可以把生活中的点滴都化为文字,记录下来了,今天就写下第一篇博文吧.希望有个好的开始,然后坚持下去.<br>&emsp;前一段时间,在腾讯员工的微信群中看到了有关RxJava和eventBus的对比文章的分享,于是趁着周末,研究一下最近很火的RxJava的使用.<br>&emsp;在学习RxJava的过程中主要参考了下列的几篇文章:</p>
<ul>
<li><p><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给android开发者的RxJava详解</a> ,这是我主要学习的一篇,大多数有关RxJava的知识都是从这里获得的.</p>
</li>
<li><p><a href="http://nicholas.ren/2015/07/19/rx-revisit.html" target="_blank" rel="external">Rx revisit</a>   ,作者主要讲述了Netflix开发Rx系列的原由,Observable和Iterator的区别</p>
</li>
<li><p><a href="http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/" target="_blank" rel="external">Implementing an Event Bus With RxJava - RxBus</a> ,主要讲述了Observer pattern和Pub-sub pattern的区别,和如何使用RxJava去模仿EventBus.</p>
</li>
<li><p><a href="http://www.zhihu.com/topic/20027327" target="_blank" rel="external">知乎-RxJava和EventBus的区别</a> ,看看知友的回答</p>
</li>
<li><p><a href="https://github.com/lzyzsd/Awesome-RxJava" target="_blank" rel="external">Awesome-RxJava</a>, github的有关Rx的文章集合<br>&emsp;阅读了那么多的文章,并且写了一些例子,但是还是感觉没有领会到RxJava的精髓.还需要在正式的项目中使用,才可以算是正在的入了门.<br>&emsp;最近的实习也不是很顺利,出现了很多的问题.不过这也很好,在扇贝的实习所学习到的和在腾讯实习正好是相互补充的.在腾讯实习时,可能是大家都比较忙,代码的质量由开发者自己保证,mentor也不会太认真的帮你进行reivew.而在扇贝则是不太一样,要求比较高的代码的质量,涉及的一些规则和原则其实我也都知道,但是在实际的开发过程中,开始时,代码质量还可以保持在较高的水平,但是随之开发的进行,需求的修改,debug,代码就开始有了”腐烂”的气味.知道原则而不是在实际过程中使用就等于不知道.所以,在单纯的编码方面你还是需要更加的谨慎.<br>&emsp;而在腾讯,大家都比较关注新技术,喜欢紧跟技术潮流,在软件工程的各个流程都做的很好,但是代码方面都是依靠个人保证.<br>&emsp;而且在实习阶段中,我也越发的感觉与公司其他员工的交流和沟通特别重要,不管是日常事务还是工作事务.你需要融入公司的这个大家庭里去啊.</p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/杂记/">杂记</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/RxJava/">RxJava</a><a href="/tags/实习/">实习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/10/17/生活学习记录一-RxJava-实习感悟/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/10/17/生活学习记录一-RxJava-实习感悟/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/4/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Android/" title="Android">Android<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android性能/" title="Android性能">Android性能<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/NIO/" title="NIO">NIO<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/NetWork/" title="NetWork">NetWork<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/Network/" title="Network">Network<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Python/" title="Python">Python<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/c/" title="c">c<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/python/" title="python">python<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/函数式编程/" title="函数式编程">函数式编程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/分布式/" title="分布式">分布式<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/后端/" title="后端">后端<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/后端-Spring/" title="后端 - Spring">后端 - Spring<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/多线程/" title="多线程">多线程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/容器/" title="容器">容器<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/并发/" title="并发">并发<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/思考/" title="思考">思考<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/c/数据结构/" title="数据结构">数据结构<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/杂记/" title="杂记">杂记<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/杂记/" title="杂记">杂记<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/源码/" title="源码">源码<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/源码分析/" title="源码分析">源码分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/杂记/生活/" title="生活">生活<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/综合/" title="综合">综合<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/网络/" title="网络">网络<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/源码/视图/" title="视图">视图<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/计划/" title="计划">计划<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/设计/" title="设计">设计<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/读书笔记/" title="读书笔记">读书笔记<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/运维/" title="运维">运维<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/随笔/" title="随笔">随笔<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/JUC/" title="JUC">JUC<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Netty/" title="Netty">Netty<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/第三方库/" title="第三方库">第三方库<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/注解/" title="注解">注解<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Span/" title="Span">Span<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/scroll/" title="scroll">scroll<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/TCP-IP/" title="TCP/IP">TCP/IP<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/View/" title="View">View<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/事件传递/" title="事件传递">事件传递<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/OkHttp/" title="OkHttp">OkHttp<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Spring-Boot/" title="Spring Boot">Spring Boot<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Docker/" title="Docker">Docker<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Jenkins/" title="Jenkins">Jenkins<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GSON/" title="GSON">GSON<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/反射/" title="反射">反射<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/JSON/" title="JSON">JSON<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/docker/" title="docker">docker<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/kubernetes/" title="kubernetes">kubernetes<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Material-Design/" title="Material Design">Material Design<sup>1</sup></a></li>
			
		
		</ul>
</div>


  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> Hello ,I&#39;m Homer in NJU. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="remCarpediem">remCarpediem</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-88918565-1', 'ztelur.github.io/');
ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?8a8af29a4307eee9d7c7f8e9321aedae";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260989317'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1260989317' type='text/javascript'%3E%3C/script%3E"));</script>




<!-- baidu search 推送-->
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
