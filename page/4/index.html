<!DOCTYPE html>
<html lang="Ch">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>程序员历小冰</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta property="og:type" content="website">
<meta property="og:title" content="程序员历小冰">
<meta property="og:url" content="http://remcarpediem.net/page/4/index.html">
<meta property="og:site_name" content="程序员历小冰">
<meta property="og:locale" content="Chinese">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员历小冰">
    

    
        <link rel="alternate" href="/atom.xml" title="程序员历小冰" type="application/atom+xml">
    

    
        <link rel="icon" href="/css/images/avatar.jpeg">
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
    
    
    
        
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f089a91a688633df563c08899e3d893e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    


<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">程序员历小冰</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">主页</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/book">读书</a>
                
                    <a class="main-nav-link" href="/categories/plan">计划</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.jpeg">
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="検索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '投稿',
            PAGES: 'Pages',
            CATEGORIES: 'カテゴリ',
            TAGS: 'タグ',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">主页</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/book">读书</a></td>
                
                    <td><a class="main-nav-link" href="/categories/plan">计划</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="検索">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile" class="profile-fixed">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.jpeg">
            <h2 id="name">历小冰</h2>
            <h3 id="title">后端开发工程师</h3>
            <span id="location"><i class="fa fa-map-marker"></i>中国，南京</span>
            <img id="wechat" src="/css/images/wechat_public.jpg">
            <a id="follow" target="_blank" href="/css/images/wechat_public.jpg">⬆关注公众号⬆</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                91
                <span>投稿</span>
            </div>
            <div class="article-info-block">
                62
                <span>タグ</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/ztelur" target="_blank" title="github" class="tooltip">
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/css/images/wechat.jpeg" target="_blank" title="wechat" class="tooltip">
                            <i class="fa fa-wechat"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/atom.xml" target="_blank" title="rss" class="tooltip">
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-LongAdder解析-1" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/d4b1972e/">LongAdder原理完全解析</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/d4b1972e/">
            <time datetime="2019-01-23T15:10:42.000Z" itemprop="datePublished">2019-01-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/并发/">并发</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/cas/">cas</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;对<code>LongAdder</code>的最初了解是从Coolshell上的一篇文章中获得的，但是一直都没有深入的了解过其实现，只知道它相较于<code>AtomicLong</code>来说，更加适合写多读少的并发情景。今天，我们就研究一下<code>LongAdder</code>的原理，探究一下它如此高效的原因。</p>
<h3 id="基本原理和思想"><a href="#基本原理和思想" class="headerlink" title="基本原理和思想"></a>基本原理和思想</h3><p>&emsp;Java有很多并发控制机制，比如说以AQS为基础的锁或者以CAS为原理的自旋锁。不了解AQS的朋友可以阅读我之前的<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483716&amp;idx=1&amp;sn=22e5160b1fb1068b262d1b0f4fcfc0a0&amp;chksm=fc04c524cb734c327b823acd2cc3ea3ef8620ab2c6c0c1dc1ac6545904f1c3259afd4f2e7450&amp;token=757268630&amp;lang=zh_CN#rd" target="_blank" rel="noopener">AQS源码解析文章</a>。一般来说，CAS适合轻量级的并发操作，也就是并发量并不多，而且等待时间不长的情况，否则就应该使用普通锁，进入阻塞状态，避免CPU空转。</p>
<p>&emsp;所以，如果你有一个Long类型的值会被多线程修改，那么使用CAS进行并发控制比较好，但是如果你是需要锁住一些资源，然后进行数据库操作，那么还是使用阻塞锁比较好。</p>
<p>&emsp;第一种情况下，我们一般都使用<code>AtomicLong</code>。<code>AtomicLong</code>是通过无限循环不停的采取CAS的方法去设置内部的value，直到成功为止。那么当并发数比较多或出现更新热点时，就会导致CAS的失败机率变高，重试次数更多，越多的线程重试，CAS失败的机率越高，形成恶性循环，从而降低了效率。</p>
<p>&emsp;而LongAdder的原理就是降低对value更新的并发数，也就是将对单一value的变更压力分散到多个value值上，降低单个value的“热度”。</p>
<p>&emsp;我们知道<code>LongAdder</code>的大致原理之后，再来详细的了解一下它的具体实现，其中也有很多值得借鉴的并发编程的技巧。</p>
<h3 id="LongAdder的成员变量"><a href="#LongAdder的成员变量" class="headerlink" title="LongAdder的成员变量"></a>LongAdder的成员变量</h3><p>&emsp;<code>LongAdder</code>是<code>Striped64</code>的子类，其有三个比较重要的成员函数，在之后的函数分析中需要使用到，这里先说明一下。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; CPU的数量
static final int NCPU = Runtime.getRuntime().availableProcessors();
&#x2F;&#x2F; Cell对象的数组，长度一般是2的指数
transient volatile Cell[] cells;
&#x2F;&#x2F; 基础value值，当并发较低时，只累加该值
transient volatile long base;
&#x2F;&#x2F; 创建或者扩容Cells数组时使用的自旋锁变量
transient volatile int cellsBusy;
</code></pre>
<p>&emsp;<code>cells</code>是<code>LongAdder</code>的父类<code>Striped64</code>中的<code>Cell</code>数组类型的成员变量。每个<code>Cell</code>对象中都包含一个value值，并提供对这个value值的CAS操作。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">static final class Cell {
    volatile long value;
    Cell(long x) { value = x; }
    final boolean cas(long cmp, long val) {
        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
    }
}
</code></pre></p>
<h3 id="Add操作"><a href="#Add操作" class="headerlink" title="Add操作"></a>Add操作</h3><p>&emsp;我们首先来看一下<code>LongAdder</code>的<code>add</code>函数，其会多次尝试CAS操作将值进行累加，如果成功了就直接返回，失败则继续执行。代码比较复杂，而且涉及的情况比较多，我们就以梳理历次尝试CAS操作为主线，讲清楚这些CAS操作的前提条件和场景。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public void add(long x) {
    Cell[] as; long b, v; int m; Cell a;
    &#x2F;&#x2F; 当cells数组为null时，会进行第一次cas操作尝试。
    if ((as = cells) != null || !casBase(b = base, b + x)) {
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) &lt; 0 ||
            (a = as[getProbe() &amp; m]) == null || 
            !(uncontended = a.cas(v = a.value, v + x)))
            &#x2F;&#x2F; 当cells数组不为null，并且通过getProbe() &amp; m
            &#x2F;&#x2F; 定位的Cell对象不为null时进行第二次CAS操作。
            &#x2F;&#x2F; 如果执行不成功，则进入longAccumulate函数。
            longAccumulate(x, null, uncontended); 
    }
}
</code></pre>
<p>&emsp;当并发量较少时，cell数组尚未初始化，所以只调用<code>casBase</code>函数，对base变量进行CAS累加。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-39fea917eb75cd7e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一个CAS操作"></p>
<p>&emsp;我们来看一下<code>casBase</code>函数相关的源码吧。我们可以认为变量<code>base</code>就是第一个value值，也是基础value变量。先调用casBase函数来cas一下base变量，如果成功了，就不需要在进行下面比较复杂的算法，<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">final boolean casBase(long cmp, long val) {
    return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);
}
</code></pre></p>
<p>&emsp;当并发量逐渐提高时，<code>casBase</code>函数会失败。如果cells数组为null或为空,就直接调用<code>longAccumulate</code>方法。因为cells为null或在为空，说明cells未初始化，所以调用<code>longAccumulate</code>进行初始化。否则继续判断。<br>&emsp;如果cells中已经初始化，就继续进行后续判断。我们先来理解一下<code>getProbe() &amp; m</code>的这个操作吧，可以把这个操作当作一次计算”hash”值，然后将cells中这个位置的Cell对象赋值给变量a。如果变量a不为null，那么就调用该对象的cas方法去设置其value值。如果a为null，或在cas赋值发生冲突，那么调用<code>longAccumulate</code>方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-8433413840b2a94b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二个CAS操作"></p>
<h3 id="LongAccumulate方法"><a href="#LongAccumulate方法" class="headerlink" title="LongAccumulate方法"></a>LongAccumulate方法</h3><p>&emsp;<code>longAccumulate</code>函数比较复杂，带有我的注释的代码已经贴在了文章后边，这里我们就只讲一下其中比较关键的一些技巧和思想。</p>
<p>&emsp;首先，我们都知道只有当对<code>base</code>的cas操作失败之后，<code>LongAdder</code>才引入<code>Cell</code>数组．所以在<code>longAccumulate</code>中就是对<code>Cell</code>数组进行操作，分别涉及了数组的初始化，扩容和设置某个位置的Cell对象等操作。</p>
<p>&emsp;在这段代码中，关于<code>cellBusy</code>的cas操作构成了一个SpinLock，这就是经典的SpinLock的编程技巧，大家可以学习一下。</p>
<p>&emsp;我们先来看一下<code>longAccumulate</code>的主体代码，首先是一个无限for循环，然后根据cells数组的状态来判断是要进行cells数组的初始化，还是进行对象添加或者扩容。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">final void longAccumulate(long x, LongBinaryOperator fn,
                             boolean wasUncontended) {
       int h;
       if ((h = getProbe()) == 0) { 
           &#x2F;&#x2F;获取PROBE变量，探针变量，与当前运行的线程相关，不同线程不同
           ThreadLocalRandom.current(); 
       &#x2F;&#x2F;初始化PROBE变量，和getProbe都使用Unsafe类提供的原子性操作。
           h = getProbe();
           wasUncontended = true;
       }
       boolean collide = false;
       for (;;) { &#x2F;&#x2F;cas经典无限循环，不断尝试
           Cell[] as; Cell a; int n; long v;
           if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) { 
           &#x2F;&#x2F; cells不为null,并且数组size大于0,表示cells已经初始化了
           &#x2F;&#x2F; 初始化Cell对象并设置到数组中或者进行数组扩容
           }
           else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) {
           &#x2F;&#x2F;cells数组未初始化，获得cellsBusy lock,进行cells数组的初始化
           &#x2F;&#x2F; cells数组初始化操作
           }
          &#x2F;&#x2F;如果初始化数组失败了，那就再次尝试一下直接cas base变量，
          &#x2F;&#x2F; 如果成功了就直接返回，这是最后一个进行CAS操作的地方。
           else if (casBase(v = base, ((fn == null) ? v + x :
                                       fn.applyAsLong(v, x))))
               break;
       }
   }
</code></pre>
<p>&emsp;进行Cell数组代码如下所示，它首先调用<code>casCellsBusy</code>函数获取了<code>cellsBusy</code>‘锁’，然后进行数组的初始化操作，最后将<code>cellBusy</code>‘锁’释放掉。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; 注意在进入这段代码之前已经casCellsBusy获得cellsBusy这个锁变量了。
boolean init = false;
try {
    if (cells == as) {
        Cell[] rs = new Cell[2];
        rs[h &amp; 1] = new Cell(x); &#x2F;&#x2F;设置x的值为cell对象的value值
        cells = rs;
        init = true;
    }
} finally {
    cellsBusy = 0;
}
if (init)
    break;
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-71b68d5e008eca77.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第三个CAS操作"></p>
<p>&emsp;如果Cell数组已经初始化过了，那么就进行Cell数组的设置或者扩容。这部分代码有一系列的if else的判断，如果前一个条件不成立，才会进入下一条判断。</p>
<p>&emsp;首先，当Cell数组中对应位置的cell对象为null时，表明该位置的Cell对象需要进行初始化，所以使用<code>casCellsBusy</code>函数获取’锁’，然后初始化Cell对象，并且设置进cells数组，最后释放掉’锁’。</p>
<p>&emsp;当Cell数组中对应位置的cell对象不为null，则直接调用其cas操作进行累加。</p>
<p>&emsp;当上述操作都失败后，认为多个线程在对同一个位置的Cell对象进行操作，这个Cell对象是一个“热点”，所以Cell数组需要进行扩容，将热点分散。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">if ((a = as[(n - 1) &amp; h]) == null) { &#x2F;&#x2F;通过与操作计算出来需要操作的Cell对象的坐标
    if (cellsBusy == 0) { &#x2F;&#x2F;volatile 变量，用来实现spinLock,来在初始化和resize cells数组时使用。
    &#x2F;&#x2F;当cellsBusy为0时，表示当前可以对cells数组进行操作。 
        Cell r = new Cell(x);&#x2F;&#x2F;将x值直接赋值给Cell对象
        if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {&#x2F;&#x2F;如果这个时候cellsBusy还是0
        &#x2F;&#x2F;就cas将其设置为非０，如果成功了就是获得了spinLock的锁．可以对cells数组进行操作．
        &#x2F;&#x2F;如果失败了，就会再次执行一次循环
            boolean created = false;
            try {
                Cell[] rs; int m, j;
                &#x2F;&#x2F;判断cells是否已经初始化，并且要操作的位置上没有cell对象．
                if ((rs = cells) != null &amp;&amp;
                    (m = rs.length) &gt; 0 &amp;&amp;
                    rs[j = (m - 1) &amp; h] == null) {
                    rs[j] = r;　&#x2F;&#x2F;将之前创建的值为x的cell对象赋值到cells数组的响应位置．
                    created = true;
                }
            } finally {
                &#x2F;&#x2F;经典的spinLock编程技巧，先获得锁，然后try finally将锁释放掉
                &#x2F;&#x2F;将cellBusy设置为0就是释放锁．
                cellsBusy = 0;
            }
            if (created)
                break;　&#x2F;&#x2F;如果创建成功了，就是使用x创建了新的cell对象，也就是新创建了一个分担热点的value
            continue; 
        }
    }
    collide = false; &#x2F;&#x2F;未发生碰撞
}
else if (!wasUncontended)&#x2F;&#x2F;是否已经发生过一次cas操作失败
    wasUncontended = true; &#x2F;&#x2F;设置成true,以便第二次进入下一个else if 判断
else if (a.cas(v = a.value, ((fn == null) ? v + x :
                            fn.applyAsLong(v, x))))
    　&#x2F;&#x2F;fn是操作类型，如果是空，就是相加，所以让a这个cell对象中的value值和x相加，然后在cas设置，如果成果
    &#x2F;&#x2F;就直接返回
    break;
else if (n &gt;= NCPU || cells != as)
　　&#x2F;&#x2F;如果cells数组的大小大于系统的可获得处理器数量或在as不再和cells相等．
    collide = false;
else if (!collide)
    collide = true;
else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {
　　&#x2F;&#x2F;再次获得cellsBusy这个spinLock,对数组进行resize
    try {
        if (cells == as) {&#x2F;&#x2F;要再次检测as是否等于cells以免其他线程已经对cells进行了操作．
            Cell[] rs = new Cell[n &lt;&lt; 1]; &#x2F;&#x2F;扩容一倍
            for (int i = 0; i &lt; n; ++i)
                rs[i] = as[i];
            cells = rs;&#x2F;&#x2F;赋予cells一个新的数组对象
        }
    } finally {
        cellsBusy = 0;
    }
    collide = false;
    continue;
}
h = advanceProbe(h);&#x2F;&#x2F;由于使用当前探针变量无法操作成功，所以重新设置一个,再次尝试
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-7bd9e13169f41c0f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第四个CAS操作"></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;本篇文章写的不是很好，我写完之后又看了一遍coolshell上的关于<code>LongAdder</code>的文章，感觉自己没有人家写的那么简洁明了。我对代码细节的注释和投入太多了。其实很多代码大家都可以看懂，并不需要大量的代码片段加注释。以后要注意一下。之后会接着研究一下JUC包中的其他类，希望大家多多关注。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/d4b1972e/" data-id="ck8hgb9kx00212xsejdnm146l" class="article-share-link"><i class="fa fa-share"></i>共有</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-MySQL探秘-八-InnoDB的事务" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/6edb90fb/">MySQL探秘(八):InnoDB的事务</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/6edb90fb/">
            <time datetime="2018-12-10T13:45:39.000Z" itemprop="datePublished">2018-12-10</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
    </div>

                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;事务是数据库最为重要的机制之一，凡是使用过数据库的人，都了解数据库的事务机制，也对ACID四个基本特性如数家珍。但是聊起事务或者ACID的底层实现原理，往往言之不详，不明所以。所以，今天我们就一起来分析和探讨InnoDB的事务机制，希望能建立起对事务底层实现原理的具体了解。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-2e908e18a2de4210.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事务的四大特性"></p>
<p>&emsp;数据库事务具有ACID四大特性。ACID是以下4个词的缩写：</p>
<ul>
<li>原子性(atomicity) ：事务最小工作单元，要么全成功，要么全失败 。</li>
<li>一致性(consistency)： 事务开始和结束后，数据库的完整性不会被破坏 。</li>
<li>隔离性(isolation) ：不同事务之间互不影响，四种隔离级别为RU（读未提交）、RC（读已提交）、RR（可重复读）、SERIALIZABLE （串行化）。</li>
<li>持久性(durability) ：事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失 。</li>
</ul>
<p>&emsp;下面，我们就以一个具体实例来介绍数据库事务的原理，并介绍InnoDB是如何实现ACID四大特性的。</p>
<h3 id="示例介绍"><a href="#示例介绍" class="headerlink" title="示例介绍"></a>示例介绍</h3><p>&emsp;我们首先来看一下具体的示例。大家可以自己亲自试验一下，这样理解和记忆都会更加深刻。<br>&emsp;首先，使用如下的SQL语句创建两张表，分别是goods和trade，代表货物和交易。并向goods表中插入一条记录，id为1的货物数量为10。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">CREATE TABLE goods (id INT, num INT, PRIMARY KEY(id));
CREATE TABLE trade (id INT, goods_id INT, user_id INT, PRIMARY KEY(id));
INSERT INTO goods VALUES(1, 10);
</code></pre>
<p>&emsp;然后打开终端，连接数据库，开启会话一，先用BEGIN显示开启一个事务。会话一先将goods表中id为1的货物的数量减一，然后向trade表中添加一笔交易的记录，最后使用COMMIT显示提交事务。<br>&emsp;而会话二则先查询goods表中id为1的货物数量，然后向trade表中添加一笔交易记录，接着更新goods表中id为1的货物的数量，最后使用ROLLBACK进行事务的回滚。其中，两个会话中执行的具体语句和先后顺序如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-e1cb53add98d666d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例具体语句和执行顺序"></p>
<p>&emsp;这个示例可以体现数据库事务的很多特性，我们一一来介绍。首先会话一的操作2更新了id为1的货物的数量，但是会话二的操作5读出来的数量仍然是10，这体现了事务的隔离性，使用InnoDB的<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483698&amp;idx=1&amp;sn=3654042755c7ea0922e5d5b462930946&amp;chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制机制</a>实现。<br>&emsp;会话二的操作7也要更新同种货物的数量，此时因为会话一的操作2已经更新了该货物的数量，InnoDB已经锁住了该记录的行锁，所以操作7会被阻塞，直到会话一COMMIT。但是会话一的操作4和会话二的操作7都是向trade表中插入记录，后者却不会因为前者而阻塞，因为二者插入的不是同一行记录。锁机制是一种常见的并发控制机制，它和多版本控制机制一起实现了InnoDB事务的隔离性，关于InnoDB锁相关的具体内容可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483694&amp;idx=1&amp;sn=671ad369f67441c7d1572110066d5695&amp;chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483702&amp;idx=1&amp;sn=669fb9f413db0cc744bdb5b9ec8f725e&amp;chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>。</p>
<p>&emsp;会话一事务最终使用COMMIT提交了事务而会话二事务则使用ROLLBACK回滚了整个事务，这体现了事务的原子性。即事务的一系列操作要么全部执行(COMMIT)，要么就全部不执行(ROLLBACK)，不存在只执行一部分的情况。InnoDB使用事务日志系统来实现事务的原子性。这里有的同学就会问了，如果中途连接断开或者Server Crash会怎么样。能怎么样，直接自动回滚呗。</p>
<p>&emsp;一旦会话一使用COMMIT操作提交事务成功后，那么数据一定会被写入到数据库中并持久的存储起来，这体现了事务的持久性。InnoDB使用<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483683&amp;idx=1&amp;sn=5225ab3481c38bb57297a36df8e62bce&amp;chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">redo log机制</a>来实现事务的持久性。</p>
<p>&emsp;而事务的一致性比较难以理解，简单的讲在事务开始时，此时数据库有一种状态，这个状态是所有的MySQL对象处于一致的状态，例如数据库完整性约束正确，日志状态一致等。当事务提交后，这时数据库又有了一个新的状态，不同的数据，不同的索引，不同的日志等。但此时，约束，数据，索引，日志等MySQL各种状态还是要保持一致性。 也就是说数据库从一个一致性的状态，变到另一个一致性的状态。事务执行后，并没有破坏数据库的完整性约束。</p>
<p>&emsp;下面我们就来详细讲解一下上述示例涉及的事务的ACID特性的具体实现原理。<strong>总结来说，事务的隔离性由多版本控制机制和锁实现，而原子性、一致性和持久性通过InnoDB的redo log、undo log和Force Log at Commit机制来实现</strong>。</p>
<h3 id="原子性，持久性和一致性"><a href="#原子性，持久性和一致性" class="headerlink" title="原子性，持久性和一致性"></a>原子性，持久性和一致性</h3><p>&emsp;原子性，持久性和一致性主要是通过redo log、undo log和Force Log at Commit机制机制来完成的。redo log用于在崩溃时恢复数据，undo log用于对事务的影响进行撤销，也可以用于多版本控制。而Force Log at Commit机制保证事务提交后redo log日志都已经持久化。<br>&emsp;开启一个事务后，用户可以使用COMMIT来提交，也可以用ROLLBACK来回滚。其中COMMIT或者ROLLBACK执行成功之后，数据一定是会被全部保存或者全部回滚到最初状态的，这也体现了事务的原子性。但是也会有很多的异常情况，比如说事务执行中途连接断开，或者是执行COMMIT或者ROLLBACK时发生错误，Server Crash等，此时数据库会自动进行回滚或者重启之后进行恢复。</p>
<p>&emsp;我们先来看一下redo log的原理，redo log顾名思义，就是重做日志，每次数据库的SQL操作导致的数据变化它都会记录一下，<strong>具体来说，redo log是物理日志，记录的是数据库页的物理修改操作</strong>。如果数据发生了丢失，数据库可以根据redo log进行数据恢复。</p>
<p>&emsp;InnoDB通过Force Log at Commit机制实现事务的持久性，即当事务COMMIT时，必须先将该事务的所有日志都写入到redo log文件进行持久化之后，COMMIT操作才算完成。<br>&emsp;当事务的各种SQL操作执行时，即会在缓冲区中修改数据，也会将对应的redo log写入它所属的缓存。当事务执行COMMIT时，与该事务相关的redo log缓冲必须都全部刷新到磁盘中之后COMMIT才算执行成功。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-99cd9e5402f46d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据库日志和数据落盘机制"></p>
<p>&emsp;redo log写入磁盘时，必须进行一次操作系统的fsync操作，防止redo log只是写入了操作系统的磁盘缓存中。参数innodb_flush_log_at_trx_commit可以控制redo log日志刷新到磁盘的策略，它的具体作用可以查阅<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483683&amp;idx=1&amp;sn=5225ab3481c38bb57297a36df8e62bce&amp;chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB的磁盘文件及落盘机制</a></p>
<p>&emsp;redo log全部写入磁盘后事务就算COMMIT成功了，但是此时事务修改的数据还在内存的缓冲区中，称其为脏页，这些数据会依据检查点(CheckPoint)机制择时刷新到磁盘中，然后删除相应的redo log，但是如果在这个过程中数据库Crash了，那么数据库重启时，会依据redo log file将那些还在内存中未更新到磁盘上的数据进行恢复。</p>
<p>&emsp;数据库为了提高性能，数据页在内存修改后并不是每次都会刷到磁盘上。而是引入checkpoint机制，择时将数据页落盘，checkpoint记录之前的数据页保证一定落盘了，这样相关的redo log就没有用了(由于InnoDB redo log file循环使用，这时这部分日志就可以被覆盖)，checkpoint之后的数据页有可能落盘，也有可能没有落盘，所以checkpoint之后的redo log file在崩溃恢复的时候还是需要被使用的。InnoDB会依据脏页的刷新情况，定期推进checkpoint，从而减少数据库崩溃恢复的时间。检查点的信息在第一个日志文件的头部。</p>
<p>&emsp;数据库崩溃重启后需要从redo log中把未落盘的脏页数据恢复出来，重新写入磁盘，保证用户的数据不丢失。当然，在崩溃恢复中还需要回滚没有提交的事务。由于回滚操作需要undo日志的支持，undo日志的完整性和可靠性需要redo日志来保证，所以崩溃恢复先做redo恢复数据，然后做undo回滚。</p>
<p>&emsp;在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-6a680cf9597332b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据和回滚日志的逻辑存储结构.jpg"></p>
<p>&emsp;undo log的存储不同于redo log，它存放在数据库内部的一个特殊的段(segment)中，这个段称为回滚段。回滚段位于共享表空间中。undo段中的以undo page为更小的组织单位。undo page和存储数据库数据和索引的页类似。因为redo log是物理日志，记录的是数据库页的物理修改操作。所以undo log的写入也会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。如上图所示，表空间中有回滚段和叶节点段和非叶节点段，而三者都有对应的页结构。</p>
<p>&emsp;我们再来总结一下数据库事务的整个流程，如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-c46ad59604b75f65.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事务的相关流程"></p>
<p>&emsp;事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页，然后redo log按照时间或者空间等条件进行落盘，undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了。此时，事务还未COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进行数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使用undo log进行事务回滚。事务执行COMMIT操作时，会将本事务相关的所有redo log都进行落盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发生了崩溃，则只使用redo log恢复数据。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>&emsp;InnoDB事务的隔离性主要通过多版本控制机制和锁机制实现，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483698&amp;idx=1&amp;sn=3654042755c7ea0922e5d5b462930946&amp;chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制</a>，<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483694&amp;idx=1&amp;sn=671ad369f67441c7d1572110066d5695&amp;chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483702&amp;idx=1&amp;sn=669fb9f413db0cc744bdb5b9ec8f725e&amp;chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>三篇文章。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;本来想一篇文章将MySQL的事务机制讲明白，写完自己读了一遍，还是发现内容有些晦涩难懂，复杂的知识本来就是很难讲明白的，夫夷以近，则游者众；险以远，则至者少，希望读者以本文作为一篇指引性的文章，自己再去更加深入的地方去探秘。不过，能将复杂知识讲解的通俗简单也是一项很大的本领，文字和讲解能力还是需要提示的。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483664&amp;idx=1&amp;sn=a4aea45edf13b367ee17539eaff4874b&amp;chksm=fc04c570cb734c66447aec4344288025bfe6ba7d715af31dc6d60d65411cd90a05d9b02e749d&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Mysql探索(一):B-Tree索引
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483669&amp;idx=1&amp;sn=de5770a2c732a688b6377b4201bf1577&amp;chksm=fc04c575cb734c63fb5da0a871c5447c0cbbaea2a0a39d3896058b546e3d3a85575f575faf4b&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">数据库内部存储结构探索
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483673&amp;idx=1&amp;sn=cba5118dd4705035c40089a9e59305a9&amp;chksm=fc04c579cb734c6fbc0e67006493d5727ed62262ac243ec74ad6c088cb4e3bcd53dfad73caaf&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(二)：SQL语句执行过程详解
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483676&amp;idx=1&amp;sn=b82135c479c806d2b97d026e143f346a&amp;chksm=fc04c57ccb734c6a530b209b3d78de96c30291228e2296179565cc367107df9bc05bcc325c1c&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(三):InnoDB的内存结构和特性
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483683&amp;idx=1&amp;sn=5225ab3481c38bb57297a36df8e62bce&amp;chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(四):InnoDB的磁盘文件及落盘机制
</a></li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483694&amp;idx=1&amp;sn=671ad369f67441c7d1572110066d5695&amp;chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(五):InnoDB锁的类型和状态查询
</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483698&amp;idx=1&amp;sn=3654042755c7ea0922e5d5b462930946&amp;chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&amp;token=731065842&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(六):InnoDB一致性非锁定读
</a></p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-7d960275042f309d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://mysql.taobao.org/monthly/2017/12/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB 事务系统</a></li>
<li><a href="http://mysql.taobao.org/monthly/2015/06/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB 崩溃恢复过程
</a></li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/6edb90fb/" data-id="ck8hgb9l6002l2xsedx1j1vnh" class="article-share-link"><i class="fa fa-share"></i>共有</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-MySQL探秘-六-InnoDB一致性非锁定读" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/c63e3cd7/">MySQL探秘(六):InnoDB一致性非锁定读</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/c63e3cd7/">
            <time datetime="2018-11-18T13:45:39.000Z" itemprop="datePublished">2018-11-18</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
    </div>

                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVVC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6%E7%AE%80%E5%8D%95%E7%9A%84MVVC.jpg" alt="一致性非锁定读示意图"></p>
<p>&emsp;上图直观地展现了InnoDB一致性非锁定读的机制。之所以称其为非锁定读，是因为不需要等待行上排他锁的释放。快照数据是指该行的之前版本的数据，每行记录可能有多个版本，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVVC)。InnoDB是通过undo log来实现MVVC。undo log本身用来在事务中回滚数据，因此快照数据本身是没有额外开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p>
<p>&emsp;一致性非锁定读是InnoDB默认的读取方式，即读取不会占用和等待行上的锁。但是并不是在每个事务隔离级别下都是采用此种方式。此外，即使都是使用一致性非锁定读，但是对于快照数据的定义也各不相同。</p>
<p>&emsp;在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。然而，对于快照数据的定义却不同。在READ COMMITTED事务隔离级别下，一致性非锁定读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，则读取事务开始时的行数据版本。</p>
<p>&emsp;我们下面举个例子来详细说明一下上述的情况。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike"># session A
mysql&gt; BEGIN;
mysql&gt; SELECT * FROM test WHERE id = 1;
</code></pre></p>
<p>&emsp;我们首先在会话A中显示地开启一个事务，然后读取test表中的id为1的数据，但是事务并没有结束。于此同时，用户在开启另一个会话B，这样可以模拟并发的操作，然后对会话B做出如下的操作：</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike"># session B
mysql&gt; BEGIN;
mysql&gt; UPDATE test SET id = 3 WHERE id = 1;
</code></pre>
<p>&emsp;在会话B的事务中，将test表中id为1的记录修改为id=3，但是事务同样也没有提交，这样id=1的行其实加了一个排他锁。由于InnoDB在READ COMMITTED和REPEATABLE READ事务隔离级别下使用一致性非锁定读，这时如果会话A再次读取id为1的记录，仍然能够读取到相同的数据。此时，READ COMMITTED和REPEATABLE READ事务隔离级别没有任何区别。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6%E4%BC%9A%E8%AF%9DA%E5%92%8C%E4%BC%9A%E8%AF%9DB.jpg" alt="会话A和会话B示意图"></p>
<p>&emsp;如上图所示，当会话B提交事务后，会话A再次运行<code>SELECT * FROM test WHERE id = 1</code>的SQL语句时，两个事务隔离级别下得到的结果就不一样了。<br>&emsp;对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本，如果行被锁定了，则读取该行版本的最新一个快照。因为会话B的事务已经提交，所以在该隔离级别下上述SQL语句的结果集是空的。<br>&emsp;对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据，因此，在该隔离级别下，上述SQL语句仍然会获得相同的数据。</p>
<h4 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h4><p>&emsp;我们首先来看一下wiki上对MVVC的定义：</p>
<blockquote>
<p>Multiversion concurrency control (MCC or MVCC), is a concurrency control<br>method commonly used by database management systems to provide<br>concurrent access to the database and in programming languages to<br>implement transactional memory.</p>
</blockquote>
<p>&emsp;由定义可知，MVVC是用于数据库提供并发访问控制的并发控制技术。<br>数据库的并发控制机制有很多，最为常见的就是锁机制。锁机制一般会给竞争资源加锁，阻塞读或者写操作来解决事务之间的竞争条件，最终保证事务的可串行化。而MVVC则引入了另外一种并发控制，它让读写操作互不阻塞，每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回，由此解决了事务的竞争条件。<br>&emsp;考虑一个现实场景。管理者要查询所有用户的存款总额，假设除了用户A和用户B之外，其他用户的存款总额都为0，A、B用户各有存款1000，所以所有用户的存款总额为2000。但是在查询过程中，用户A会向用户B进行转账操作。转账操作和查询总额操作的时序图如下图所示。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6MVVC%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF.jpg" alt="转账和查询的时序图"></p>
<p>&emsp;如果没有任何的并发控制机制，查询总额事务先读取了用户A的账户存款，然后转账事务改变了用户A和用户B的账户存款，最后查询总额事务继续读取了转账后的用户B的账号存款，导致最终统计的存款总额多了100元，发生错误。</p>
<p>&emsp;使用锁机制可以解决上述的问题。查询总额事务会对读取的行加锁，等到操作结束后再释放所有行上的锁。因为用户A的存款被锁，导致转账操作被阻塞，直到查询总额事务提交并将所有锁都释放。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6%E8%BD%AC%E8%B4%A6%E4%BD%BF%E7%94%A8%E9%94%81.jpg" alt="使用锁机制"><br>&emsp;但是这时可能会引入新的问题，当转账操作是从用户B向用户A进行转账时会导致死锁。转账事务会先锁住用户B的数据，等待用户A数据上的锁，但是查询总额的事务却先锁住了用户A数据，等待用户B的数据上的锁。</p>
<p>&emsp;使用MVVC机制也可以解决这个问题。查询总额事务先读取了用户A的账户存款，然后转账事务会修改用户A和用户B账户存款，查询总额事务读取用户B存款时不会读取转账事务修改后的数据，而是读取本事务开始时的数据副本(在REPEATABLE READ隔离等级下)。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6%E8%BD%AC%E8%B4%A6%E4%BD%BF%E7%94%A8MVVC.jpg" alt="使用MVVC机制"></p>
<p>&emsp;MVCC使得数据库读不会对数据加锁，普通的SELECT请求不会加锁，提高了数据库的并发处理能力。借助MVCC，数据库可以实现READ COMMITTED，REPEATABLE READ等隔离级别，用户可以查看当前数据的前一个或者前几个历史版本，保证了ACID中的I特性（隔离性)</p>
<h4 id="InnoDB的MVVC实现"><a href="#InnoDB的MVVC实现" class="headerlink" title="InnoDB的MVVC实现"></a>InnoDB的MVVC实现</h4><p>&emsp;多版本并发控制仅仅是一种技术概念，并没有统一的实现标准， 其的核心理念就是数据快照，不同的事务访问不同版本的数据快照，从而实现不同的事务隔离级别。虽然字面上是说具有多个版本的数据快照，但这并不意味着数据库必须拷贝数据，保存多份数据文件，这样会浪费大量的存储空间。InnoDB通过事务的undo日志巧妙地实现了多版本的数据快照。<br>&emsp;数据库的事务有时需要进行回滚操作，这时就需要对之前的操作进行undo。因此，在对数据进行修改时，InnoDB会产生undo log。当事务需要进行回滚时，InnoDB可以利用这些undo log将数据回滚到修改之前的样子。<br>&emsp;根据行为的不同 undo log 分为两种 insert undo log和update undo log。<br>&emsp;insert undo log 是在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对于其它事务此记录是不可见的，所以 insert undo log 可以在事务提交后直接删除而不需要进行 purge 操作。<br>&emsp;update undo log 是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，为了提供 MVCC机制，因此 update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。<br>&emsp;为了保证事务并发操作时，在写各自的undo log时不产生冲突，InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际上是一种 Undo 文件组织方式。<br>&emsp;InnoDB行记录有三个隐藏字段：分别对应该行的rowid、事务号db_trx_id和回滚指针db_roll_ptr，其中db_trx_id表示最近修改的事务的id，db_roll_ptr指向回滚段中的undo log。如下图所示。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6innodb%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%88%9D.jpg" alt="初始状态"></p>
<p>&emsp;当事务2使用UPDATE语句修改该行数据时，会首先使用排他锁锁定改行，将该行当前的值复制到undo log中，然后再真正地修改当前行的值，最后填写事务ID，使用回滚指针指向undo log中修改前的行。如下图所示。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6innodb%E5%AE%9E%E7%8E%B02.jpg" alt="第一次修改"></p>
<p>&emsp;当事务3进行修改与事务2的处理过程类似，如下图所示。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6innodb%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A13.jpg" alt="第二次修改"></p>
<p>&emsp;REPEATABLE READ隔离级别下事务开始后使用MVVC机制进行读取时，会将当时活动的事务id记录下来，记录到Read View中。READ COMMITTED隔离级别下则是每次读取时都创建一个新的Read View。<br>&emsp;Read View是InnoDB中用于判断记录可见性的数据结构，记录了一些用于判断可见性的属性。</p>
<ul>
<li>low_limit_id：某行记录的db_trx_id &lt; 该值，则该行对于当前Read View是一定可见的</li>
<li>up_limit_id：某行记录的db_trx_id &gt;= 该值，则该行对于当前read view是一定不可见的</li>
<li>low_limit_no：用于purge操作的判断</li>
<li>rw_trx_ids：读写事务数组</li>
</ul>
<p>&emsp;Read View创建后，事务再次进行读操作时比较记录的db_trx_id和Read View中的low_limit_id，up_limit_id和读写事务数组来判断可见性。</p>
<p>&emsp;如果该行中的db_trx_id等于当前事务id，说明是事务内部发生的更改，直接返回该行数据。否则的话，如果db_trx_id小于up_limit_id，说明是事务开始前的修改，则该记录对当前Read View是可见的，直接返回该行数据。</p>
<p>&emsp;如果db_trx_id大于或者等于low_limit_id，则该记录对于该Read View一定是不可见的。如果db_trx_id位于[up_limit_id, low_limit_id)范围内，需要在活跃读写事务数组(rw_trx_ids)中查找db_trx_id是否存在，如果存在，记录对于当前Read View是不可见的。<br>&emsp;如果记录对于Read View不可见，需要通过记录的DB_ROLL_PTR指针遍历undo log，构造对当前Read View可见版本数据。<br>&emsp;简单来说，Read View记录读开始时及其之后，所有的活动事务，这些事务所做的修改对于Read View是不可见的。除此之外，所有其他的小于创建Read View的事务号的所有记录均可见。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>&emsp;我们后续还会学习InnoDB的锁的相关的知识，请大家持续关注。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483664&amp;idx=1&amp;sn=a4aea45edf13b367ee17539eaff4874b&amp;chksm=fc04c570cb734c66447aec4344288025bfe6ba7d715af31dc6d60d65411cd90a05d9b02e749d&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Mysql探索(一):B-Tree索引
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483669&amp;idx=1&amp;sn=de5770a2c732a688b6377b4201bf1577&amp;chksm=fc04c575cb734c63fb5da0a871c5447c0cbbaea2a0a39d3896058b546e3d3a85575f575faf4b&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">数据库内部存储结构探索
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483673&amp;idx=1&amp;sn=cba5118dd4705035c40089a9e59305a9&amp;chksm=fc04c579cb734c6fbc0e67006493d5727ed62262ac243ec74ad6c088cb4e3bcd53dfad73caaf&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(二)：SQL语句执行过程详解
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483676&amp;idx=1&amp;sn=b82135c479c806d2b97d026e143f346a&amp;chksm=fc04c57ccb734c6a530b209b3d78de96c30291228e2296179565cc367107df9bc05bcc325c1c&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(三):InnoDB的内存结构和特性
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483683&amp;idx=1&amp;sn=5225ab3481c38bb57297a36df8e62bce&amp;chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(四):InnoDB的磁盘文件及落盘机制
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483694&amp;idx=1&amp;sn=671ad369f67441c7d1572110066d5695&amp;chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(五):InnoDB锁的类型和状态查询
</a></li>
</ul>
<p><img src="http://pie6tw55i.bkt.clouddn.com/qrcode_for_gh_bcc90a2a52c5_344.jpg" alt=""></p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="http://mysql.taobao.org/monthly/2018/03/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2018/03/01/</a></li>
<li><a href="https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/" target="_blank" rel="noopener">https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/</a></li>
<li><a href="http://hedengcheng.com/?p=148" target="_blank" rel="noopener">http://hedengcheng.com/?p=148</a></li>
<li>《唐成－2016PG大会-数据库多版本实现内幕.pdf》</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/c63e3cd7/" data-id="ck8hgb9l7002p2xsec5e1f90k" class="article-share-link"><i class="fa fa-share"></i>共有</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-2018年-计划目录" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/e7ec8ed3/">2018年,计划目录</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/e7ec8ed3/">
            <time datetime="2018-03-26T12:34:31.000Z" itemprop="datePublished">2018-03-26</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/plan/">plan</a>
    </div>

                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;和<a href="http://ztelur.github.io/2017/05/03/2017%E5%B9%B4%EF%BC%8C%E8%AE%A1%E5%88%92%E7%9B%AE%E5%BD%95/" target="_blank" rel="noopener">17年计划</a>一样，建立一个计划目录，记录一下18年的计划和实现情况,进行不定时的更新。</p>
<h2 id="计划列表"><a href="#计划列表" class="headerlink" title="计划列表"></a>计划列表</h2><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><ul>
<li>测试用例自动化生成技术研究<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3></li>
<li>计算机程序的构造和解释<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2018-3-26日"><a href="#2018-3-26日" class="headerlink" title="2018.3.26日"></a>2018.3.26日</h3><h4 id="测试用例自动化生成技术研究"><a href="#测试用例自动化生成技术研究" class="headerlink" title="测试用例自动化生成技术研究"></a>测试用例自动化生成技术研究</h4>&emsp;依据代码逻辑自动生成junit代码。用于追求覆盖率的junit代码自动生成<h4 id="计算机程序的构造和解释"><a href="#计算机程序的构造和解释" class="headerlink" title="计算机程序的构造和解释"></a>计算机程序的构造和解释</h4>&emsp;再次挑战这本书，希望能坚持下去。</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/e7ec8ed3/" data-id="ck8hgb9jo00022xsefnkdc1uc" class="article-share-link"><i class="fa fa-share"></i>共有</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Spring-Cloud-Stream-一-：Spring基础知识" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/2317aa7e/">Spring Cloud Stream(一)：Spring基础知识</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/2317aa7e/">
            <time datetime="2017-10-10T13:51:45.000Z" itemprop="datePublished">2017-10-10</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Spring/">Spring</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Spring-Boot/">Spring Boot</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;我研究和阅读<code>Spring Cloud Stream</code>源码已经有一个多月了，但是由于自己的Spring基础知识不是很充足，所以导致很多地方都没有融会贯通，并且相关的文章一直无从下手。于是我先整理了当时阅读代码时的知识点记录，算是源码分析之前的基础知识储备吧，整理的有些杂乱，希望大家理解。<br>&emsp;本文涉及的Spring知识如下：</p>
<ul>
<li>Spring Boot的<code>@Import</code>用法和原理,与<code>Configuration</code>和<code>ImportBeanDefinitionRegistrar</code>相关</li>
<li>Bean初始化各个周期的回调，比如<code>InitializingBean</code>,<code>BeanPostProcessor</code>,<code>SmartInitializingSingleton</code></li>
<li><code>FactoryBean</code>和<code>MethodInterceptor</code></li>
<li><code>Aware</code>系列回调</li>
<li><code>Lifecycle</code>和<code>SmartLifecycle</code>和<code>DefaultLifecycleProcessor</code></li>
</ul>
<h4 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h4><p> <code>BeanDefinitionRegistryPostProcessor</code>实现了<code>BeanFactoryPostProcessor</code>接口，是Spring框架的<code>BeanDefinitionRegistry</code>的后处理器，用来注册额外的<code>BeanDefinition</code>。<code>postProcessBeanDefinitionRegistry</code>方法会在所有的<code>BeanDefinition</code>已经被加载了，但是所有的<code>Bean</code>还没有被创建前调用。<code>BeanDefinitionRegistryPostProcessor</code>经常被用来注册<code>BeanFactoryPostProcessor</code>的<code>BeanDefinition</code>。</p>
<h4 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h4><p> <code>@Import</code>注解用来支持在<code>Configuration</code>类中引入其他的配置类，包括<code>Configuration</code>类，<code>ImportSelector</code>和<code>ImportBeanDefinitionRegistrar</code>的实现类。<code>ImportBeanDefinitionRegistrar</code>在<code>ConfigurationClassPostProcessor</code>处理<code>Configuration</code>类期间被调用，用来生成该<code>Configuration</code>类所需要的<code>BeanDefinition</code>。而<code>ConfigurationClassPostProcessor</code>正实现了<code>BeanDefinitionRegistryPostProcessor</code>接口。下面我们就来看一下其<code>processConfigBeanDefinitions</code>方法到底是如何处理<code>Configuration</code>类的。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
		List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
		String[] candidateNames = registry.getBeanDefinitionNames();
        &#x2F;&#x2F;第一步：先把所有Configuration的beanDefinition找到。
		for (String beanName : candidateNames) {
			BeanDefinition beanDef = registry.getBeanDefinition(beanName);
			&#x2F;&#x2F;利用AnnotationMetadata是否有@Configuration这个注解。需要注意的是
            &#x2F;&#x2F;Configuration是一个元注解，它是可以使用在其他注解上的，被这些注解注释的类也被认为是Configuration
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
				configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
			}
		}
		&#x2F;&#x2F;第二步：通过Order注解的值来排序，定义了Configuration的先后顺序
		configCandidates.sort((bd1, bd2) -&gt; {
			int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
			int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
			return (i1 &lt; i2) ? -1 : (i1 &gt; i2) ? 1 : 0;
		});
        &#x2F;&#x2F;..... 此处有省略
		ConfigurationClassParser parser = new ConfigurationClassParser(
				this.metadataReaderFactory, this.problemReporter, this.environment,
				this.resourceLoader, this.componentScanBeanNameGenerator, registry);

		Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
		Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
		do {
            &#x2F;&#x2F;第三步：通过BeanDefinition来读取ConfigurationClass
			parser.parse(candidates);
			parser.validate();

			Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
			configClasses.removeAll(alreadyParsed);

			if (this.reader == null) {
				this.reader = new ConfigurationClassBeanDefinitionReader(
						registry, this.sourceExtractor, this.resourceLoader, this.environment,
						this.importBeanNameGenerator, parser.getImportRegistry());
			}
            &#x2F;&#x2F;第四步：重点，通过ConfigurationClass来获得BeanDefinition
			this.reader.loadBeanDefinitions(configClasses);
			alreadyParsed.addAll(configClasses);

			candidates.clear();
            &#x2F;&#x2F;第五步：由于在loadBeanDefinitions过程中会向registry中添加BeanDefinition,所以这里需要把新的Definition
            &#x2F;&#x2F;在重新检测一遍，先看是否是Configuration类，如果是的那么还要再进行一次处理。
			if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
                &#x2F;&#x2F;.....此处有省略，大致逻辑就是通过registry多出的BeanDefinition获得新的candidateNames
				candidateNames = newCandidateNames;
			}
		}
		while (!candidates.isEmpty());
        &#x2F;&#x2F;.....此处有省略
	}
</code></pre>
<p> 接着我们直接到<code>ConfigurationClassBeanDefinitionReader</code>类中查看<code>loadBeanDefinition</code>函数的实现。它会调用<code>loadBeanDefinitionsForConfigurationClass</code>函数。在该函数中会处理所有和<code>Configuration</code>相关的<code>BeanDefinition</code>,其中就会调用<code>loadBeanDefinitionsFromRegistrars</code>来通过<code>ImportBeanDefinitionRegistrar</code>加载<code>BeanDefinition</code>。<br> 看到这里，大家可能会有个疑问，多个<code>Configuration</code>和多个<code>ImportBeanDefinitionRegistrar</code>存在的情况下，它们之间的对应关系是如何确定的呢？<br> <code>ConfigurationClassParser</code>的parse方法会将Configuration类相关的配置信息全部解析出来。我们可以看其<code>doProcessConfigurationClass</code>方法的源码。通过<code>@Import</code>注解将<code>Configuration</code>类和相应的<code>ImportBeanDefinitionRegistrar</code>联系在一起。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
			throws IOException {
        &#x2F;&#x2F;首先处理内部成员类的情况
		processMemberClasses(configClass, sourceClass);

		&#x2F;&#x2F; 处理 @PropertySource 注解
		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), PropertySources.class,
				org.springframework.context.annotation.PropertySource.class)) {
			if (this.environment instanceof ConfigurableEnvironment) {
				processPropertySource(propertySource);
            }
		}

		&#x2F;&#x2F; 处理 @ComponentScan 注解
		Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
		if (!componentScans.isEmpty() &amp;&amp;
				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
			for (AnnotationAttributes componentScan : componentScans) {
				&#x2F;&#x2F; The config class is annotated with @ComponentScan -&gt; perform the scan immediately
				Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
				&#x2F;&#x2F; Check the set of scanned definitions for any further config classes and parse recursively if needed
				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
					if (ConfigurationClassUtils.checkConfigurationClassCandidate(
							holder.getBeanDefinition(), this.metadataReaderFactory)) {
						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());
					}
				}
			}
		}

		&#x2F;&#x2F; 处理 @Import 注解
		processImports(configClass, sourceClass, getImports(sourceClass), true);

		&#x2F;&#x2F; 处理 @ImportResource 注解
		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {
			AnnotationAttributes importResource =
					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
			String[] resources = importResource.getStringArray(&quot;locations&quot;);
			Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
			for (String resource : resources) {
				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
				configClass.addImportedResource(resolvedResource, readerClass);
			}
		}

		&#x2F;&#x2F; 处理configuration中的 @Bean 函数
		Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
		for (MethodMetadata methodMetadata : beanMethods) {
			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
		}
        &#x2F;&#x2F;......有省略
		return null;
	}
</code></pre></p>
<h4 id="InitializingBean，FactoryBean，MethodInterceptor"><a href="#InitializingBean，FactoryBean，MethodInterceptor" class="headerlink" title="InitializingBean，FactoryBean，MethodInterceptor"></a>InitializingBean，FactoryBean，MethodInterceptor</h4><p> Spring Cloud Stream的<code>BindableProxyFactory</code>类实现了上述接口。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">BindableProxyFactory implements MethodInterceptor, FactoryBean&lt;Object&gt;, Bindable, InitializingBean
</code></pre></p>
<p> 其中，<code>InitializingBean</code>接口有一个<code>afterPropertiesSet</code>方法，该方法在<code>bean</code>所有的属性都被赋值后调用。bean的属性被初始化是在初始化的时候做的，与<code>BeanPostProcessor</code>结合来看，<code>afterPropertiesSet</code>方法在<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>之间被调用。<br> Spring中有两个类型的Bean,普通Bean和工厂Bean。FactoryBean有三个接口，分别是:</p>
<ul>
<li>Object getObject():返回FactoryBean创建的对象实例。</li>
<li>boolean isSingleton():表示FactoryBean返回的对象实例是否为单例。</li>
<li>Class getObjectType():返回FactoryBean返回的对象类型。<br> 我们可以看一下<code>BindableProxyFactory</code>的相关实现，这里会和<code>MethodInterceptor</code>配合。<code>MethodInterceptor</code>是AOP相关的接口，用于在调用对象接口时进行切片注入或在直接实现接口。
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">
@Override
	public synchronized Object getObject() throws Exception {
        &#x2F;&#x2F;使用AOP的ProxyFactory类，由于该类本身也是先了MethodInterceptor接口
        &#x2F;&#x2F;所以这样配合使用，直接返回ProxyFactory类。
		if (this.proxy == null) {
			ProxyFactory factory = new ProxyFactory(this.type, this);
			this.proxy = factory.getProxy();
		}
		return this.proxy;
	}

	@Override
	public Class&lt;?&gt; getObjectType() {
		return this.type;
	}

	@Override
	public boolean isSingleton() {
		return true;
	}
</code></pre>
</li>
</ul>
<h4 id="BeanPostProcessor，ApplicationContextAware，BeanFactoryAware，SmartInitializingSingleton"><a href="#BeanPostProcessor，ApplicationContextAware，BeanFactoryAware，SmartInitializingSingleton" class="headerlink" title="BeanPostProcessor，ApplicationContextAware，BeanFactoryAware，SmartInitializingSingleton"></a>BeanPostProcessor，ApplicationContextAware，BeanFactoryAware，SmartInitializingSingleton</h4><p> Spring Cloud Stream的<code>StreamListenerAnnotationBeanPostProcessor</code>实现了如下接口<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public class StreamListenerAnnotationBeanPostProcessor
		implements BeanPostProcessor, ApplicationContextAware, BeanFactoryAware, SmartInitializingSingleton,
		InitializingBean
</code></pre></p>
<p> <code>BeanPostProcessor</code>是<code>bean</code>的后处理器，通过它我们可以在<code>Bean</code>初始化前后进行处理。它的<code>postProcessBeforeInitialization</code>方法在<code>Bean</code>初始化之前被调用，而<code>postProcessAfterInitialization</code>在<code>Bean</code>初始化后被调用。相关原理涉及到Spring创建Bean的流程，这个之后有时间再研究吧。</p>
<h4 id="Aware系列接口"><a href="#Aware系列接口" class="headerlink" title="Aware系列接口"></a>Aware系列接口</h4><p> Spring中提供了一些<code>Aware</code>相关的接口，像是<code>BeanFactoryAware</code>,<code>ApplicationContextAware</code>等。当一个类实现了这些接口之后，<code>Aware</code>接口的Bean在初始化之后，可以取得相应的资源的实例。比如<code>StreamListenerAnnotationBeanPostProcessor</code>对象就实现了<code>ApplicationContextAware</code>和<code>BeanFactoryAware</code>接口来获取<code>ConfigurableApplicationContext</code>与<code>BeanFactory</code>实例。</p>
<h4 id="SmartInitializingSingleton"><a href="#SmartInitializingSingleton" class="headerlink" title="SmartInitializingSingleton"></a>SmartInitializingSingleton</h4><p> 当所有的singleton的bean都初始化完成之后才会调用这个接口<br>的<code>afterSingletonsInstantiated</code>函数</p>
<h4 id="SmartLifecycle"><a href="#SmartLifecycle" class="headerlink" title="SmartLifecycle"></a>SmartLifecycle</h4><p> 之前介绍的接口都是在Bean的生命周期内的某个阶段中被调用，如果我们希望在容器本身的生命周期事件上做一些事情该怎麽办呢？Spring容器提供了<code>Lifecycle</code>接口。当<code>ApplicationContext</code>接口启动或在关闭时，它会调用本容器内所有的Lifecycle接口。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public interface Lifecycle {
    &#x2F;&#x2F;启动该组件
	void start();
    &#x2F;&#x2F;停止组件
	void stop();
    &#x2F;&#x2F;查看组件是否正在运行
	boolean isRunning();

}
</code></pre></p>
<p> 如果两个对象有依赖关系，希望某一个bean先初始化完成，完成一些工作之后，再初始化另一个bean。在这个场景下，可以使用<code>SmartLifecycle</code>接口，该接口的<code>getPhase</code>方法返回一个整型数字，表明执行顺序。如果其<code>getPhase()</code>方法返回<code>Integer.MIN_VALUE</code>,那么该对象最先启动，最后停止；如果返回<code>Integer.MAX_VALUE</code>,那么该对象最后启动，最先停止。在<code>Spring</code>容器里，有<code>DefaultLifecycleProcessor</code>这个类来处理所有的<code>Lifecycle</code>的bean。在<code>AbstractApplicationContext</code>的<code>finishRefresh</code>函数中会调用到该processer的<code>onRefresh函数</code>，从其调用其本身的<code>startBeans</code>函数。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">private void startBeans(boolean autoStartupOnly) {
		Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();
		Map&lt;Integer, LifecycleGroup&gt; phases = new HashMap&lt;Integer, LifecycleGroup&gt;();
        &#x2F;&#x2F;遍历所有的Lifecycle,按照phase分成不同的LifecycleGroup
		for (Map.Entry&lt;String, ? extends Lifecycle&gt; entry : lifecycleBeans.entrySet()) {
			Lifecycle bean = entry.getValue();
			if (!autoStartupOnly || (bean instanceof SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) {
				int phase = getPhase(bean);
				LifecycleGroup group = phases.get(phase);
				if (group == null) {
					group = new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);
					phases.put(phase, group);
				}
				group.add(entry.getKey(), bean);
			}
		}
		if (!phases.isEmpty()) {
            &#x2F;&#x2F;按照phase排序，然后启动
			List&lt;Integer&gt; keys = new ArrayList&lt;Integer&gt;(phases.keySet());
			Collections.sort(keys);
			for (Integer key : keys) {
				phases.get(key).start();
			}
		}
	}
</code></pre></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/2317aa7e/" data-id="ck8hgb9m2004o2xse2pbms1bu" class="article-share-link"><i class="fa fa-share"></i>共有</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Spring-Boot-一-Spring-Boot-starter自定义" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/81d689c6/">Spring Boot (一): Spring Boot starter自定义</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/81d689c6/">
            <time datetime="2017-09-10T12:25:35.000Z" itemprop="datePublished">2017-09-10</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Spring/">Spring</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Spring-Boot/">Spring Boot</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 前些日子在公司接触了<code>spring boot</code>和<code>spring cloud</code>,有感于其大大简化了spring的配置过程，十分方便使用者快速构建项目，而且拥有丰富的starter供开发者使用。但是由于其自动化配置的原因，往往导致出现问题，新手无法快速定位问题。这里我就来总结一下spring boot 自定义starter的过程,相信大家看完这篇文章之后，能够对<code>spring boot starter</code>的运行原理有了基本的认识。<br> 为了节约你的时间，本篇文章的主要内容有：</p>
<ul>
<li>spring boot starter的自定义</li>
<li>spring boot auto-configuration的两种方式,spring.factories和注解</li>
<li>Conditional注解的使用</li>
</ul>
<h3 id="引入pom依赖"><a href="#引入pom依赖" class="headerlink" title="引入pom依赖"></a>引入pom依赖</h3><p> 相信接触过spring boot的开发者都会被其丰富的starter所吸引，如果你想给项目添加redis支持，你就可以直接引用<code>spring-boot-starter-redis</code>，如果你想使项目微服务化，你可以直接使用<code>spring-cloud-starter-eureka</code>。这些都是spring boot所提供的便利开发者的组件，大家也可以自定义自己的starter并开源出去供开发者使用。<br> 创建自己的starter项目需要maven依赖是如下所示:<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;spring-boot-autoconfigure&lt;&#x2F;artifactId&gt;
            &lt;version&gt;1.4.4.RELEASE&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;
            &lt;version&gt;1.4.4.RELEASE&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;
</code></pre></p>
<h4 id="核心配置类StorageAutoConfigure"><a href="#核心配置类StorageAutoConfigure" class="headerlink" title="核心配置类StorageAutoConfigure"></a>核心配置类StorageAutoConfigure</h4><p> 构建starter的关键是编写一个装配类，这个类可以提供该starter核心bean。这里我们的starter提供一个类似<code>redis</code>的键值存储功能的bean，我们叫它为<code>StorageService</code>。负责对这个bean进行自动化装配的类叫做<code>StorageAutoConfigure</code>。保存application.properties配置信息的类叫做<code>StorageServiceProperties</code>。这三种类像是铁三角一样，你可以在很多的<code>spring-boot-starter</code>中看到他们的身影。<br> 我们首先来看<code>StorageAutoConfigure</code>的定义。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">@Configuration
@ConditionalOnClass(StorageService.class)
@EnableConfigurationProperties(StorageServiceProperties.class)
public class StorageAutoConfigure {
    @Autowired
    private StorageServiceProperties properties;

    @Bean
    @ConditionalOnMissingBean(StorageService.class)
    @ConditionalOnProperty(prefix = &quot;storage.service&quot;, value = &quot;enabled&quot;, havingValue = &quot;true&quot;)
    StorageService exampleService() {
        return new StorageService(properties);
    }
}
</code></pre></p>
<p> 我们首先讲一下源码中注解的作用。</p>
<ul>
<li><code>@Configuration</code>,被该注解注释的类会提供一个或则多个<code>@bean</code>修饰的方法并且会被spring容器处理来生成<code>bean definitions</code>。</li>
<li><code>@bean</code>注解是必须修饰函数的，该函数可以提供一个<code>bean</code>。而且该函数的函数名必须和bean的名称一致，除了首字母不需要大写。</li>
<li><code>@ConditionalOnClass</code>注解是条件判断的注解，表示对应的类在classpath目录下存在时，才会去解析对应的配置文件。</li>
<li><code>@EnableConfigurationProperties</code>注解给出了该配置类所需要的配置信息类，也就是<code>StorageServiceProperties</code>类，这样spring容器才会去读取配置信息到<code>StorageServiceProperties</code>对象中。</li>
<li><code>@ConditionalOnMissingBean</code>注解也是条件判断的注解，表示如果不存在对应的bean条件才成立，这里就表示如果已经有<code>StorageService</code>的bean了，那么就不再进行该bean的生成。这个注解十分重要，涉及到默认配置和用户自定义配置的原理。也就是说用户可以自定义一个<code>StorageService</code>的bean,这样的话，spring容器就不需要再初始化这个默认的bean了。</li>
<li><code>ConditionalOnProperty</code>注解是条件判断的注解，表示如果配置文件中的响应配置项数值为true,才会对该bean进行初始化。</li>
</ul>
<p> 看到这里，大家大概都明白了<code>StorageAutoConfigure</code>的作用了吧，spring容器会读取相应的配置信息到<code>StorageServiceProperties</code>中，然后依据调节判断初始化StorageService这个bean。集成了该<code>starter</code>的项目就可以直接使用<code>StorageService</code>来存储键值信息了。</p>
<h4 id="配置信息类StorageServiceProperties"><a href="#配置信息类StorageServiceProperties" class="headerlink" title="配置信息类StorageServiceProperties"></a>配置信息类StorageServiceProperties</h4><p> 存储配置信息的类<code>StorageServiceProperties</code>很简单，源码如下所示:<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">@ConfigurationProperties(&quot;storage.service&quot;)
public class StorageServiceProperties {
    private String username;
    private String password;
    private String url;
    
    ......
    &#x2F;&#x2F;一系列的getter和setter函数
}
</code></pre></p>
<p> <code>@ConfigurationProperties</code>注解就是让spring容器知道该配置类的配置项前缀是什么，上述的源码给出的配置信息项有<code>storage.service.username</code>,<code>storage.service.password</code>和<code>storage.service.url</code>，类似于数据库的host和用户名密码。这些配置信息都会由spring容器从<code>application.properties</code>文件中读取出来设置到该类中。</p>
<h4 id="starter提供功能的StorageService"><a href="#starter提供功能的StorageService" class="headerlink" title="starter提供功能的StorageService"></a>starter提供功能的StorageService</h4><p> <code>StorageService</code>类是提供整个starter的核心功能的类，也就是提供键值存储的功能。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public class StorageService {
    private Logger logger = LoggerFactory.getLogger(StorageService.class);
    private String url;
    private String username;
    private String password;
    private HashMap&lt;String, Object&gt; storage = new HashMap&lt;String, Object&gt;();
    public StorageService(StorageServiceProperties properties) {
        super();
        this.url = properties.getUrl();
        this.username = properties.getUsername();
        this.password = properties.getPassword();
        logger.debug(&quot;init storage with url &quot; + url + &quot; name: &quot; + username + &quot; password: &quot; + password);
    }


    public void put(String key, Object val) {
        storage.put(key, val);
    }

    public Object  get(String key) {
        return storage.get(key);
    }
}
</code></pre></p>
<h4 id="注解配置和spring-factories"><a href="#注解配置和spring-factories" class="headerlink" title="注解配置和spring.factories"></a>注解配置和spring.factories</h4><p>&emsp;自定义的<code>starter</code>有两种方式来通知spring容器导入自己的auto-configuration类，也就是本文当中的<code>StorageAutoConfigure</code>类。<br>&emsp;一般都是在<code>starter</code>项目的<code>resources/META-INF</code>文件夹下的spring.factories文件中加入需要自动化配置类的全限定名称。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">org.springframework.boot.autoconfigure.EnableAutoConfiguration=starter.StorageAutoConfigure
</code></pre></p>
<p>&emsp;<code>spring boot</code>项目中的<code>EnableAutoConfigurationImportSelector</code>会自动去每个jar的相应文件下查看spring.factories文件内容，并将其中的类加载出来在auto-configuration过程中进行配置。而<code>EnableAutoConfigurationImportSelector</code>在<code>@EnableAutoConfiguration</code>注解中被<code>import</code>。<br>&emsp;第一种方法只要是引入该starter，那么spring.factories中的auto-configuration类就会被装载，但是如果你希望有更加灵活的方式，那么就使用自定义注解来引入装配类。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Import(StorageAutoConfigure.class)
@Documented
public @interface EnableStorage {
}
</code></pre></p>
<p>&emsp;有了这个注解，你可以在你引入该starter的项目中使用该注解，通过<code>@import</code>注解，spring容器会自动加载<code>StorageAutoConfigure</code>并自动化进行配置。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>&emsp;上述只是关于spring boot starter最为简单的定制和原理分析，后续我准备研究一下<code>spring cloud stream</code>的源码，主要是因为工作上一直在使用这个框架。请大家继续关注。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/81d689c6/" data-id="ck8hgb9lw004c2xsea40gr90u" class="article-share-link"><i class="fa fa-share"></i>共有</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Raft算法" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/1df31392/">Raft算法</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/1df31392/">
            <time datetime="2017-07-25T09:09:09.000Z" itemprop="datePublished">2017-07-25</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/分布式/">分布式</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Raft/">Raft</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 前段时间一直在学习mit的分布式课程<a href="http://nil.csail.mit.edu/6.824/2015/index.html" target="_blank" rel="noopener">Distributed Systems</a>，仔细阅读了raft论文，但是中间又跑去搞docker了，所以一直没有整理raft相关的文章，今天就来总结一下。<br>&emsp;文章中没有多少详细的图片，但是大家可以边看文章边看<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">Raft演示动画</a><br> 之前介绍的<a href="http://remcarpediem.com/2017/04/16/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Paxos/" target="_blank" rel="noopener">Paxos</a>算法一直都是分布式一致性协议的标准，但是Paxos难以理解，更难以理解。于是Stanford的教授提出了Raft协议，它是一个为真实世界应用建立的协议，主要注重协议的落地性和可理解性。这里有Raft的<a href="http://nil.csail.mit.edu/6.824/2015/papers/raft-atc14.pdf" target="_blank" rel="noopener">论文</a>，大家有兴趣可以自行阅读一下。<br> Raft是为了managing a replicated log。Raft会首先选举一个leader,然后让这个leader来管理replicated log。Raft将consensus问题(也就是一致性问题)划分成三个相互独立的子问题：  </p>
<ul>
<li>leader election</li>
<li>log replication</li>
<li>safety</li>
</ul>
<h4 id="Raft-basis"><a href="#Raft-basis" class="headerlink" title="Raft basis"></a>Raft basis</h4><p> 任何时间每个server都处于下列三个状态之一：leader,follower,或在candidate之一。在正常状态下，整个集群只会有一个leader并且其他所有server都处于followers状态下。followers是被动的，它们只会对leader的request进行反应。第三个状态candidate是用来选举新的leader的。<br> Raft以Term来划分运行时间，你可以将其理解为任期。Term以连续的整数来命名，每个Term都以一个election开始。在一次选举中，一个或多个candidate试图成为leader。如果一个candidate赢得了election,那么它就成为leader。如果一次election中没有candidate获胜，那么就进行下一个Term,重新进行election。每个Term最多只有一leader，否则进入下一个Term,这样Term就可以作为一个logical clock。<br> Raft服务器通过RPC来交互，只需要两个RPC操作，RequestVote RPCs and AppendEntries RPCs。RequestVote用于选举而AppendEntries用于leader发送请求进行relicate log entries和心跳。</p>
<h4 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h4><p>&emsp;Raft通过心跳机制来触发leader selection。当一个服务器启动时，默认位于followers状态，并且一直持续知道它一直接受到leader的RPC请求。leader会周期性发送心跳给所有的followers。如果follower一段时间内没有接受到心跳，那么就认为当前没有leader应该开始leader selection。<br>&emsp;开始election后，server将其Term进行加一，然后转变成candidate状态，并且给其他所有server发送RequestVote RPC请求来进行vote。这个过程一直持续到：server自己赢得election,其他的server赢得election,或者这个Term期间没有server获胜，进入下一个Term。<br>&emsp;candidate收到半数以上server的vote就赢得了election。每个server在一个Term中只会vote一次。server基于first-come-and-first-serve的规则来进行投票。一旦某个candidate赢得了election, 就变成了leader,并且开始周期性发送心跳。<br>&emsp;当等待投票时，candidate受到了其他candidate发送的AppendEntries PRC请求,如果candiate发现在包含在请求当中的Term数值大于或则等于自己的Term数值，那么该candiate主动退回到follower状态，否在拒绝该请求，继续保持candidate状态。<br>&emsp;当很多server变成candidate状态进行election时，选举失败的可能性就很高了。那么每个candiate会推迟随机时间之后进入下一个Term并进行新的election。以此来避免大量的选举失败的情况发生。</p>
<h4 id="Log-replication"><a href="#Log-replication" class="headerlink" title="Log replication"></a>Log replication</h4><p>&emsp;一旦一个leader被选举成功，它就开始处理client请求。每个client请求都包含一个需要被replicated state machine处理的命令，leader将这些命令当作一个新的entry添加到log中。然后给follower发送AppendEntries RPCs请求来复制这个log entry。当一个entry被safely relicated(在下一小结中会讲解)，leader就会将entry交给state machine进行执行，并且将结果返回。<br>&emsp;当一个log entry可以被安全的交给state machine处理时，我们认为它是committed的。Raft保证所有committed的log entry一定是持久化的，并且一定被state machine执行。Log entry是committed一旦该entry在大多数follower上被replicated。一旦一个entry被committed,那么在它之前的所有log也是committed的。Leader会随时关注最大的committed的log的index,并在AppendEntries RPCs请求中携带该信息，这样follower就能知道哪些entry被committed，它们就会将其提交给自己的state machine来执行。<br>&emsp;当followers crash或则网络丢包时，leader会一直发送AppendEntries RPCs直到所有followers都存储了entry。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017725-raft-raft1.png" alt="log entry的排列"></p>
<p>&emsp;每个Log entry都有其唯一标识，entry中包括了 leader Term，index和要执行的comand。index是指entry在Log中的位置。Raft通过Log Machine Property来维护Log的合理性：</p>
<ul>
<li>如果两个entries在不同的logs中(存储在不同的server上)拥有相同的index和term,那么他们包含相同的command。</li>
<li>如果两个entries在不同的logs中拥有相同的index和term,那么他们之前的entries也都是一致或在内容相同的。<br>&emsp;第一条规定保证leader每个Term中的每个index最多只能创建一个entry。而第二条规定使得followers在处理AppendEntries RPCs请求时要进行一致性检测。leader在AppendEntries请求中带上了自己logs中排在新entry之前的那个entry的index和term,如果follower在自己的logs中找不到该entry,那么就拒绝添加new entry。这样就保证了第二条规定不会被违反。<br>&emsp;正常情况下，leader和followers的logs都是一致的，但是当一系列的leader crash，followers crash和election之后，followers的logs可能会被当前leader的logs多出一些entry,也可能会少一些entry。在Raft中，leader通过强迫followers的logs复制leader的logs来保持一致性。这就意味着follower logs中的冲突的entry会被重写。</li>
</ul>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017725-raft-raft2.png" alt="leader和follower的logs冲突"></p>
<p>&emsp;为了一致化logs,leader的logs需要和follower的logs进行对比，找出它们之间最后一条相同的entry。然后将follower logs中那条entry之后的所有entry删除，并发送leader logs中那条entry之后的entry给follower。这些行为都发生在AppendEntries RPCs的一致性检查过程中。<br>&emsp;leader会每个follower维护一个nextIndex来记录发送给这个follower的下一条log entry的index。nextIndex初始化为leader logs的最后一条entry之后的index。如果follower的logs和leader的logs不一致，那么AppendEntries RPCs的一致性检查就会失败。leader发现自己的请求被follower拒绝了，那么就减少该follower的nextIndex然后再次发送AppendEntries请求。最终nextIndex就会变成二者log中最后一个一致的entry的index。当上述情况发生之后，AppendEntries请求就会成功，就会删除follower中多的entry和添加缺少的entry。</p>
<h4 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h4><p>&emsp;这一小节主要描述在leader election过程中的一些限定。这些限定保证任何一个Term的leader的logs都包含了之前Term中所有committed的entry。这也是所谓的Leader Completeness Property。</p>
<h4 id="Election限制"><a href="#Election限制" class="headerlink" title="Election限制"></a>Election限制</h4><p>&emsp;Raft规定：在election过程中，new leader本身必须有之前Term中所有committed的log entry。也就是说每次election成功的leader必然包含之前所有的committed的log entry。这样保证了log的单向流动，一定是从leader到follower。<br>&emsp;Raft通过election vote过程来保证上述限制。一个candidate必须得到集群中多于半数的server的vote，而每个committed的log entry一定也会存在于多于半数的server的logs中。也就是说在RequestVote RPC中包含了candidate自己logs中最后一个committed的log信息，接受到该请求的server会将其和自己log中最后一个committed的log进行对比，如果自己的log晚于candiate的，那么就同意该candiate成为leader,否在拒绝。这样的话，没有包含所有committed log entry的candidate就一定不会得到超过半数的server的vote。Raft根据entry的term和index来确定每个entry的先后顺序。较大term的log entry比较新，如果log entry的term一致，那就是越大的index约新。</p>
<h5 id="Committing-entries-from-previous-terms"><a href="#Committing-entries-from-previous-terms" class="headerlink" title="Committing entries from previous terms"></a>Committing entries from previous terms</h5><p>&emsp;如果旧的leader在committing an entry时crash了，那么新的leader是否需要重新commit这个entry呢？但是为了简化，Raft重来不会提交之前Term的log entry。没有被committed的log entry就会被重写。</p>
<h5 id="Followers-and-candidate-crashs"><a href="#Followers-and-candidate-crashs" class="headerlink" title="Followers and candidate crashs"></a>Followers and candidate crashs</h5><p>&emsp;如果followers或在candidate在接受到RPC之前crash，leader会一直重试发送RPC。如果是在接受处理之后crash，没有发送回复，leader也是会重复发送RPC,但是因为RPC都是幂等的，所以不会造成额外的影响。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>&emsp;Raft的应用十分广泛，比如etcd项目就是使用Raft来保证分布式一致性的，之后我也想去研究一下etcd中Raft的实现，毕竟之前都是理论。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/1df31392/" data-id="ck8hgb9lh003e2xsewqirv01j" class="article-share-link"><i class="fa fa-share"></i>共有</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Kubernetes部署" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/51083ebf/">Kubernetes部署</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/51083ebf/">
            <time datetime="2017-07-23T07:33:52.000Z" itemprop="datePublished">2017-07-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/docker/">docker</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/docker/">docker</a>, <a class="tag-link" href="/tags/kubernetes/">kubernetes</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;学习完Docker之后，发现了kubernetes这个容器云框架，于是就自己部署来玩玩。大家也可以按照这个<a href="和我一步步部署 kubernetes 集群">和我一步步部署 kubernetes 集群</a>文章来部署。最近在这里花费了大量的时间，之后希望整理一下相关的原理介绍。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017723-kube-kuber1.png" alt="kuber1.png"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017723-kube-kube3.png" alt="kube3.png"></p>
<h3 id="问题列表和解决方案"><a href="#问题列表和解决方案" class="headerlink" title="问题列表和解决方案"></a>问题列表和解决方案</h3><ul>
<li>google源找不到解决方案：<br><a href="http://www.jianshu.com/p/4f5066dad9b4" target="_blank" rel="noopener">http://www.jianshu.com/p/4f5066dad9b4</a><br>公钥未安装导致无法安装</li>
<li>Created API client, waiting for the control plane to become ready<br>卡死在这里，阿里云需要使用内网ip地址 你也可以使用journalctl -u kubelet 查看日志<br>ApiServer的debug <a href="https://github.com/kubernetes/kubernetes/wiki/Debugging-FAQ" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/wiki/Debugging-FAQ</a></li>
<li>SSL/TLS协议<br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></li>
<li>etcd cant bind the addr<br><a href="https://github.com/coreos/etcd/issues/4789" target="_blank" rel="noopener">https://github.com/coreos/etcd/issues/4789</a><br>nc -l 10.5.0.9 2380<br>iptables查看端口问题</li>
<li>flanneld<br><a href="https://stackoverflow.com/questions/34439659/flannel-and-docker-dont-start" target="_blank" rel="noopener">https://stackoverflow.com/questions/34439659/flannel-and-docker-dont-start</a><br>flanneld 启动/kubernetes 没有找到<br>//fail to retrieve network config: invalid charactar</li>
<li><p>linux低版本不支持flanneld的vxlan功能，需要换成udp<br>cant register network : oeperation not supported<br><a href="https://github.com/coreos/etcd/issues/3710" target="_blank" rel="noopener">https://github.com/coreos/etcd/issues/3710</a></p>
</li>
<li><p>linux低版本不支持docker<br><a href="http://dockone.io/question/1060" target="_blank" rel="noopener">http://dockone.io/question/1060</a><br>pod-infra-container-image</p>
</li>
<li>dashboard<br><a href="https://github.com/kubernetes/kubernetes/issues/39722" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/39722</a></li>
<li>127.0.3.1:9090 cant connection<br><a href="http://blog.csdn.net/xinghun_4/article/details/50492041" target="_blank" rel="noopener">http://blog.csdn.net/xinghun_4/article/details/50492041</a><br>add route<br><a href="https://github.com/kubernetes/dashboard/issues/672" target="_blank" rel="noopener">https://github.com/kubernetes/dashboard/issues/672</a></li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/51083ebf/" data-id="ck8hgb9kv001u2xsevjtvbgwk" class="article-share-link"><i class="fa fa-share"></i>共有</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Docker系列之Jenkins自动化部署" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/b4f6f76f/">Docker系列之Jenkins自动化部署</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/b4f6f76f/">
            <time datetime="2017-07-02T13:23:35.000Z" itemprop="datePublished">2017-07-02</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/docker/">docker</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Docker/">Docker</a>, <a class="tag-link" href="/tags/Jenkins/">Jenkins</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> Devops的概念已经火了很久了，我一直想对这方面进行一定的了解；再加上实验室项目环境依赖比较复杂，希望使用Docker来解决，所以最近就好好研究了一波Docker的相关实践和原理。这里整理一下，希望组成一个系列，从实践到原理详细讲解一下Docker的使用。<br> 第一篇就讲一下Jenkins+Docker的自动化部署实践。大致的流程如下：目前我有两个服务器，分别是阿里云和bandwagon,代码存储在github上，每次push都会触发阿里云上的jenkins的构建任务，jenkins将github上的代码fetch到本地，编译打包成war文件，生成docker image并上传到docker registry上，然后通过ssh来登录bandwagon服务器pull下来新生成的image并启动。由于篇幅问题，本篇文章不会介绍有关docker image的build和docker registry的搭建，但是我会在后续文章中再做详细讲解。<br> 学习Docker，我推荐先在网络上找说明指南，一步一步自己尝试的使用，然后如果觉得有必要可以看一下《Docker容器和容器云》这本书。<br> 本文内容都是docker和jenkins的基础知识，为了节约你的时间，本文的主要内容如下：</p>
<ul>
<li>docker 基础命令</li>
<li>jenkins docker版本的搭建，构建任务的配置</li>
<li>Pubish Over SSH 安装和配置</li>
<li>通过github的webhook来触发jenkins构建任务</li>
</ul>
<h4 id="Docker运行jenkins"><a href="#Docker运行jenkins" class="headerlink" title="Docker运行jenkins"></a>Docker运行jenkins</h4><p> Docker如此火爆的一个原因是因为它形成了一个良好的生态圈，基本上主流的软件应用都有相应的Docker image。如果大家不清楚Docker image的含义，建议大家看一下<a href="https://www.gitbook.com/book/richardhc/chinese_docker/details" target="_blank" rel="noopener">Docker中文指南</a>，我们可以通过<code>docker pull</code>命令来下载响应的image,然后运行。比如我们希望在阿里云服务器上部署一个jenkins应用，首先可以执行下列语句来获取一个jenkins的image。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">docker pull jenkinsci&#x2F;jenkins:lts
</code></pre></p>
<p> 这里我们使用pull从docker registry上拉取image,但是目前业界上有很多共有或在私有的docker registry,比如说docker hub和daoCloud。所以image的全称就由三部分组成:域名或在ip + / + 软件名称 + : + 版本号，所以上边的这条命令就是让docker去jenkinsci这个Jenkins机构自己部署的registry上下载jenkins的lts版本的image.你也可以直接使用<code>docker pull jenkins</code>来下载image,但docker会默认的从docker hub上下载jenkins的laster版本。</p>
<p> 下载成功之后，你可以使用<code>docker images</code>命令来查看当前下载的image信息</p>
<p> 你可以通过<code>docker run</code>命令来运行docker容器，请注意我这里的用词，在Docker中image和container是不同的概念，你可以将他们简单的理解成Java中类和对象的关系。我们使用下面的命令来启动这个jenkins容器。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">sudo docker run -d --name jenkins -p 9090:8080 -v &#x2F;var&#x2F;jenkins_home:&#x2F;var&#x2F;jenkins_home jenkinsci&#x2F;jenkins:lts
</code></pre></p>
<p> 我们来依次讲解一下run命令的几个参数把：</p>
<ul>
<li><p><code>-d</code> 后台运行docker容器并打印容器ID。如果不加<code>-d</code>参数，那么容器运行会和终端绑定，如果终端关闭，那么容器也会关闭，但是容器不会被删除。但是如果你只是想试一试某个容器，运行后自动进入命令行，那么可以使用-it参数;如果你想容器关闭之后自动删除，那么就使用-rm参数。</p>
</li>
<li><p><code>--name</code> 给docker container起一个别名，后续可以通过别名来管理容器，否在会系统会默认分配一个随机的别名。</p>
</li>
<li><p><code>-p</code> docker容器和外侧的端口映射，jenkins服务是运行在docker容器内部的，但是docker容器默认不对外暴露接口，所以通过这个参数将内部的8080端口映射到服务器本身的9090端口上。</p>
</li>
<li><p><code>-v</code> 数据卷的挂载。这里涉及到docker container的一个特性，container如果停止运行了，那么再次启动时，之前所有运行相关的数据和文件就都不存在了，就类似于设置了自动还原的电脑一般，无论你做了多少的操作，一旦关机重启之后就又恢复到最初的状态。数据卷就是来解决上述问题的，通过Docker container外部的文件夹的挂载，将可持久化的文件存储到外部挂载的文件夹中。</p>
</li>
</ul>
<p> 然后你就可以根据你自己的ip地址来键入下列地址http:ip:9090来访问jenkins的主页了。<br>&emsp;这里有一点需要注意的是，需要注意你阿里云服务器设置的网络安全协议，是否禁用掉了9090这个端口。</p>
<h4 id="Publish-over-SSH配置"><a href="#Publish-over-SSH配置" class="headerlink" title="Publish over SSH配置"></a>Publish over SSH配置</h4><p>&emsp;Jenkins的初始化配置和SSH Over Publish的安装请大家自行百度，这里我主要讲解一下SSH Over Pushlish配置。<br>&emsp;首先我们要在jenkins服务器上生成密钥对，使用<code>ssh-keygen -t rsa</code>命令来生成秘密对，这样的话，在~/.ssh/下就会有私钥id_rsa和公钥id_rsa.pub。<br>&emsp;然后你需要上传公钥到目标服务器上，也就是我的bandwagon服务器上，可以使用<code>ssh-copy-id</code>来将文件上传到服务器上，类似于<code>scp</code>命令的使用方式。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub &lt;username&gt;@&lt;host&gt;
</code></pre></p>
<p>&emsp;最后我们需要修改目标服务器的ssh配置文件，配置文件为/etc/ssh/sshd_config。设置ssh-server允许使用私钥和公钥对的方式登录，然后使用<code>sudo /etc/init.d/ssh restart</code>命令重启ssh服务。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">RSAAuthentication yes
PubkeyAuthentication yes
#AuthorizedKeysFile     %h&#x2F;.ssh&#x2F;authorized_keys
</code></pre></p>
<p>&emsp;上述步骤成功之后，大家在系统管理中配置Publish over SSH。相关的配置信息如下图所示。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins1.png" alt="jenkins1.png"></p>
<p>&emsp;你还可以点击下方的高级选项，来配置ssh服务器的端口，超时时间等信息，还可以点击Test Configuration来检测是否配置成功。</p>
<h4 id="构建任务配置"><a href="#构建任务配置" class="headerlink" title="构建任务配置"></a>构建任务配置</h4><p>&emsp;我们先创建一个构建任务，该任务从github repo上将代码拉取下来，然后执行构建任务，然后通过Publish Over SSH在目标服务器上进行部署。<br>&emsp;我们首先配置源码管理模块，选择Git选项，然后配置Repository URL 并添加认证信息。可以将自己的github帐号和密码加入其中。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins2.png" alt="jenkins2.png"></p>
<p>&emsp;不同的项目的构建命令不同，但是我们可以在构建后操作模块设置后续操作，通过ssh登录目标服务器，让目标服务器执行命令行操作来pull最新上传的image并且执行，这样就完成了部署。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins3.png" alt="jenkins3.png"></p>
<h4 id="Push触发构建任务"><a href="#Push触发构建任务" class="headerlink" title="Push触发构建任务"></a>Push触发构建任务</h4><p>&emsp;完成上述配置，你就可以手动在jenkins上启动构架任务了，但是要做到自动化部署，还必须设置Push操作自动触发jenkins构建任务的机制。<br>&emsp;我们先到首页-用户管理界面打开自己的用户界面，然后点击左侧的设置按钮，并点击<code>show API token</code>按钮来获取API token.然后在构建任务设置页面的构建触发器模块勾选触发远程构建选项，并将token填到里边去。这是jenkins会提示你如何通过URL来触发构建任务。<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins5.png" alt="jenkins5.png"></p>
<p>&emsp;然后我们打开github上相应库的设置页面。点击左侧的Webhooks选项，然后添加hook.将上述的url填写到Payload URL栏中，点击添加。如果添加成功之后，每次你push一个新版本，那么jenkins就会自动进行部署了。<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/201772-docker-jenkins6.png" alt="jenkins6.png"></p>
<p>&emsp;如果你发现webhooks发送请求失败，那可能是因为你jenkins安全设置的问题，禁止掉了发送请求自动化构建。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;本篇讲的都是十分基础性的内容，后一篇文章讲一下dockerfile的原理和注意事项与docker registry。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/b4f6f76f/" data-id="ck8hgb9ko001g2xselvg9rfa0" class="article-share-link"><i class="fa fa-share"></i>共有</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-《多处理器编程艺术》－链表：锁的作用" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/56d732a0/">《多处理器编程艺术》－链表：锁的作用</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/56d732a0/">
            <time datetime="2017-06-19T13:57:31.000Z" itemprop="datePublished">2017-06-19</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/并发/">并发</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/锁/">锁</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 最近在阅读《多处理器编程艺术》一书，掌握了很多Java多线程的底层知识，现在就做一下书中链表-锁的作用一章的总结。<br>&emsp;为了节约你的时间，本文主要内容如下：</p>
<ul>
<li>带锁的链表队列</li>
<li>细粒度同步</li>
<li>乐观同步</li>
<li>惰性同步</li>
<li>非阻塞同步</li>
</ul>
<h3 id="粗粒度同步"><a href="#粗粒度同步" class="headerlink" title="粗粒度同步"></a>粗粒度同步</h3><p>&emsp;所谓粗粒度同步其实很简单，就是在List的<code>add</code>,<code>remove</code>,<code>contains</code>函数的开始就直接使用Lock加锁，然后在函数结尾释放。<br>&emsp;<code>add</code>函数的代码如下所示，函数的主体就是链表的遍历添加逻辑，只不过在开始和结束进行了锁的获取和释放。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">private Node head;
private Lock lock = new ReentrantLock();
public boolean add(T item) {
    Node pred, curr;
    int key = item.hashCode();
    lock.lock();
    try {
        pred = head;
        curr = pred.next;
        while(curr.key &lt; key) {
            pred = curr;
            curr = pred.next;
        }
        if (key == curr.key) {
            return false;
        } else {
            Node node = new Node(item);
            node.next = curr;
            pred.next = node;
            return true;
        }

    } finally {
        lock.unlock();
    }
}
</code></pre></p>
<p>&emsp;大家看到这里就会想到，这不就是类似于<code>Hashtable</code>的实现方式吗？把可能出现多线程问题的函数都用一个重入锁锁住。但是这个方法的缺点很明显，如果竞争激烈的话，对链表的操作效率会很低，因为<code>add</code>,<code>remove</code>,<code>contains</code>三个函数都需要获取锁，也都需要等待锁的释放。至于如何优化，我们可以一步一步往下看</p>
<h3 id="细粒度同步"><a href="#细粒度同步" class="headerlink" title="细粒度同步"></a>细粒度同步</h3><p>&emsp;<strong><em>我们可以通过锁定单个节点而不是整个链表来提高并发</em></strong>。给每个节点增加一个Lock变量以及相关的lock()和unlock()函数,当线程遍历链表的时候，若它是第一个访问节点的线程，则锁住被访问的节点，在随后的某个时刻释放锁。这种细粒度的锁机制允许并发线程以流水线的方式遍历链表。<br>&emsp;使用这种方式来遍历链表，必须同时获取两个相邻节点的锁，通过“交叉手”的方式来获取锁：除了初始的head哨兵节点外，只有在已经获取pred的锁时，才能获取curr的锁。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;每个Node对象中都有一个Lock对象，可以进行lock()和unlock()操作
public boolean add(T item) {
    int key = item.hashCode();
    head.lock();
    Node pred = head;
    try {
        Node curr = pred.next;
        curr.lock();

        try {
            while (curr.key &lt; key) {
                pred.unlock();
                pred = curr;
                curr = pred.next;
                curr.lock();
            }

            if (curr.key == key) {
                return false;
            }
            Node newNode = new Node(item);
            newNode.next = curr;
            pred.next = newNode;
            return true;
        } finally {
            curr.unlock();
        }

    } finally {
        pred.unlock();
    }
}
</code></pre>
<h3 id="乐观同步"><a href="#乐观同步" class="headerlink" title="乐观同步"></a>乐观同步</h3><p>&emsp;虽然细粒度锁是对单一粒度锁的一种改进，但它仍然出现很长的获取锁和释放锁的序列。而且，访问链表中不同部分的线程仍然可能相互阻塞。例如，一个正在删除链表中第二个元素的线程将会阻塞所有试图查找后继节点的线程。<br>&emsp;减少同步代价的一种方式就是乐观：<strong><em>不需要获取锁就可以查找，对找到的节点进行加锁，然后确认锁住的节点是正确的；如果一个同步冲突导致节点被错误的锁定，则释放这些锁重新开始</em></strong>。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public boolean add(T item) {
    int key = item.hashCode();

    while (true) { &#x2F;&#x2F;如果不成功，就进行重试
        Node pred = head;
        Node curr = pred.next;
        while (curr.key &lt; key) {
            pred = curr;
            curr = pred.next;
        }
        &#x2F;&#x2F;找到目标相关的pred和curr之后再将二者锁住
        pred.lock();
        curr.lock();
        try {
            &#x2F;&#x2F;锁住二者之后再进行判断，是否存在并发冲突
            if (validate(pred, curr)) {
                &#x2F;&#x2F;如果不存在，那么就直接进行正常操作
                if (curr.key == key) {
                    return false;
                } else {
                    Node node = new Node(item);
                    node.next = curr;
                    pred.next = node;
                }
            }
        } finally {
            pred.unlock();
            curr.unlock();
        }
    }
}
public boolean validate(Node pred, Node curr) {
    &#x2F;&#x2F;从队列头开始查找pred和curr,判断是否存在并发冲突
    Node node = head;
    while (node.key &lt;= pred.key) {
        if (node == pred) {
            return pred.next == curr;
        }
        node = node.next;
    }
    return false;
}
</code></pre></p>
<p>&emsp;由于不再使用能保护并发修改的锁，所以每个方法调用都可能遍历那些已经被删除的节点，所以在进行添加，删除获取判断是否存在的之前必须再次进行验证。</p>
<h3 id="惰性同步"><a href="#惰性同步" class="headerlink" title="惰性同步"></a>惰性同步</h3><p>&emsp;当不用锁遍历两次链表的代价比使用锁遍历一次链表的代价小很多时，乐观同步的实现效果非常好。但是这种算法的缺点之一就是contains()方法在遍历时需要锁，这一点并不令人满意，其原因在于对contains()的调用要比其他方法的调用频繁得多。<br>&emsp;<strong><em>使用惰性同步的方法，使得contains()调用是无等待的，同时add()和remove()方法即使在被阻塞的情况下也只需要遍历一次链表</em></strong>。<br>&emsp;<strong><em>对每个节点增加一个布尔类型的marked域，用于说明该节点是否在节点集合中。现在，遍历不再需要锁定目标结点，也没有必须通过重新遍历整个链表来验证结点是否可达。所有未被标记的节点必然是可达的</em></strong>。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">&#x2F;&#x2F;add方法和乐观同步的方法一致，只有检验方法做了修改。
&#x2F;&#x2F;只需要检测节点的marked变量就可以，并且查看pred的next是否还是指向curr，需要注意的是marked变量一定是voliate的。
private boolean validate(Node pred, Node curr) {
        return !pred.marked &amp;&amp; !curr.marked &amp;&amp; pred.next == curr;
}
</code></pre>
<p>&emsp;惰性同步的优点之一就是能够将类似于设置一个flag这样的逻辑操作与类似于删除结点的链接这种对结构的物理改变分开。通常情况下，延迟操作可以是批量处理方式进行，且在某个方便的时候再懒惰地进行处理，从而降低了对结构进行物理修改的整体破裂性。惰性同步的主要缺点是add()和remove()调用是阻塞的：如果一个线程延迟，那么其他线程也将延迟。</p>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>&emsp;使用惰性同步的思维是非常有益处的。我们可以进一步将add(),remove()和contains()这三个方法都变成非阻塞的。前两个方法是无锁的，最后一个方法是无等待的。我们无法直接使用compareAndSet()来改变next域来实现，因为这样会出现问题。但是我们可以将结点的next域和marked域看作是单个的原子单位：当marked域为true时，对next域的任何修改都将失败。<br>&emsp;我们可以使用AtomicMarkableReference<t>对象将指向类型T的对象引用next和布尔值marked封装在一起。这些域可以一起或单个地原子更新。可以让每个结点的next域为一个AtomicMarkableReference<node>。线程可以通过设置结点next域中的标记位来逻辑地删除curr,和其他正在执行add()和remove()的线程共享物理删除:当每个线程遍历链表时，通过物理删除所有被标记的节点来清理链表。</node></t></p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">
    public Window find(Node head, int key) {
        Node pred = null, curr = null, succ = null;
        boolean[] marked = {false};
        boolean snip;

        retry: while(true) {
            pred = head;
            curr = curr.next.get(marked);
            while(true) {
                succ = curr.next.get(marked); &#x2F;&#x2F;获取succ,并且查看是被被标记
                while (marked[0]) {&#x2F;&#x2F;如果被标记了，说明curr被逻辑删除了，需要继续物理删除
                    snip = pred.next.compareAndSet(curr, succ, false, false);&#x2F;&#x2F;
                    if (!snip) continue retry;
                    curr = succ;
                    succ = curr.next.get(marked);
                }
                &#x2F;&#x2F;当不需要删除后，才继续遍历
                if (curr.key &gt;= key) {
                    return new Window(pred, curr);
                }
                pred = curr;
                curr = succ;
            }
        }
    }

    public boolean add(T item) {
        int key = item.hashCode();
        while(true) {
            Window window = find(head, key);
            Node pred = window.pred, curr = window.curr;
            if (curr.key == key) {
                return false;
            } else {
                Node node = new Node(item);
                node.next = new AtomicMarkableReference&lt;&gt;(curr, false);
                if (pred.next.compareAndSet(curr, node, false, false)) {
                    return true;
                }
            }
        }
    }

    public boolean remove(T item) {
        int key = item.hashCode();
        boolean sinp;
        while(true) {
            Window window = find(head, key);
            Node pred = window.pred, curr = window.curr;
            if (curr.key != key) {
                return false;
            } else {
                Node succ = curr.next.getReference();
                &#x2F;&#x2F;要进行删除了，那么就直接将curr.next设置为false,然后在进行真正的物理删除。
                sinp = curr.next.compareAndSet(curr, succ, false, true);
                if (!sinp) {
                    continue;
                }
                pred.next.compareAndSet(curr, succ, false, false);
                return true;
            }
        }
    }


class Node {
          AtomicMarkableReference&lt;Node&gt; next;
}
</code></pre>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;文中的代码在我的github的这个<a href="https://github.com/ztelur/MultiprocessorProgramming/tree/master/src/com/company/nine" target="_blank" rel="noopener">repo</a>中都可以找到。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/56d732a0/" data-id="ck8hgb9mf005c2xse28ubznv3" class="article-share-link"><i class="fa fa-share"></i>共有</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/3/">&laquo; 前</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/5/">次 &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最近の記事</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/a94bd30a/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/article/a94bd30a/" class="title">MySQL的死锁系列- 锁的类型以及加锁原理</a></p>
                            <p class="item-date"><time datetime="2020-03-31T14:06:26.000Z" itemprop="datePublished">2020-03-31</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/d5009955/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/java-persistent/">java persistent</a></p>
                            <p class="item-title"><a href="/article/d5009955/" class="title">Java 数据持久化系列之池化技术</a></p>
                            <p class="item-date"><time datetime="2020-02-02T13:48:17.000Z" itemprop="datePublished">2020-02-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/75dc863d/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/plan/">plan</a></p>
                            <p class="item-title"><a href="/article/75dc863d/" class="title">2020年，计划目录</a></p>
                            <p class="item-date"><time datetime="2020-01-27T05:00:09.000Z" itemprop="datePublished">2020-01-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/24b8edbf/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Redis/">Redis</a></p>
                            <p class="item-title"><a href="/article/24b8edbf/" class="title">Redis Cluster 的数据分片机制</a></p>
                            <p class="item-date"><time datetime="2019-12-21T13:24:26.000Z" itemprop="datePublished">2019-12-21</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/1dd72ef8/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Redis/">Redis</a></p>
                            <p class="item-title"><a href="/article/1dd72ef8/" class="title">Redis 命令执行过程(下)</a></p>
                            <p class="item-date"><time datetime="2019-12-11T15:09:14.000Z" itemprop="datePublished">2019-12-11</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">カテゴリ</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SICP/">SICP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-persistent/">java persistent</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/plan/">plan</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计/">设计</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">アーカイブ</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">3</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">タグクラウド</h3>
        <div class="widget tagcloud">
            <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Animation/" style="font-size: 10px;">Animation</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GSON/" style="font-size: 10px;">GSON</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/JUC/" style="font-size: 20px;">JUC</a> <a href="/tags/Jenkins/" style="font-size: 10px;">Jenkins</a> <a href="/tags/Material-Design/" style="font-size: 10px;">Material Design</a> <a href="/tags/MotionEvent/" style="font-size: 10px;">MotionEvent</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 20px;">Netty</a> <a href="/tags/OkHttp/" style="font-size: 15px;">OkHttp</a> <a href="/tags/Raft/" style="font-size: 10px;">Raft</a> <a href="/tags/React-Native/" style="font-size: 10px;">React Native</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/SICP/" style="font-size: 10px;">SICP</a> <a href="/tags/Shader/" style="font-size: 10px;">Shader</a> <a href="/tags/Span/" style="font-size: 15px;">Span</a> <a href="/tags/Spring-Boot/" style="font-size: 15px;">Spring Boot</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/TCP-IP/" style="font-size: 20px;">TCP/IP</a> <a href="/tags/View/" style="font-size: 15px;">View</a> <a href="/tags/View-Architecture/" style="font-size: 10px;">View Architecture</a> <a href="/tags/ViewRoot/" style="font-size: 10px;">ViewRoot</a> <a href="/tags/Window机制/" style="font-size: 10px;">Window机制</a> <a href="/tags/animation/" style="font-size: 10px;">animation</a> <a href="/tags/cas/" style="font-size: 10px;">cas</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/draw/" style="font-size: 10px;">draw</a> <a href="/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/tags/filesystem/" style="font-size: 10px;">filesystem</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/kubernetes/" style="font-size: 10px;">kubernetes</a> <a href="/tags/persistent/" style="font-size: 15px;">persistent</a> <a href="/tags/redis/" style="font-size: 20px;">redis</a> <a href="/tags/scroll/" style="font-size: 15px;">scroll</a> <a href="/tags/spring-cloud/" style="font-size: 10px;">spring-cloud</a> <a href="/tags/事件传递/" style="font-size: 15px;">事件传递</a> <a href="/tags/依赖注入/" style="font-size: 10px;">依赖注入</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/动态编程/" style="font-size: 10px;">动态编程</a> <a href="/tags/反射/" style="font-size: 10px;">反射</a> <a href="/tags/图像处理/" style="font-size: 10px;">图像处理</a> <a href="/tags/实习/" style="font-size: 10px;">实习</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/工具-Linux/" style="font-size: 10px;">工具, Linux</a> <a href="/tags/市场/" style="font-size: 10px;">市场</a> <a href="/tags/并发/" style="font-size: 10px;">并发</a> <a href="/tags/思维/" style="font-size: 10px;">思维</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/文件系统/" style="font-size: 10px;">文件系统</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/注解/" style="font-size: 20px;">注解</a> <a href="/tags/第三方库/" style="font-size: 15px;">第三方库</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a> <a href="/tags/贪婪算法/" style="font-size: 10px;">贪婪算法</a> <a href="/tags/软件设计/" style="font-size: 10px;">软件设计</a> <a href="/tags/锁/" style="font-size: 10px;">锁</a> <a href="/tags/限流/" style="font-size: 15px;">限流</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">リンク</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://www.blueskykong.com/">aoho blog</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2020 历小冰<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
	<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
	<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
	<script>
		var gitment = new Gitment({
			owner: 'lexburner',
			repo: 'lexburner.github.io',
			oauth: {
				client_id: 'd5fc3e1150477a0d433d',
				client_secret: 'aa94acd5f130281051b9e703c19b4c6d878e90c4',
			},
		})
		gitment.render('commentContainer')
	</script>
	



    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
    



<link rel="stylesheet" href="/css/prism.css">
<script type="text/javascript" src="/js/prism.js"></script>
<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>