
 <!DOCTYPE HTML>
<html lang="Chinese">
<head>
  <meta charset="UTF-8">
  
    <title>Carpediem</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="remCarpediem">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Carpediem">
<meta property="og:url" content="http://remcarpediem.com/page/4/index.html">
<meta property="og:site_name" content="Carpediem">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Carpediem">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="Carpediem" type="application/atom+xml">
    
    
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Carpediem">Carpediem</a></h1>
				<h2 class="blog-motto">blog of nobody</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:remcarpediem.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/01/01/Material-Design-标注图/" title="Material Design 标注图" itemprop="url">Material Design 标注图</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2016-01-01T10:40:33.000Z" itemprop="datePublished"> Published 2016-01-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;最近发现自己在实现产品需求时,在界面元素的细节部分把握不够准确,经常被leader告知需要微调一下界面元素的各类尺寸.虽然导致这个因素的最重要的原因是我场的设计太懒,不给标注,但是作为一个终端工程师,了解并掌握足够的设计相关的知识还是十分必要的,于是最近就开始研究其google的Material Design设计风格.<br>&emsp;本篇文章主要是收集一些MD风格的设计标注图和注意事项,主要内容都来自于<a href="http://www.uisdc.com/comprehensive-material-design-note#" target="_blank" rel="external">重磅教程！帮你全面彻底搞定MATERIAL DESIGN的学习笔记</a>.</p>
<blockquote>
<p>MD风格的精髓在于<br>把物理世界的体验带进屏幕,去掉现实的杂质和随机性,保留保留其最原始纯净的形态、空间关系、变化与过渡，配合虚拟世界的灵活特性，还原最贴近真实的体验，达到简洁与直观的效果</p>
</blockquote>
<p>&emsp;其实以我现在的理解就是:</p>
<ul>
<li>界面元素的层次性</li>
<li>交互时强调带有意义并且具有现实特性的动画</li>
<li>两种纯色作为应用的基本颜色</li>
</ul>
<p>&emsp;这篇只是收藏MD风格中关于一些特定界面元素的标注图以备以后使用</p>
<h4 id="文字排版"><a href="#文字排版" class="headerlink" title="文字排版"></a>文字排版</h4><p>常用字号：</p>
<ul>
<li>12sp 小字提示</li>
<li>14sp（桌面端13sp） 正文/按钮文字</li>
<li>16sp（桌面端15sp） 小标题</li>
<li>20sp Appbar文字</li>
<li>24sp 大标题</li>
<li>34sp/45sp/56sp/112sp 超大号文字</li>
</ul>
<p>&emsp;长篇幅正文，每行建议60字符（英文）左右。短文本，建议每行30字符（英文）左右。</p>
<h4 id="常用尺寸"><a href="#常用尺寸" class="headerlink" title="常用尺寸"></a>常用尺寸</h4><blockquote>
<p>所有可操作元素最小点击区域尺寸：48dp X 48dp。<br>  栅格系统的最小单位是8dp，一切距离、尺寸都应该是8dp的整数倍。以下是一些常见的尺寸与距离：</p>
</blockquote>
<ul>
<li>顶部状态栏高度：24dp</li>
<li>Appbar最小高度：56dp</li>
<li>底部导航栏高度：48dp</li>
<li>悬浮按钮尺寸：56x56dp/40x40dp</li>
<li>用户头像尺寸：64x64dp/40x40dp</li>
<li>小图标点击区域：48x48dp</li>
<li>侧边抽屉到屏幕右边的距离：56dp</li>
<li>卡片间距：8dp</li>
<li>分隔线上下留白：8dp</li>
<li>大多元素的留白距离：16dp</li>
<li>屏幕左右对齐基线：16dp</li>
<li><p>文字左侧对齐基线：72dp<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_a-33.png" alt="enter image description here"></p>
<h4 id="Button-sheets"><a href="#Button-sheets" class="headerlink" title="Button sheets"></a>Button sheets</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_button_sheet_1.png" alt="enter image description here"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_button_sheet_2.png" alt="enter image description here"></p>
<h4 id="Buttons"><a href="#Buttons" class="headerlink" title="Buttons"></a>Buttons</h4><p>&emsp;按钮分为悬浮按钮,凸起按钮和扁平按钮</p>
</li>
<li><p>悬浮按钮的操作都是正向操作</p>
</li>
<li>建议只用一个悬浮按钮</li>
<li>悬浮按钮可以贴在纸片边缘或者接缝处，但不要贴在对话框、侧边抽屉和菜单的边缘</li>
<li>悬浮按钮不能被其他元素盖住，也不能挡住其他按钮</li>
<li>列表滚动至底部时，悬浮按钮应该隐藏，防止它挡住列表项<br>悬浮按钮的位置不能随意摆放，可以贴着左右两边的对齐基线</li>
</ul>
<h4 id="Cards"><a href="#Cards" class="headerlink" title="Cards"></a>Cards</h4><ul>
<li>卡片统一带有2dp的圆角</li>
<li>同时展现多种不同内容</li>
<li>卡片内容之间不需要进行比较</li>
<li>包含了长度不确定的内容，比如评论</li>
<li>包含丰富的内容与操作项，比如赞、滚动条、评论</li>
<li>本该是列表，但文字超过3行</li>
<li><p>本该是网格，但需要展现更多文字<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_cards_1.png" alt="enter image description here"></p>
<h4 id="Dialogs"><a href="#Dialogs" class="headerlink" title="Dialogs"></a>Dialogs</h4></li>
<li><p>注意有些对话框点击周围会消失,但是有些是不会消失的</p>
</li>
<li><p>对话框的四周留白比较大，通常是24dp。<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_dialog_1.png" alt="enter image description here"></p>
<h4 id="Dividers"><a href="#Dividers" class="headerlink" title="Dividers"></a>Dividers</h4></li>
<li><p>列表中有头像、图片等元素时，使用内嵌分隔线，左端与文字对齐。</p>
</li>
<li>没有头像、图标等元素时，需要用通栏分隔线。</li>
<li>谨慎使用分隔线，留白和小标题也能起到分隔作用。能用留白的地方，优先使用留白。分隔线的层级高于留白。</li>
</ul>
<h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><ul>
<li><p>列表由行构成，行内包含瓦片。如果列表项内容文字超过3行，请改用卡片。如果列表项的主要区别在于图片，请改用网格。<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_list_1.png" alt="enter image description here"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_list_2.png" alt="enter image description here"></p>
<h4 id="Pickers"><a href="#Pickers" class="headerlink" title="Pickers"></a>Pickers</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_pickers_1.png" alt="日期选择器"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_pickers_1.png" alt="时间选择器"></p>
<h4 id="Progress-amp-activity"><a href="#Progress-amp-activity" class="headerlink" title="Progress &amp; activity"></a>Progress &amp; activity</h4></li>
<li><p>进度条分为确定时间和不确定时间,不同的类型,动画效果不同</p>
</li>
<li>进度条可以使用在一些本来就有的元素上,比如悬浮按钮</li>
</ul>
<h4 id="Snackbars"><a href="#Snackbars" class="headerlink" title="Snackbars"></a>Snackbars</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_snackbars_1.png" alt="snackbars尺寸"></p>
<h4 id="Text-fields"><a href="#Text-fields" class="headerlink" title="Text fields"></a>Text fields</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_text_fields_1.png" alt="Text1"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_text_fields_2.png" alt="Text2"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_text_fields_3.png" alt="Text3"></p>
<h4 id="NavigatorBar"><a href="#NavigatorBar" class="headerlink" title="NavigatorBar"></a>NavigatorBar</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_navigator_1.png" alt="navigator尺寸"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计/">设计</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Material-Design/">Material Design</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/01/01/Material-Design-标注图/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/01/01/Material-Design-标注图/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/12/Android文件存储位置简述/" title="Android文件存储位置简述" itemprop="url">Android文件存储位置简述</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-12-12T09:11:54.000Z" itemprop="datePublished"> Published 2015-12-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;最近一段时间,工作和学习方面都比较忙,所以,博客方面有一段时间没有投入时间啦,今天学习了一下android文件存储方面的知识,主要是<code>Internal Storage</code>和<code>External Storage</code>的相关特性.主要知识来自android的官方文档和其他人的博客.</p>
<h4 id="Internal-Storage"><a href="#Internal-Storage" class="headerlink" title="Internal Storage"></a>Internal Storage</h4><p>&emsp;一般来说,你可以直接存储文件在机器的internal storage中,存储在这个位置的文件是私有的,其他应用无法获得.但是当用户卸载你的应用时,文件就被删除啦.</p>
<blockquote>
<p>通过<code>openFileOutput()</code>传入文件的名字和操作模式,就可以获得<code>FileOutputStream</code>,然后就可以<code>write()</code>,然后<code>close</code>啦.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String FILENAME = <span class="string">"hello_file"</span>;</span><br><span class="line">String string = <span class="string">"hello world!"</span>;</span><br><span class="line"></span><br><span class="line">FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);</span><br><span class="line">fos.write(string.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure></p>
<p><code>MODE_PRIVATE</code>模式会创建或者替换同名文件,并让文件变为私有的,其他的一些模式还有<code>MODE_APPEND</code>(追加模式),<code>MODE_WORLD_READABLE</code>(全局可读)和<code>MODE_WORLD_WRITEABLE</code>(全局可写).<br>通过<code>OpenFileInput()</code>函数可以进行文件的读取.</p>
</blockquote>
<p>&emsp;Android的内部存储路径为/data/data/packagename/,加入你的应用名为com.example.test,那么这个路径就为/data/data/com.example.test,这个路径下一般会有files,cache和你自己生成的文件夹.那么如下的操作返回的路径如下</p>
<ul>
<li>Context.getFileDir(),获得/data/data/com.example.test/files这个文件夹的File对象</li>
<li>Context.openFileInput()和Context.openFileOutput,读取的是files文件夹下的文件</li>
<li>Context.fileList(),返回的是files下的所有文件名</li>
<li>Context.deleteFile(),删除files下指定名称的文件</li>
<li>Context.getCacheDir(),该方法返回的是/data/data/com.example.test/cache的File对象.当Android的内部存储容量过低时,android会自动清除缓存文件.</li>
<li>getDir(String name,int mode),返回的是/data/data/com.example.test/下指定名称的文件夹的File对象</li>
</ul>
<h4 id="External-Storage"><a href="#External-Storage" class="headerlink" title="External Storage"></a>External Storage</h4><p>&emsp;所有android设备都会提供外部存储,你可以用来保存文件,但是存储在外部存储的文件是完全公开的,并且可以被用户修改,外部存储可能无法获得,并且存储的文件的安全性很低,会被修改或者删除.<br>&emsp;获得    外部存储的访问权必须需要申请<code>READ_EXTERNAL_STORAGE</code>或者<code>WRITE_EXTERNAL_STORAGE</code>权限,如果申请了写权限,那么相应的读权限也获得啦.如果是Android 6.0,那么权限的申请可能就更加麻烦 :<a href="http://jijiaxin89.com/2015/08/30/Android-s-Runtime-Permission/" target="_blank" rel="external">6.0新的权限管理系统</a><br>&emsp;在使用外部存储设备之前,必须先检查外部存储设备的挂载情况,然后再进行文件操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Checks if external storage is available for read and write */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExternalStorageWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Checks if external storage is available to at least read */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExternalStorageReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state) ||</span><br><span class="line">        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;如果你想存储一些可以和其他应用共享的文件时,一般存储在共享的文件夹中,比如<code>Music/</code>,’Pictures/‘,’Ringtones/‘通过<code>Environment.getExternalStoragePublicDirectory</code>,传递给其文件夹的类型,比如<code>DIRECTORY_MUSIC</code>,<code>DIRECTORY_PICTURES</code>,就可以获得响应文件夹的File对象.<br>&emsp;当你不想其他应用读取你的文件时,你可能需要使用私有文件夹.通过<code>getExternalFilesDir()</code>,并传递给其子文件夹的type,就可以打开响应的文件夹,在4.4之后,读取私有文件夹下的文件,是不需要外部存储设备权限的.<br>&emsp;外部存储设备的路径一般都以/mnt/sdcard开始,如下的一些函数获得路径如下:</p>
<ul>
<li>getExternalCacheDir() 获得/mnt/sdcard/Android/data/com.example.test/cache 文件夹的File对象</li>
<li>getExternalFilesDir(type)获得/mnt/sdcard/Android/data/com.example.test/files文件夹下响应子文件夹的File对象</li>
<li>Environment.getExternalStorageDiretory() 获得的是/mnt/sdcard文件夹的File对象</li>
<li>Environment.getDataDirectory() 获得是的/data文件夹的File对象,需要注意的是,/data/data/Android/就是内部存储文件夹啦.</li>
<li>Environment.getDownloadCacheDirectory() 获得的是/cache文件夹的File对象.</li>
</ul>
<p>参考文章:</p>
<ul>
<li><a href="http://blog.csdn.net/ljh347917444/article/details/16984199" target="_blank" rel="external">android 系统文件路径.sdcard路径.外部路径</a> </li>
<li><a href="http://developer.android.com/intl/zh-cn/guide/topics/data/data-storage.html#filesInternal" target="_blank" rel="external">Android Doc</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/文件系统/">文件系统</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/12/12/Android文件存储位置简述/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/12/12/Android文件存储位置简述/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/18/OkHttp解析系列-重定向和出错重试/" title="OkHttp解析系列-重定向和出错重试" itemprop="url">OkHttp解析系列-重定向和出错重试</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-11-18T14:00:10.000Z" itemprop="datePublished"> Published 2015-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emps;这是OkHttp系列博文的第一篇，之前写过一篇草稿，介绍OkHttp的整体框架，但是感觉涉及的知识太多，无法在一篇中讲述清楚，所以，之后的博文都只关注某一方面的知识，争取文章短小精悍。<br>&emsp;今天主要研究一下OkHttp发送<code>Http</code>请求过程中的重定向和出错重试，主要涉及的源码文件有<code>Call.java``HttpEngine.java</code>。<br>&emsp;我们今天研究<code>Call</code>的<code>Response getResponse(Request request, boolean forWebSocket) throws IOException</code>函数，它是你调用<code>Call.execute()</code>返回<code>Response</code>所调用的核心函数，主要功能是新建一个<code>HttpEngine</code>发送<code>Request</code>然后处理出错重试和重定向问题。</p>
<h4 id="设置Headers"><a href="#设置Headers" class="headerlink" title="设置Headers"></a>设置Headers</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy body metadata to the appropriate request headers.</span></span><br><span class="line">  RequestBody body = request.body();</span><br><span class="line">  <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Request.Builder requestBuilder = request.newBuilder();<span class="comment">//拷贝了内部数据</span></span><br><span class="line"></span><br><span class="line">    MediaType contentType = body.contentType();</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">    <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request = requestBuilder.build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;这是函数的第一部分，主要是将<code>RequestBody</code>的一些元数据拷贝到<code>Header</code>的首部中,主要是<code>Content-Type</code>和<code>Transfer-Encoding</code>。<code>Content-Type</code>相信大家都了解，标示<code>RequestBody</code>的<code>Mime-Type</code>，格式为<code>主类型/子类型</code>，比如<code>text/xml</code>。而<code>Transfer-Encoding</code>是表示一种网络传输的方式，想具体了解的同学可以看一下这个链接<a href="https://imququ.com/post/transfer-encoding-header-in-http.html" target="_blank" rel="external">点我</a>.</p>
<h4 id="出错重试"><a href="#出错重试" class="headerlink" title="出错重试"></a>出错重试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the initial HTTP engine. Retries and redirects need new engine for each attempt.</span></span><br><span class="line">    <span class="comment">// 建立一个初始的http 引擎，每次重试和重定向都需要新的引擎</span></span><br><span class="line">    engine = <span class="keyword">new</span> HttpEngine(client, request, <span class="keyword">false</span>, <span class="keyword">false</span>, forWebSocket, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>; <span class="comment">//连续发送请求</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (canceled) &#123; <span class="comment">//如果被取消啦</span></span><br><span class="line">        engine.releaseConnection();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        engine.sendRequest();</span><br><span class="line">        engine.readResponse();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RequestException e) &#123;</span><br><span class="line">        <span class="comment">// The attempt to interpret the request failed. Give up.</span></span><br><span class="line">        <span class="keyword">throw</span> e.getCause();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        HttpEngine retryEngine = engine.recover(e); <span class="comment">//重试引擎</span></span><br><span class="line">        <span class="keyword">if</span> (retryEngine != <span class="keyword">null</span>) &#123;</span><br><span class="line">          engine = retryEngine;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Give up; recovery is not possible.</span></span><br><span class="line">        <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        HttpEngine retryEngine = engine.recover(e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (retryEngine != <span class="keyword">null</span>) &#123;</span><br><span class="line">          engine = retryEngine;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Give up; recovery is not possible.</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">      .......</span><br></pre></td></tr></table></figure>
<p>&emsp;在这段代码中，<code>OkHttp</code>建立一个<code>HttpEngine</code>对象来负责<code>Http</code>层级的请求的发送和回复的接收，<code>HttpEngine</code>会在之后的博文中详细讲解。然后进入了一个<code>while</code>循环,这个循环其实主要是处理重定向问题的。我们在这一节中主要关注<code>catch</code>中的逻辑，这是用于处理出错重试的逻辑。由于外层有一个<code>while</code>循环，所以在<code>catch</code>中尝试获得<code>retryEngine</code>，如果有就<code>continue</code>,没有就抛出异常。</p>
<h4 id="重定向处理"><a href="#重定向处理" class="headerlink" title="重定向处理"></a>重定向处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Response response = engine.getResponse();</span><br><span class="line">      <span class="comment">// followUp这个是优化http connection的使用率的吗？</span></span><br><span class="line">      Request followUp = engine.followUpRequest();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!forWebSocket) &#123; <span class="comment">//如果没有followup并且不是为了websocket</span></span><br><span class="line">          engine.releaseConnection();<span class="comment">//关闭连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!engine.sameConnection(followUp.httpUrl())) &#123; <span class="comment">//如果followup的httpUrl不是同一个连接,也就是</span></span><br><span class="line">        <span class="comment">//schema，host or port 有一个不同</span></span><br><span class="line">        engine.releaseConnection();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//复用了上一次的connection啊！！！！</span></span><br><span class="line">      Connection connection = engine.close();</span><br><span class="line">      request = followUp;</span><br><span class="line">      <span class="comment">//继续处理，有可能是重定向啦</span></span><br><span class="line">      engine = <span class="keyword">new</span> HttpEngine(client, request, <span class="keyword">false</span>, <span class="keyword">false</span>, forWebSocket, connection, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">          response);</span><br></pre></td></tr></table></figure>
<p>&emsp;这里我们可以看到<code>Http</code>重定向的机制。<code>Request request = engine.followUpRequest()</code>来获得重定向需要发送的<code>Request</code>，如果没有或者重定向次数大于<code>MAX_FOLLOW_UPS</code>就不会重新发送重定向请求。然后判断重定向请求和原请求的HttpUrl是否相同，否则也不会发送重定向请求。然后<code>Connection connection = engine.close()</code>会释放资源并且复用上次的连接，然后新建一个<code>HttpEngine</code>然后继续<code>While</code>循环发送请求。</p>
<h4 id="重定向状态码解析"><a href="#重定向状态码解析" class="headerlink" title="重定向状态码解析"></a>重定向状态码解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">followUpRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (userResponse == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  Proxy selectedProxy = getRoute() != <span class="keyword">null</span></span><br><span class="line">      ? getRoute().getProxy()</span><br><span class="line">      : client.getProxy();</span><br><span class="line">  <span class="keyword">int</span> responseCode = userResponse.code();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (responseCode) &#123;</span><br><span class="line">    <span class="keyword">case</span> HTTP_PROXY_AUTH: <span class="comment">//407 Proxy authentication required 要先经过代理服务器认证</span></span><br><span class="line">      <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// fall-through</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_UNAUTHORIZED: <span class="comment">//401 没有身份认证</span></span><br><span class="line">      <span class="keyword">return</span> OkHeaders.processAuthHeader(client.getAuthenticator(), userResponse, selectedProxy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> HTTP_PERM_REDIRECT:<span class="comment">// 308</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_TEMP_REDIRECT: <span class="comment">//307</span></span><br><span class="line">      <span class="comment">// "If the 307 or 308 status code is received in response to a request other than GET</span></span><br><span class="line">      <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span></span><br><span class="line">      <span class="keyword">if</span> (!userRequest.method().equals(<span class="string">"GET"</span>) &amp;&amp; !userRequest.method().equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="comment">//如果不是get和head 那么就不能自动转发</span></span><br><span class="line">      <span class="comment">// fall-through</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_MULT_CHOICE: <span class="comment">//300</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_MOVED_PERM:<span class="comment">// 301</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_MOVED_TEMP:<span class="comment">//302</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_SEE_OTHER: <span class="comment">//303</span></span><br><span class="line">      <span class="comment">// Does the client allow redirects?</span></span><br><span class="line">      <span class="keyword">if</span> (!client.getFollowRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//如果不允许重定向</span></span><br><span class="line"></span><br><span class="line">      String location = userResponse.header(<span class="string">"Location"</span>);<span class="comment">//从response的头部获得的location</span></span><br><span class="line">      <span class="keyword">if</span> (location == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      HttpUrl url = userRequest.httpUrl().resolve(location);<span class="comment">//使用request的解析location</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Don't follow redirects to unsupported protocols.</span></span><br><span class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If configured, don't follow redirects between SSL and non-SSL.</span></span><br><span class="line">      <span class="keyword">boolean</span> sameScheme = url.scheme().equals(userRequest.httpUrl().scheme());</span><br><span class="line">      <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.getFollowSslRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Redirects don't include a request body.</span></span><br><span class="line">      Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.permitsRequestBody(userRequest.method())) &#123;</span><br><span class="line">        requestBuilder.method(<span class="string">"GET"</span>, <span class="keyword">null</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Type"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></span><br><span class="line">      <span class="comment">// is potentially annoying to the application layer since they have no</span></span><br><span class="line">      <span class="comment">// way to retain them.</span></span><br><span class="line">      <span class="keyword">if</span> (!sameConnection(url)) &#123;</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Authorization"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> requestBuilder.url(url).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;这一段就是根据回复的状态码生成重定向请求的代码逻辑。</p>
<ul>
<li>HTTP_PROXY_AUTH 407  表示需要经过代理服务器认证 ，这时抛出异常，不进行重定向</li>
<li>HTTP_UNAUTHORIZED 401 身份未认证</li>
<li>HTTP_PERM_REDIRECT 308 HTTP_TEMP_REDIRECT 307 这两种状态码时，只有当请求的<code>method</code>不为<code>GET</code>和<code>HEAD</code>时不进行重定向，否则按照下边一列状态码的方式处理</li>
<li>HTTP_MULT_CHOICE  300 HTTP_MOVED_PERM 301 HTTP_MOVED_TEMP 302 HTTP_SEE_OTHER 303 当是这些状态码时，先判断是否运行重定向，然后获得<code>Response</code>中的<code>Location</code>首部的值，然后用<code>HttpUrl</code>去解析，如果是<code>host</code>不同，那么去掉所有的认证首部，这是为了安全。<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4>&emsp;今天所总结的只是<code>Http</code>的重定向部分和<code>OkHttp</code>中的关于重定向的逻辑部分。之后会陆陆续续的继续总结关于<code>Http</code>的知识。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/NetWork/">NetWork</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/OkHttp/">OkHttp</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/18/OkHttp解析系列-重定向和出错重试/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/18/OkHttp解析系列-重定向和出错重试/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/07/OkHttp解析系列-开篇/" title="OkHttp解析系列-开篇" itemprop="url">OkHttp解析系列-开篇</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-11-07T03:55:04.000Z" itemprop="datePublished"> Published 2015-11-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>&emsp;前几天使用<code>react-native</code>遇到了底层<code>okhttp</code>库<code>cookie</code>无法保存的问题，由于自己对http和<code>okhttp</code>也不是很了解.所以想开一个系列的博文，借助详细解析<code>okhttp</code>的详细解析来梳理一下http相关的知识。</p>
<h4 id="Okhttp"><a href="#Okhttp" class="headerlink" title="Okhttp"></a>Okhttp</h4><p>&emsp;<code>Okhttp</code>是很火而且效率很好的一个android的网络库，被很多app或者开源库使用或者集成，比如<code>react-native</code>,官网地址如下<a href="http://square.github.io/okhttp/" target="_blank" rel="external">戳我</a>.</p>
<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p>&emsp;事先声明，我画的这张UML类图不够标准，正方形的虚线边框是我自己添加上去的，只是逻辑上或者概念上的分类，标示这些类大致是属于哪个模块的，而且也没有添加各个类之间的依赖关系。之所以使用这张图，主要是希望表面<code>okhttp</code>代码的不同模块吧。也算为以后的博客进行内容区分。<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/okhttpOkHttp%E5%8D%9A%E5%AE%A2.jpg" alt="enter image description here"></p>
<h4 id="Okhttp模块"><a href="#Okhttp模块" class="headerlink" title="Okhttp模块"></a>Okhttp模块</h4><p>&emsp;之后的博客，就会按照上图的不同模块来进行，首先是<code>OkHttp</code>的主要框架模块，然后是请求和响应相关的模块，然后是关于http机制的模块，最后是关于http报文格式的模块。现在计划是如此，可能在博文之间会添加一些http知识。就这么愉快的决定啦。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/NetWork/">NetWork</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/OkHttp/">OkHttp</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/07/OkHttp解析系列-开篇/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/07/OkHttp解析系列-开篇/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/04/React-Native-Android-Cookie-Problem/" title="React Native Android Cookie Problem" itemprop="url">React Native Android Cookie Problem</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-11-04T05:50:31.000Z" itemprop="datePublished"> Published 2015-11-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>&emsp;最近使用react native 来写一个公司内部使用的app，使用<code>fetch</code>去登陆，发现在android平台上无法获取cookie，iOS平台上却可以。即使是<code>response.headers.get()</code>也获得不了相关信息。于是上网google并且阅读源码，终于找到了问题出现的原因和解决方案。</p>
<h4 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h4><p>&emsp;我们查看<code>native react</code>的<code>fetch.js</code>的代码，发现它的底层是使用<code>XmlHttpRequest</code>来实现的，然后再次找到’XmlHttpRequest’的相关源码，发现了三个文件<code>XMLHttpRequest.android.js</code>,<code>XMLHttpRequest.ios.js</code>和<code>XMLHttpRequestBase.js</code>。我们主要研究了android相关的文件。<br>&emsp;先看’XMLHttpRequest.android.js’。它继承了<code>XMLHttpRequestBase</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XMLHttpRequest</span> <span class="keyword">extends</span> <span class="title">XMLHttpRequestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  _requestId: ?number;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>._requestId = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sendImpl(method: ?string, url: ?string, headers: <span class="built_in">Object</span>, data: any): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'string'</span>) &#123;</span><br><span class="line">      body = &#123;string: data&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> FormData) &#123;</span><br><span class="line">      body = &#123;</span><br><span class="line">        formData: data.getParts().map((part) =&gt; &#123;</span><br><span class="line">          part.headers = convertHeadersMapToArray(part.headers);</span><br><span class="line">          <span class="keyword">return</span> part;</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      body = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//RCTNetWorking是android的native module，使用okhttp实现，我们之后会看到相关的代码</span></span><br><span class="line">    <span class="keyword">this</span>._requestId = RCTNetworking.sendRequest(</span><br><span class="line">      method,</span><br><span class="line">      url,</span><br><span class="line">      convertHeadersMapToArray(headers),</span><br><span class="line">      body,</span><br><span class="line">      <span class="keyword">this</span>.callback.bind(<span class="keyword">this</span>)<span class="comment">//这里是调用native module的回调，具体callback实现在XMLHttpRequestBase中。</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  abortImpl(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._requestId &amp;&amp; RCTNetworking.abortRequest(<span class="keyword">this</span>._requestId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;通过源码，我们可以了解，<code>XMLHttpRequest</code>就是通过Android Native Module 来发送网络请求的，然后会回调到<code>callback</code>函数中。我们接下来看看一下<code>callback</code>函数.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">callback(status: number, responseHeaders: ?<span class="built_in">Object</span>, responseText: string): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._aborted) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.status = status;</span><br><span class="line">  <span class="keyword">this</span>.setResponseHeaders(responseHeaders || &#123;&#125;);</span><br><span class="line">  <span class="keyword">this</span>.responseText = responseText;</span><br><span class="line">  <span class="keyword">this</span>.setReadyState(<span class="keyword">this</span>.DONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;这里我们发现<code>callback</code>回调有三个参数,<code>status</code>,<code>responseHeaders</code>和<code>responseText</code>,那么为什么在外层的<code>fetch</code>会拿不到<code>header</code>中的<code>cookie</code>呢？这里就需要研究android native module的实现啦。<br>&emsp;<code>RCTNetworking</code>对应的java文件为<code>NetworkingModule.java</code>，找到这个文件，直接看<code>sendRequest</code>函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReactMethod</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(</span><br><span class="line">    String method,</span><br><span class="line">    String url,</span><br><span class="line">    <span class="keyword">int</span> requestId,</span><br><span class="line">    ReadableArray headers,</span><br><span class="line">    ReadableMap data,</span><br><span class="line">    <span class="keyword">final</span> Callback callback)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//....... 无关代码省略</span></span><br><span class="line">  mClient.newCall(requestBuilder.build()).enqueue(</span><br><span class="line">      <span class="keyword">new</span> com.squareup.okhttp.Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, IOException e)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (mShuttingDown) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          callback.invoke(<span class="number">0</span>, <span class="keyword">null</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (mShuttingDown) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// TODO(5472580) handle headers properly</span></span><br><span class="line">          String responseBody;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            responseBody = response.body().string();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// The stream has been cancelled or closed, nothing we can do</span></span><br><span class="line">            <span class="comment">//这里是重点，我们发现第二个参数本该传递header,但是现在确实传的null，导致上层的js代码无法获得header!!!!</span></span><br><span class="line">            callback.invoke(<span class="number">0</span>, <span class="keyword">null</span>, e.getMessage());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          callback.invoke(response.code(), <span class="keyword">null</span>, responseBody);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####解决方案<br>&emsp;在<code>fetch</code>或者<code>XMLHttpRequest</code>拿不到头部信息的问题找到了，那么如何让react native android实现cookie呢？<br>&emsp;方案有两套，一是：<code>callback.invoke</code>时把头部信息传递上去，让js层去做cookie的相关逻辑；二是:给<code>Okhttp</code>添加<code>CookieHandler</code>让<code>Okhttp</code>自己管理<code>Cookie</code>。<br>&emsp;第二套方案是我在github上看到的<a href="https://github.com/facebook/react-native/pull/3723/files" target="_blank" rel="external">github相关讨论和code</a>，相关代码在github上已经被merge到master上去啦，相信不久之后，新版本的<code>React Native Android</code>就可以把这个坑填上啦。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/React-Native/">React Native</a><a href="/tags/Cookie/">Cookie</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/04/React-Native-Android-Cookie-Problem/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/04/React-Native-Android-Cookie-Problem/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/28/Window和WindowManager解析/" title="Window和WindowManager解析" itemprop="url">Window和WindowManager解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-10-28T07:35:51.000Z" itemprop="datePublished"> Published 2015-10-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;这几天阅读了《Android开发艺术探索》的关于Window和WindowManager的章节,特此写一片博文来整理和总结一下学到的知识.<br>&emsp;说到Window,大家都会想到所有的视图,包括Activity,Dialog,Toast,它们实际上都是附加在Window上的,Window是这些视图的管理者.今天我们就来具体将一下这些视图是如何附加在Window上的,Window有是如何管理这些视图的.</p>
<h4 id="Window的属性和类别"><a href="#Window的属性和类别" class="headerlink" title="Window的属性和类别"></a>Window的属性和类别</h4><p>&emsp;当我们通过WindowManager添加Window时,可以通过WindowManger.LayoutParams来确定Window的属性和类别.其中Flags参数标示Window的属性,我们列出几个比较常见的属性:</p>
<ul>
<li><p><code>FLAG_NOT_FOCUSABLE</code> 这个参数表示Window不需要获取焦点,也不需要接收任何输入事件</p>
</li>
<li><p><code>FLAG_NOT_TOUCH_MODAL</code> 这个参数表示当前Window区域之外的点击事件传递给底层Window,区域之内的点击事件自己处理,一般默认开启</p>
</li>
<li><p><code>FLAG_SHOW_WHEN_LOCKED</code> 这个属性可以让Window显示在锁屏界面上<br>&emsp;Window不仅有属性,还有类型.Type参数表示Window的类型,分别为应用Window(activity对应的),子window(dialog对应的),和系统Window(Toast和系统通知栏).Window是分层的,每个window都有z-ordered,层级大的window会覆盖层级小的window,其大小关系为系统window&gt;子window&gt;应用window.所以系统window总会显示在最上边,但是使用系统window是需要声明相应的权限的.这一点需要注意.</p>
<h4 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h4><p>&emsp;我们先来看一下WindowManager的接口,对其接口函数的了解有助于我们更好的理解Window的类别和属性.<br>&emsp;WindowManger实现了ViewManager这个接口,所提供的主要函数只有三个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params);</span><br><span class="line">public void updateViewLayout(View view, ViewGroup.LayoutParams params);</span><br><span class="line">public void removeView(View view);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;而且通过阅读源码,我们会发现所有的操作都是交由WindowManagerGloalal来进行.之后的小节我会依次介绍.这一节先讲一下它的比较重要的成员变量.<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 存储所有window所对应的view</span><br><span class="line">    private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();</span><br><span class="line">    // 存在window所对应的viewRootImpl</span><br><span class="line">    private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line">    // 存储了所有window对应的布局参数</span><br><span class="line">    private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">            new ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line">    // 存储了那些正在被删除的view对象,调用了removeVIew,但是没有完成的</span><br><span class="line">    private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;();</span><br></pre></td></tr></table></figure></p>
<h4 id="Window的添加过程"><a href="#Window的添加过程" class="headerlink" title="Window的添加过程"></a>Window的添加过程</h4><p>&emsp;这是WindowManagerGlobal的对应接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">           Display display, Window parentWindow)</span><br></pre></td></tr></table></figure>
<p>&emsp;创建ViewRootImpl,并将View添加到相应的列表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建ViewRootImpl,然后将下述对象添加到列表中</span><br><span class="line">root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line">       view.setLayoutParams(wparams);//设置Params</span><br><span class="line">       mViews.add(view);//window列表添加</span><br><span class="line">       mRoots.add(root);//ViewRootImpl列表添加</span><br><span class="line">       mParams.add(wparams);//布局参数列表添加</span><br></pre></td></tr></table></figure>
<p>&emsp;通过ViewRootImpl来更新界面完成window的添加过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 添加啦!!!!!!!!这是通过ViewRootImpl的setView来完成</span><br><span class="line">root.setView(view, wparams, panelParentView);</span><br></pre></td></tr></table></figure>
<p>&emsp;在ViewRootImpl的setView函数中,会调用requestLayout来完成异步刷新,然后在requestLayout<br>中调用scheduleTraversals来进行view绘制.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   	public void requestLayout() &#123;</span><br><span class="line">       if (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">           checkThread();</span><br><span class="line">           mLayoutRequested = true;</span><br><span class="line">           scheduleTraversals(); // 实际View绘制的入口</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;最后通过WindowSession来完成Window的添加过程,它是一个Binder对象,通过IPC调用来添加window.<br>&emsp;所以,Window的添加请求就交给WindowManagerService去处理,在其内部为每个应用保留一个单独的Session.</p>
<h4 id="Window的删除过程"><a href="#Window的删除过程" class="headerlink" title="Window的删除过程"></a>Window的删除过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void removeView(View view, boolean immediate) &#123;</span><br><span class="line">    if (view == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;view must not be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        int index = findViewLocked(view, true); //先找到view的index</span><br><span class="line">        View curView = mRoots.get(index).getView();</span><br><span class="line">        removeViewLocked(index, immediate);</span><br><span class="line">        if (curView == view) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new IllegalStateException(&quot;Calling with view &quot; + view</span><br><span class="line">                + &quot; but the ViewAncestor is attached to &quot; + curView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;removeView先通过findViewLocked来查找待删除的View的索引,然后用removeViewLocked来做进一步删除.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void removeViewLocked(int index, boolean immediate) &#123;</span><br><span class="line">    ViewRootImpl root = mRoots.get(index); //获得当前的view的viewRootImpl</span><br><span class="line">    View view = root.getView();</span><br><span class="line"></span><br><span class="line">    if (view != null) &#123; //先让imm下降</span><br><span class="line">        InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">        if (imm != null) &#123;</span><br><span class="line">            imm.windowDismissed(mViews.get(index).getWindowToken());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean deferred = root.die(immediate); //die方法只是发送一个请求删除的消息之后就就返回</span><br><span class="line">    if (view != null) &#123;</span><br><span class="line">        view.assignParent(null);</span><br><span class="line">        if (deferred) &#123;</span><br><span class="line">            mDyingViews.add(view);//加入dyingView</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;在WindowManager中提供了两种删除接口removeVIew()和removeViewImmediate(),它们分别表示异步和同步删除.而异步操作中会调用die函数,来发送一个MSG_DIE消息来异步删除,ViewRootImpl的Handler会调用doDie(),而如果是同步删除,那么就直接调用doDie(),然后在removeView函数中把View添加到mDyingViews中.</p>
<h4 id="Window的更新"><a href="#Window的更新" class="headerlink" title="Window的更新"></a>Window的更新</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">      	.....</span><br><span class="line">final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</span><br><span class="line">       view.setLayoutParams(wparams);</span><br><span class="line">       synchronized (mLock) &#123;</span><br><span class="line">           int index = findViewLocked(view, true);</span><br><span class="line">           ViewRootImpl root = mRoots.get(index);</span><br><span class="line">           mParams.remove(index);</span><br><span class="line">           mParams.add(index, wparams);</span><br><span class="line">           root.setLayoutParams(wparams, false);//这是主要的方法</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;在setLayoutParams中会调用scheduleTraversals来重新绘制.</p>
<h4 id="Window的创建过程"><a href="#Window的创建过程" class="headerlink" title="Window的创建过程"></a>Window的创建过程</h4><p>&emsp;不同类型的Window的创建过程不同,这里我只来讲一下Activity的Window的创建过程.在Window的启动过程中,会调用attach()函数来为其关联运行过程中所依赖的一系列上下文环境变量.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mWindow = PolicyManager.makeNewWindow(this);</span><br><span class="line">mWindow.setCallback(this);</span><br></pre></td></tr></table></figure>
<p>&emsp;Window对象是通过PolicyManager的makeNewWindow方法实现的,由于Activity实现了Window的Callback接口,因此当Window接收到外界的状态改变时就会回调Activity的对应方法.而我们去追寻Window的具体实现类,会发现它就是PhoneWindow,而Activity中最常用的setContentView方法的具体操作都是在PhoneWindow的相应方法中实现的.</p>
<p>&emsp;如果没有DecorView,那么就创建它.DecorView是一个FrameLayout,是Activity中的顶级View,一般包括标题栏和内容栏,而且内容栏的id为android.R.id.content,而DecorView的创建过程由installDecor完成,内部会通过generateDecor方法来直接创建DecorView</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (mContentParent == null) &#123; //如何没有DecorView,那么就新建一个</span><br><span class="line">           installDecor();</span><br><span class="line">       &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">           mContentParent.removeAllViews();</span><br><span class="line">       &#125;</span><br><span class="line"> 	if (mDecor == null) &#123;</span><br><span class="line">           mDecor = generateDecor(); //直接new出一个DecorView返回</span><br><span class="line">           ......</span><br><span class="line">       &#125;</span><br><span class="line">       if (mContentParent == null) &#123;</span><br><span class="line">           //[window] 这一步也是很重要的.</span><br><span class="line">           mContentParent = generateLayout(mDecor); </span><br><span class="line">           .......</span><br><span class="line">           &#125;</span><br><span class="line">       .......</span><br></pre></td></tr></table></figure>
<p>&emsp;而在generateLayout中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//根据不同的style生成不同的decorview啊</span><br><span class="line">       View in = mLayoutInflater.inflate(layoutResource, null);</span><br><span class="line">       // 加入到deco中,所以应该是其第一个child</span><br><span class="line">       decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">       mContentRoot = (ViewGroup) in; </span><br><span class="line">       //给DecorView的第一个child是mContentView</span><br><span class="line">       // 这是获得所谓的content</span><br><span class="line">       ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br></pre></td></tr></table></figure></p>
<p>  &emsp;将View添加到DecorView的mContentParent中,这步只需要一条语句就可,具体内部细节就不说啦.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//第二步,将layout添加到mContentParent</span><br><span class="line">       mLayoutInflater.inflate(layoutResID, mContentParent);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;然后就是回调Acitivity的onContentChanged方法通知Activity视图已经改变了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final Callback cb = getCallback();</span><br><span class="line">       if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">           cb.onContentChanged();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;经历了上述三个步骤,DecorView已经创建并初始化完毕,并且Activity的布局文件已经成功添加到DecorView的mContentParent中,但是DecorView并没有添加到WindowManager中去,也无法接收外界的输入,只有到Acitivity的makeVisible()被调用时,DecorView才真正完成了添加和显示过程.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//DecorView正式添加并显示</span><br><span class="line">void makeVisible() &#123;</span><br><span class="line">   if (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = true;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;这篇博文主要是读书笔记式的总结,本来想写一些自己的东西,但是研究的太浅,并且语言组织上还是有不足,以后还需要注意和继续努力啦.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/源码分析/">源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android/">Android</a><a href="/tags/Window机制/">Window机制</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/10/28/Window和WindowManager解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/10/28/Window和WindowManager解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/17/生活学习记录一-RxJava-实习感悟/" title="生活学习记录一:RxJava+实习感悟" itemprop="url">生活学习记录一:RxJava+实习感悟</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-10-17T09:54:47.000Z" itemprop="datePublished"> Published 2015-10-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;很久之前就希望自己可以把生活中的点滴都化为文字,记录下来了,今天就写下第一篇博文吧.希望有个好的开始,然后坚持下去.<br>&emsp;前一段时间,在腾讯员工的微信群中看到了有关RxJava和eventBus的对比文章的分享,于是趁着周末,研究一下最近很火的RxJava的使用.<br>&emsp;在学习RxJava的过程中主要参考了下列的几篇文章:</p>
<ul>
<li><p><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给android开发者的RxJava详解</a> ,这是我主要学习的一篇,大多数有关RxJava的知识都是从这里获得的.</p>
</li>
<li><p><a href="http://nicholas.ren/2015/07/19/rx-revisit.html" target="_blank" rel="external">Rx revisit</a>   ,作者主要讲述了Netflix开发Rx系列的原由,Observable和Iterator的区别</p>
</li>
<li><p><a href="http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/" target="_blank" rel="external">Implementing an Event Bus With RxJava - RxBus</a> ,主要讲述了Observer pattern和Pub-sub pattern的区别,和如何使用RxJava去模仿EventBus.</p>
</li>
<li><p><a href="http://www.zhihu.com/topic/20027327" target="_blank" rel="external">知乎-RxJava和EventBus的区别</a> ,看看知友的回答</p>
</li>
<li><p><a href="https://github.com/lzyzsd/Awesome-RxJava" target="_blank" rel="external">Awesome-RxJava</a>, github的有关Rx的文章集合<br>&emsp;阅读了那么多的文章,并且写了一些例子,但是还是感觉没有领会到RxJava的精髓.还需要在正式的项目中使用,才可以算是正在的入了门.<br>&emsp;最近的实习也不是很顺利,出现了很多的问题.不过这也很好,在扇贝的实习所学习到的和在腾讯实习正好是相互补充的.在腾讯实习时,可能是大家都比较忙,代码的质量由开发者自己保证,mentor也不会太认真的帮你进行reivew.而在扇贝则是不太一样,要求比较高的代码的质量,涉及的一些规则和原则其实我也都知道,但是在实际的开发过程中,开始时,代码质量还可以保持在较高的水平,但是随之开发的进行,需求的修改,debug,代码就开始有了”腐烂”的气味.知道原则而不是在实际过程中使用就等于不知道.所以,在单纯的编码方面你还是需要更加的谨慎.<br>&emsp;而在腾讯,大家都比较关注新技术,喜欢紧跟技术潮流,在软件工程的各个流程都做的很好,但是代码方面都是依靠个人保证.<br>&emsp;而且在实习阶段中,我也越发的感觉与公司其他员工的交流和沟通特别重要,不管是日常事务还是工作事务.你需要融入公司的这个大家庭里去啊.</p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/杂记/">杂记</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/RxJava/">RxJava</a><a href="/tags/实习/">实习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/10/17/生活学习记录一-RxJava-实习感悟/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/10/17/生活学习记录一-RxJava-实习感悟/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/07/Gson源码分析二/" title="Gson源码分析二" itemprop="url">Gson源码分析二</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-10-07T07:48:51.000Z" itemprop="datePublished"> Published 2015-10-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;承接上一篇博文<a href="http://blog.csdn.net/u012422440/article/details/48860893" target="_blank" rel="external">Gson源码分析</a>，这篇博文主要总结一下Gson中涉及Java反射逻辑的部分。</p>
<h4 id="一个Gson例子"><a href="#一个Gson例子" class="headerlink" title="一个Gson例子"></a>一个Gson例子</h4><p>&emsp;Gson可以解析用户自定义的对象，当然你也可以使用<code>public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter)</code>来完全按照自己的方式来解析，但是Gson其实已经为解析自定义类型对象做了适配，除非特殊需求，我们一般不需要定义自己的TypeAdapter。比如下边这个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyType&#123;</span><br><span class="line">    private int i = 1;</span><br><span class="line">    private String name = &quot;test&quot;;</span><br><span class="line"></span><br><span class="line">    public MyType() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    public MyType(int id,String name) &#123;</span><br><span class="line">        this();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"> MyType type = new MyType();</span><br><span class="line"> System.out.println(gson.toJson(type));</span><br></pre></td></tr></table></figure></p>
<p>&emsp;这样就可以将MyType对象与JSON格式字符串进行相互转换了，不得不说这是十分方便的。而且通过<code>Excluder</code>和<code>FieldNamingStragety</code>我们还可以对Gson的转换过程进行一定的控制。<br>&emsp;更为厉害的是，Gson对相对泛型和复杂的对象支持的很好，比如<code>ArrayList&lt;MyType&gt;</code>对象，也可以直接通过Gson进行转换。</p>
<h3 id="Gson反射基础"><a href="#Gson反射基础" class="headerlink" title="Gson反射基础"></a>Gson反射基础</h3><p>&emsp;这一部分主要讲解一下Java相关的反射基础和Gson对其进行的扩展。<br>&emsp;我们都知道Java泛型是类型擦除的，也就是说在运行期间，我们无法通过反射获得泛型对象的类型，那Gson是如何解析类似于<code>ArrayList&lt;MyType&gt;</code>这样的对象的类型的呢？<br>&emsp;上篇博文中讲到了Gson中使用TypeToken来代表对象的类型，其创建时会使用到<code>$Gson$Types</code>这个对象，我们现在就来好好研究一下这个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static Type canonicalize(Type type) &#123;</span><br><span class="line">    if (type instanceof Class) &#123;  //如果就是Class</span><br><span class="line">      Class&lt;?&gt; c = (Class&lt;?&gt;) type;</span><br><span class="line">        // c.getComponetType()就是返回数组对象的类型比如</span><br><span class="line">      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;</span><br><span class="line">      // ????!!!! loop for ever ????</span><br><span class="line">    &#125; else if (type instanceof ParameterizedType) &#123;  //多级泛型 HashMap&lt;K,T&gt;</span><br><span class="line">      ParameterizedType p = (ParameterizedType) type;</span><br><span class="line">      return new ParameterizedTypeImpl(p.getOwnerType(),</span><br><span class="line">          p.getRawType(), p.getActualTypeArguments());</span><br><span class="line">    &#125; else if (type instanceof GenericArrayType) &#123;   //数组泛型</span><br><span class="line">      GenericArrayType g = (GenericArrayType) type;</span><br><span class="line">      return new GenericArrayTypeImpl(g.getGenericComponentType());</span><br><span class="line">    &#125; else if (type instanceof WildcardType) &#123;   // includes ?  , ? extends Number , ? super T</span><br><span class="line">      WildcardType w = (WildcardType) type;</span><br><span class="line">      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // type is either serializable as-is or unsupported</span><br><span class="line">      return type;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;这里的<code>ParameterizedType</code>,<code>GenericArrayType</code>,<code>WildcardType</code>还有之后会出现的<code>TypeVariable</code>是一个重点啊，他们都是<code>Type</code>的子接口，代表所有类型的公共高阶接口。详细的解释在这里有<a href="http://blog.csdn.net/u012422440/article/details/48948921" target="_blank" rel="external">转载博文</a><br>&emsp;还需要进一步的实验啊，以后再来补充这一部分。还有关于如何处理泛型类型擦除的逻辑。</p>
<p>###ReflectiveTypeAdapterFacotry<br>&emsp;在上边博文中我们说过，Gson会使用<code>TypeToken</code>来代表转换对象的类型，然后找到对应类型的<code>TypeAdapter</code>，但是对于用户自定义的类型，Gson是如何处理的呢？<br>&emsp;Gson的<code>TypeAdapters</code>中有一个可以处理自定义类型的<code>TypeAdapterFactory</code>，它就是<code>ReflectiveTypeAdapterFactory</code>,它也是这篇博文的重点内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final ConstructorConstructor constructorConstructor; //构造函数</span><br><span class="line"> private final FieldNamingStrategy fieldNamingPolicy; //命名规则</span><br><span class="line"> private final Excluder excluder; //排除器</span><br></pre></td></tr></table></figure></p>
<p>&emsp;上述是其成员变量，文章开头所说的用户控制Gson的转换过程就是通过这三个对象实现的，我接下来会一一讲解。<br>&emsp;我们知道在Gson中通过<code>TypeToken</code>获得相应的<code>TypeAdapter</code>的逻辑如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (TypeAdapterFactory factory : factories) &#123;</span><br><span class="line">       TypeAdapter&lt;T&gt; candidate = factory.create(this, type);</span><br><span class="line">         System.out.print(&quot;1 &quot;);</span><br><span class="line">       if (candidate != null) &#123;</span><br><span class="line">           System.out.println(candidate.toString()+type.toString());</span><br><span class="line">         call.setDelegate(candidate);</span><br><span class="line">         typeTokenCache.put(type, candidate);</span><br><span class="line">         return candidate;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;可以看出只要对应的facotry的create返回的对象不为null，就认为找到了对应的factory了，那我们在来看一下<code>ReflectiveTypeAdapterFactory</code>的create函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, final TypeToken&lt;T&gt; type) &#123;</span><br><span class="line">    Class&lt;? super T&gt; raw = type.getRawType();</span><br><span class="line">    if (!Object.class.isAssignableFrom(raw)) &#123;  </span><br><span class="line">    //如果Object都不是raw的最高类型,表示raw不是Object的子类啦 </span><br><span class="line">	 return null; // it&apos;s a primitive!</span><br><span class="line">    &#125;</span><br><span class="line">    ObjectConstructor&lt;T&gt; constructor = constructorConstructor.get(type);</span><br><span class="line">    return new Adapter&lt;T&gt;(constructor, getBoundFields(gson, type, raw));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;ObjectConstrutor<t>是为了构造器，为了创建一个相应的对象，主要是fromJson时使用的,而getBoundFields是为了获得对象的Filed类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  final InstanceCreator&lt;T&gt; typeCreator = (InstanceCreator&lt;T&gt;) instanceCreators.get(type); //no-args和type一一对应啊</span><br><span class="line">  if (typeCreator != null) &#123;</span><br><span class="line">    return new ObjectConstructor&lt;T&gt;() &#123;  //这就是最基础的Constructor啊</span><br><span class="line">      public T construct() &#123;</span><br><span class="line">        return typeCreator.createInstance(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Next try raw type match for instance creators</span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;) // types must agree</span><br><span class="line">  final InstanceCreator&lt;T&gt; rawTypeCreator =</span><br><span class="line">      (InstanceCreator&lt;T&gt;) instanceCreators.get(rawType);</span><br><span class="line">  if (rawTypeCreator != null) &#123;</span><br><span class="line">    return new ObjectConstructor&lt;T&gt;() &#123;</span><br><span class="line">      public T construct() &#123;</span><br><span class="line">        return rawTypeCreator.createInstance(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ObjectConstructor&lt;T&gt; defaultConstructor = newDefaultConstructor(rawType); //默认的构造函数</span><br><span class="line">  if (defaultConstructor != null) &#123;</span><br><span class="line">    return defaultConstructor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ObjectConstructor&lt;T&gt; defaultImplementation = newDefaultImplementationConstructor(type, rawType);</span><br><span class="line">  if (defaultImplementation != null) &#123;</span><br><span class="line">    return defaultImplementation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // finally try unsafe</span><br><span class="line">  return newUnsafeAllocator(type, rawType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>&emsp;这段代码就是为了获得对应类型的构造器对象，在<code>newDefaultConstructor</code>会使用反射<code>getDeclaredConstructor</code>来获得默认的构造器。然后我在来看一下<code>getBoundFields</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//获得成员变量吧</span><br><span class="line"> private Map&lt;String, BoundField&gt; getBoundFields(Gson context, TypeToken&lt;?&gt; type, Class&lt;?&gt; raw) &#123;</span><br><span class="line">   Map&lt;String, BoundField&gt; result = new LinkedHashMap&lt;String, BoundField&gt;();</span><br><span class="line">   if (raw.isInterface()) &#123; //interface没有field啦</span><br><span class="line">     return result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Type declaredType = type.getType();</span><br><span class="line">   while (raw != Object.class) &#123; //从当前类型一直遍历到最高类型，把所有的对象的成员遍历都收集到</span><br><span class="line">     Field[] fields = raw.getDeclaredFields();</span><br><span class="line">     for (Field field : fields) &#123;  //遍历所有的field</span><br><span class="line">       boolean serialize = excludeField(field, true);//是否需要序列化，就是是否需要转换成Json</span><br><span class="line">       boolean deserialize = excludeField(field, false);//是否需要从Json中转换过来</span><br><span class="line">       if (!serialize &amp;&amp; !deserialize) &#123;</span><br><span class="line">         continue;</span><br><span class="line">       &#125;</span><br><span class="line">       field.setAccessible(true);</span><br><span class="line">         //获得Field的type</span><br><span class="line">       Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());//获得Field的Type</span><br><span class="line">       BoundField boundField = createBoundField(context, field, getFieldName(field),</span><br><span class="line">           TypeToken.get(fieldType), serialize, deserialize); //之后详细解释</span><br><span class="line">       BoundField previous = result.put(boundField.name, boundField);</span><br><span class="line">       if (previous != null) &#123;</span><br><span class="line">         throw new IllegalArgumentException(declaredType</span><br><span class="line">             + &quot; declares multiple JSON fields named &quot; + previous.name);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));</span><br><span class="line">     raw = type.getRawType();</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br><span class="line">  static abstract class BoundField &#123;</span><br><span class="line">   final String name;</span><br><span class="line">   final boolean serialized;</span><br><span class="line">   final boolean deserialized;</span><br><span class="line"></span><br><span class="line">   protected BoundField(String name, boolean serialized, boolean deserialized) &#123;</span><br><span class="line">     this.name = name;</span><br><span class="line">     this.serialized = serialized;</span><br><span class="line">     this.deserialized = deserialized;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;其实这一段代码逻辑很简单，主要就是遍历所有的成员遍历，大家可以看我的注释，其中涉及<code>Type</code>的操作我还没有搞懂….,但是<code>createBoundField</code>也是很重要的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private ReflectiveTypeAdapterFactory.BoundField createBoundField(</span><br><span class="line">      final Gson context, final Field field, final String name,</span><br><span class="line">      final TypeToken&lt;?&gt; fieldType, boolean serialize, boolean deserialize) &#123;</span><br><span class="line">    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());</span><br><span class="line">    // special casing primitives here saves ~5% on Android...</span><br><span class="line">    //其实就是创建一个BoundField的子类</span><br><span class="line">    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) &#123;</span><br><span class="line">      final TypeAdapter&lt;?&gt; typeAdapter = getFieldAdapter(context, field, fieldType);//获得子类的TypeAdapter&lt;?&gt;这是解析自定义类型对象的关键一步</span><br><span class="line">      @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;) // the type adapter and field type always agree</span><br><span class="line">      @Override void write(JsonWriter writer, Object value)</span><br><span class="line">          throws IOException, IllegalAccessException &#123;</span><br><span class="line">        Object fieldValue = field.get(value);</span><br><span class="line">        TypeAdapter t =</span><br><span class="line">          new TypeAdapterRuntimeTypeWrapper(context, this.typeAdapter, fieldType.getType());</span><br><span class="line">        t.write(writer, fieldValue); //使用TypeAdapter进行写入</span><br><span class="line">      &#125;</span><br><span class="line">      @Override void read(JsonReader reader, Object value)</span><br><span class="line">          throws IOException, IllegalAccessException &#123;</span><br><span class="line">        Object fieldValue = typeAdapter.read(reader);</span><br><span class="line">        if (fieldValue != null || !isPrimitive) &#123;</span><br><span class="line">          field.set(value, fieldValue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      public boolean writeField(Object value) throws IOException, IllegalAccessException &#123;</span><br><span class="line">        if (!serialized) return false;</span><br><span class="line">        Object fieldValue = field.get(value);</span><br><span class="line">        return fieldValue != value; // avoid recursion for example for Throwable.cause</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;接下来我们就来看一下对应的TypeAdapter <code>private Adapter(ObjectConstructor&lt;T&gt; constructor, Map&lt;String, BoundField&gt; boundFields)</code>，主要看其read和write方法。其中两个方法最后其实都是调用了BoundField的read和write方法，我们就只看read方法啦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override public T read(JsonReader in) throws IOException &#123;</span><br><span class="line">     if (in.peek() == JsonToken.NULL) &#123;</span><br><span class="line">       in.nextNull();</span><br><span class="line">       return null;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     T instance = constructor.construct(); //新建对象</span><br><span class="line"></span><br><span class="line">     try &#123;</span><br><span class="line">       in.beginObject();//读出一个&#123;</span><br><span class="line">       while (in.hasNext()) &#123;</span><br><span class="line">         String name = in.nextName();//获得一个属性的name</span><br><span class="line">         BoundField field = boundFields.get(name);//获得Field对象</span><br><span class="line">         if (field == null || !field.deserialized) &#123;//如果为null或者不需要解序列化</span><br><span class="line">           in.skipValue();</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">           field.read(in, instance);//使用BoundField进行write，可以参考createBoundField</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; catch (IllegalStateException e) &#123;</span><br><span class="line">       throw new JsonSyntaxException(e);</span><br><span class="line">     &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">       throw new AssertionError(e);</span><br><span class="line">     &#125;</span><br><span class="line">     in.endObject();</span><br><span class="line">     return instance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;这样对已自定义对象就可以自由的和JSON格式进行相互转换啦。但是有些同学可能会问了<code>ArrayList&lt;MyType&gt;</code>是如何转换的呢？那我们就要研究<code>CollectionTypeAdapterFactory</code>了，如果你去internal/bind文件夹下查看，你会发现很多类似的类。下边就贴出来其create函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; typeToken) &#123;</span><br><span class="line">   Type type = typeToken.getType();</span><br><span class="line"></span><br><span class="line">   Class&lt;? super T&gt; rawType = typeToken.getRawType();</span><br><span class="line">   if (!Collection.class.isAssignableFrom(rawType))//看是否是Collection的子类 &#123;</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Type elementType = $Gson$Types.getCollectionElementType(type, rawType);//获得element的Type就是List&lt;T&gt;的T的类型，同学们可能会疑问泛型不是类型擦除了吗？你可以阅读一下$Gson$Types中的代码，自行了解一下，我暂时还没有完全搞懂</span><br><span class="line">   //之后就和ReflectiveTypeAdapterFactory的逻辑类似啦</span><br><span class="line">   TypeAdapter&lt;?&gt; elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));</span><br><span class="line">   ObjectConstructor&lt;T&gt; constructor = constructorConstructor.get(typeToken);</span><br><span class="line"></span><br><span class="line">   @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;) // create() doesn&apos;t define a type parameter</span><br><span class="line">   TypeAdapter&lt;T&gt; result = new Adapter(gson, elementType, elementTypeAdapter, constructor);</span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;感觉关于<code>TypeToken</code>和<code>$Gson$Type</code>还是没有完全明白，所以并没有过多涉及，大家如果发现神马问题，或者有好的建议，欢迎大家批判和指教。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/第三方库/">第三方库</a><a href="/tags/反射/">反射</a><a href="/tags/JSON/">JSON</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/10/07/Gson源码分析二/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/10/07/Gson源码分析二/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/02/Gson源码分析/" title="Gson源码分析" itemprop="url">Gson源码分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-10-02T08:24:34.000Z" itemprop="datePublished"> Published 2015-10-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;最近研究了google开源的Json库Gson，在这里进行总结一下，应该会分为3篇博客。第一篇主要讲一下Gson的整个框架吧；第二篇主要总结一下Gson关于反射的部分;最后一篇会总结一下JsonWriter和JsonReader，主要是Json对象的处理啦。</p>
<h3 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h3><p>&emsp;Gson是可以转换Java对象为JSON表示的java库，也可以将JSON转换为Java对象，并且可以转换你没有源代码的预设的复杂对象<br>&emsp;现在有一些JSON转换库，但是大多数都需要你在class中设置annotation；如果没有class的源代码你就无法实现转换，而且大多数无法支持全部的Java范型。Gson把实现上述作为设计的主要目标。<br>&emsp;Gson的目标</p>
<ul>
<li>提供简单的toJson(),和fromJson来实现Java对象和JSON数据的相互转换</li>
<li>运行预先存在的无法修改的对象与Json的转换</li>
<li>支持Java范型</li>
<li>运行用户自定义对象的结构</li>
<li>支持复杂对象的处理</li>
</ul>
<h3 id="框架描述"><a href="#框架描述" class="headerlink" title="框架描述"></a>框架描述</h3><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/gson_GsonUML.jpg" alt="框架类图"><br> &emsp;这是Gson库的类图，没有将所有类都表现上去，只是画了几个比较主要的类和我研究过的类。这篇文章就主要梳理一下这个框架，研究一下几个比较主要的函数的流程和各个对象的协作。</p>
<h4 id="1-GsonBuilder"><a href="#1-GsonBuilder" class="headerlink" title="1.GsonBuilder"></a>1.GsonBuilder</h4><p> &emsp;GsonBuilder是Gson对象的Builder类啦，我们可以先看一下Gson对象的构造函数的复杂度啦,所以如果希望配置Gson,就只有使用Builder模式啦，这也是Java设计模式中所推荐的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,</span><br><span class="line">      final Map&lt;Type, InstanceCreator&lt;?&gt;&gt; instanceCreators, boolean serializeNulls,</span><br><span class="line">      boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,</span><br><span class="line">      boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,</span><br><span class="line">      LongSerializationPolicy longSerializationPolicy,</span><br><span class="line">      List&lt;TypeAdapterFactory&gt; typeAdapterFactories)</span><br></pre></td></tr></table></figure></p>
<p>&emsp; GsonBuilder文件中的注释也有说明：</p>
<blockquote>
<p>使用这个对象去配置你的Gson对象，当你希望修改默认配置时</p>
</blockquote>
<p>&emsp;我们现在可以依次介绍一下GsonBuilder的成员变量或者说是其所依赖的类型吧。</p>
<ul>
<li><p><code>Exculder</code> 是用来配置一些你不希望被转换成JSON格式的对象的成员变量的，比如你只希望自己的对象中所有public的成员变量被转换为JSON格式，那么就需要使用到这个对象，添加规则去除去所有非pulbic的成员变量。</p>
</li>
<li><p><code>LongSerializationPolicy</code>  </p>
</li>
<li><p><code>FieldNamingStragety</code></p>
</li>
<li><p><code>InstanceCreator</code> </p>
</li>
<li><p><code>TypeAdapterFactory</code></p>
</li>
</ul>
<h4 id="2-Gson"><a href="#2-Gson" class="headerlink" title="2.Gson"></a>2.Gson</h4><p>&emsp;Gson对象就是我们最常使用的对象啦，它有一系列的fromJson,toJson的成员函数供我们调用，这篇文章的一个重点就是梳理同这两类函数的逻辑。<br>&emsp;我们先来看一下Gson的构造函数吧。构造函数名和参数列表在前边已经列出来啦，构造函数中就是将参数列表中的对象配置为成员变量，不过要注意的是对TypeAdapterFactory的操作啦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">....</span><br><span class="line">   List&lt;TypeAdapterFactory&gt; factories = new ArrayList&lt;TypeAdapterFactory&gt;();</span><br><span class="line"></span><br><span class="line">   // built-in type adapters that cannot be overridden</span><br><span class="line">   factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);</span><br><span class="line">   factories.add(ObjectTypeAdapter.FACTORY);</span><br><span class="line">   ..... //还有很多基本的TypeAdapterFactory</span><br><span class="line">   // the excluder must precede all adapters that handle user-defined types</span><br><span class="line">   factories.add(excluder);</span><br><span class="line"></span><br><span class="line">   // user&apos;s type adapters</span><br><span class="line">   factories.addAll(typeAdapterFactories);</span><br><span class="line"></span><br><span class="line">   // type adapters for basic platform types</span><br><span class="line">   factories.add(TypeAdapters.STRING_FACTORY); //里边是一些基本类型的adapter啦</span><br><span class="line">      ......</span><br><span class="line">   this.factories = Collections.unmodifiableList(factories);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;Gson内置了很多基本类型和对象的转换组件，类型为<code>TypeAdapter</code>,可以通过相应的<code>TypeAdapterFactory</code>来获得，所以这里<code>factories</code>就预先加载了很多基本类型转换组件的Factory,然后<code>factories.addAll(typeAdapterFactories)</code>是添加构造函数中传入的用户自定义的<code>TypeAdapterFactory</code><br> &emsp;<code>fromJson</code>和<code>toJson</code>这两类函数我们在介绍完所有的类之后在解析吧。</p>
<h4 id="3-TypeAdapter"><a href="#3-TypeAdapter" class="headerlink" title="3.TypeAdapter"></a>3.TypeAdapter</h4><p>&emsp;这是一个抽象类，提供了两个抽象函数作为hook函数来让用户重载，分别是<code>public abstract void write(JsonWriter out, T value) throws IOException;</code>和<code>public abstract T read(JsonReader in) throws IOException;</code>一读一写，用户如果要解析自己自定义的对象，就可以继承这个类，然后实现上述两个方法，并在<code>GsonBuilder中使用</code>GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) <code>来注册这个转换类，然后Gson就可以对你的自定义对象进行转换啦。需要注意的是，这里的转换完全由你自己控制，所以可定制性比较强。在介绍</code>TypeAdapters`时，我们会介绍几个简单的TypeAdapter的实现。</p>
<h4 id="4-TypeAdapterFactory"><a href="#4-TypeAdapterFactory" class="headerlink" title="4.TypeAdapterFactory"></a>4.TypeAdapterFactory</h4><p>&emsp;这是一个接口，自定义了一个函数:<code>&lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; type);</code>,具体的实现方法，我们可以在后边的<code>TypeAdapters</code>类中看到.</p>
<h4 id="5-TypeAdapters"><a href="#5-TypeAdapters" class="headerlink" title="5.TypeAdapters"></a>5.TypeAdapters</h4><p>&emsp;这个类中定义了几乎所有的基础类型的TypeAdapter和Factory,我们现在挑出一个来研究一下。这是一个URL对象的JSON转换器啦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static final TypeAdapter&lt;URL&gt; URL = new TypeAdapter&lt;URL&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public URL read(JsonReader in) throws IOException &#123;</span><br><span class="line">      if (in.peek() == JsonToken.NULL) &#123;</span><br><span class="line">        in.nextNull();</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      String nextString = in.nextString(); //读出in中的内容</span><br><span class="line">      return &quot;null&quot;.equals(nextString) ? null : new URL(nextString);//根据读出的内容，创建URL对象</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void write(JsonWriter out, URL value) throws IOException &#123;</span><br><span class="line">      out.value(value == null ? null : value.toExternalForm()); //写入内容</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);//创建Facotry啦</span><br></pre></td></tr></table></figure></p>
<p> &emsp; 我们可以看到，这是一个URL的转换器，<code>JsonReader</code>和<code>JsonWriter</code>后边会介绍到，现在你就可以把他们当做类似于StringBuilder一类的Json的生成器和解释器。</p>
<h4 id="6-TypeToken"><a href="#6-TypeToken" class="headerlink" title="6.TypeToken"></a>6.TypeToken</h4><p>&emsp;TypeToken可以看做是对Java范型的扩展，大家都知道Java范型是有类型擦除效果的，无法获得其真实类型。而这个类就是为了处理这种情况的，我们从文件中的注释也可以了解到。具体的内容，我们希望在Gson相关的第二篇博文中再详细说明，主要就是涉及围绕TypeToken的一系列的Gson对范型的支持和处理。<br>&emsp;而在Gson对象中，TypeToken主要是用于根据Type来获得相应的TypeAdapter。</p>
<h4 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h4><p>&emsp;还有很多其他的类没有介绍，其中有些不太重要，我也没有太多了解，另外一些我会在接下去的两篇博文中详细介绍。</p>
<h3 id="转换流程"><a href="#转换流程" class="headerlink" title="转换流程"></a>转换流程</h3><p>&emsp;接下来，我们就主要理通Gson两个最重要的函数的逻辑，之后的两篇博文会详细介绍其中的重要的细节，这篇博文就只诉说每一步大致的作用啦。</p>
<h4 id="1-fromJson"><a href="#1-fromJson" class="headerlink" title="1 fromJson()"></a>1 fromJson()</h4><p>&emsp;函数名为fromJson的函数比较多，我们只看下边这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line"> public &lt;T&gt; T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException &#123;</span><br><span class="line">   boolean isEmpty = true;</span><br><span class="line">   boolean oldLenient = reader.isLenient();</span><br><span class="line">   reader.setLenient(true);</span><br><span class="line">   try &#123;</span><br><span class="line">     reader.peek();</span><br><span class="line">     isEmpty = false;</span><br><span class="line">     // 反射部分的精髓,主要的就是TypeToken和TypeAdapter啦</span><br><span class="line">     TypeToken&lt;T&gt; typeToken = (TypeToken&lt;T&gt;) TypeToken.get(typeOfT);  //1:工厂方法,其中调用typeToken的构造器</span><br><span class="line">     TypeAdapter&lt;T&gt; typeAdapter = getAdapter(typeToken); //2:通过type来获得Adapter啊</span><br><span class="line">     T object = typeAdapter.read(reader);//3:通过typeAdapter来转换对象</span><br><span class="line">     return object;</span><br><span class="line">   &#125; catch (EOFException e) &#123;</span><br><span class="line">     /*</span><br><span class="line">      * For compatibility with JSON 1.5 and earlier, we return null for empty</span><br><span class="line">      * documents instead of throwing.</span><br><span class="line">      */</span><br><span class="line">     if (isEmpty) &#123;</span><br><span class="line">       return null;</span><br><span class="line">     &#125;</span><br><span class="line">     throw new JsonSyntaxException(e);</span><br><span class="line">   &#125; catch (IllegalStateException e) &#123;</span><br><span class="line">     throw new JsonSyntaxException(e);</span><br><span class="line">   &#125; catch (IOException e) &#123;</span><br><span class="line">     // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException</span><br><span class="line">     throw new JsonSyntaxException(e);</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     reader.setLenient(oldLenient);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;如同代码中标注的一样，<code>fromJson</code>中大致分为3个比较重要的步奏.</p>
<ul>
<li><p>TypeToken<t> typeToken = (TypeToken<t>) TypeToken.get(typeOfT); 获得要转换类型对应的TypeToken对象，主要涉及的Gson中范型和反射的部分逻辑，我们第二篇博文再讲</t></t></p>
</li>
<li><p>TypeAdapter<t> typeAdapter = getAdapter(typeToken); //通过type来获得Adapter啊,这个我们先来看一下getAdapter函数,就是找出TypeToken所对应的TypeAdapter对象，用于下一步的解析。</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  public &lt;T&gt; TypeAdapter&lt;T&gt; getAdapter(TypeToken&lt;T&gt; type) &#123;</span><br><span class="line">    TypeAdapter&lt;?&gt; cached = typeTokenCache.get(type);  // typeTokenCache?? 创造adapter是很麻烦的事情吗？有cache</span><br><span class="line">    if (cached != null) &#123;</span><br><span class="line">      return (TypeAdapter&lt;T&gt;) cached;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;TypeToken&lt;?&gt;, FutureTypeAdapter&lt;?&gt;&gt; threadCalls = calls.get();  //threadLocal get</span><br><span class="line">    boolean requiresThreadLocalCleanup = false; //是否需要清理threadLocal中的数据</span><br><span class="line">    if (threadCalls == null) &#123;</span><br><span class="line">      threadCalls = new HashMap&lt;TypeToken&lt;?&gt;, FutureTypeAdapter&lt;?&gt;&gt;();</span><br><span class="line">      calls.set(threadCalls);</span><br><span class="line">      requiresThreadLocalCleanup = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // the key and value type parameters always agree</span><br><span class="line">    FutureTypeAdapter&lt;T&gt; ongoingCall = (FutureTypeAdapter&lt;T&gt;) threadCalls.get(type);</span><br><span class="line">    if (ongoingCall != null) &#123;</span><br><span class="line">      return ongoingCall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      FutureTypeAdapter&lt;T&gt; call = new FutureTypeAdapter&lt;T&gt;();</span><br><span class="line">      threadCalls.put(type, call);</span><br><span class="line"></span><br><span class="line">      for (TypeAdapterFactory factory : factories) &#123;</span><br><span class="line">        TypeAdapter&lt;T&gt; candidate = factory.create(this, type);  // 通过factory 来创建TypeAdapter啊，由于需要遍历list比较麻烦</span><br><span class="line">        if (candidate != null) &#123;</span><br><span class="line">          call.setDelegate(candidate);</span><br><span class="line">          typeTokenCache.put(type, candidate);</span><br><span class="line">          return candidate;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     ....</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      threadCalls.remove(type);</span><br><span class="line">	  ....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>T object = typeAdapter.read(reader);//3:通过typeAdapter来转换对象,具体过程，和JsonReader，JsonWriter的原理，第三篇博文再进行讲述<h4 id="2-toJson"><a href="#2-toJson" class="headerlink" title="2 toJson"></a>2 toJson</h4>&emsp;其实toJson和fromJson很像，就是获得相应的TypeAdapter,只不过这次调用的是write方法。这里就不累赘多说啦。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>&emsp;博客还未写完，代码还没有看透…..</li>
</ul>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/GSON/">GSON</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/10/02/Gson源码分析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/10/02/Gson源码分析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/09/27/Android-Async-Http-源码解析/" title="Android-Async-Http 源码解析" itemprop="url">Android-Async-Http 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-09-27T06:37:49.000Z" itemprop="datePublished"> Published 2015-09-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;前几天去参加一个面试，被问到了一些android 网络方面的知识，发现自己在这个方面还有些不足，需要自我补充一下相关的知识，于是最近找了些开源的网络模块的第三方库来阅读，主要是想深入了解一下http协议和相关的代码框架组织问题。这篇博客就总结一下自己阅读android-async-http的一些体会和学习吧。</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>&emsp;介绍android async http 的相关事项，主要是翻译github上的话吧<br>&emsp;这段是官网翻译，大家请随意跳过,详细介绍请转到[<a href="http://loopj.com/android-async-http/" target="_blank" rel="external">http://loopj.com/android-async-http/</a>]<br>&emsp;android-async-http是建立在Apache HttpClient之上的基于回调的异步android http client，它使用Handler机制，请求在UI线程之外发生，但是回调逻辑在UI线程中进行执行</p>
<blockquote>
<p><strong>特点</strong>(部分)：</p>
<ul>
<li>执行异步request，在匿名回调中处理response</li>
<li>Http 请求 发生在UI线程之外</li>
<li>使用ThreadPool来负载多线程消耗</li>
<li>GET/POST params 生成器</li>
<li>支持文件断点续传</li>
<li>支持自动重试</li>
<li>支持流式Json数据上传</li>
<li>可以处理重定向和请求循环</li>
<li>自动的gzip压缩</li>
<li>支持cookie</li>
<li>可以通过BaseJsonResponseHandler和Jackson Json , Gson 和其他Json第三方库进行集成</li>
</ul>
</blockquote>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AsyncHttpClient client = new AsyncHttpClient();</span><br><span class="line"></span><br><span class="line">client.get(&quot;https://www.google.com&quot;, new       AsyncHttpResponseHandler() &#123;   </span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">        // 请求开始发生的回调    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) &#123;</span><br><span class="line">        // 成功获得response的回调</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable</span><br><span class="line">error)</span><br><span class="line">&#123;</span><br><span class="line">        // 失败的回调 :(</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onRetry(int retryNo) &#123;</span><br><span class="line">        // 请求被重试时的回调</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onProgress(long bytesWritten, long totalSize) &#123;</span><br><span class="line">        // 请求发生过程中的回调</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onFinish() &#123;</span><br><span class="line">        // 完成请求时的对调，未知成功还是失败</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/async_http_绘图1.jpg" alt="主要类类图"><br>&emsp;上图就是android-async-http的主要类的类图，我们下面就来一个一个类解析一下</p>
<h6 id="AsyncHttpClient"><a href="#AsyncHttpClient" class="headerlink" title="AsyncHttpClient"></a>AsyncHttpClient</h6><p>&emsp;先看AsyncHttpClient,它是这个http库的核心类之一，封装了发生http请求的所有逻辑，可以说它是这个库的中心类。它的构造函数如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">  public AsyncHttpClient(SchemeRegistry schemeRegistry) &#123;</span><br><span class="line">    // http param</span><br><span class="line">    BasicHttpParams httpParams = new BasicHttpParams();</span><br><span class="line"></span><br><span class="line">    // connect params builder ?????</span><br><span class="line">    ConnManagerParams.setTimeout(httpParams, connectTimeout);</span><br><span class="line">    ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(maxConnections));</span><br><span class="line">    ConnManagerParams.setMaxTotalConnections(httpParams, DEFAULT_MAX_CONNECTIONS);</span><br><span class="line"></span><br><span class="line">    // httpConnectionParams</span><br><span class="line">    HttpConnectionParams.setSoTimeout(httpParams, responseTimeout);</span><br><span class="line">    HttpConnectionParams.setConnectionTimeout(httpParams, connectTimeout);</span><br><span class="line">    HttpConnectionParams.setTcpNoDelay(httpParams, true);</span><br><span class="line">    HttpConnectionParams.setSocketBufferSize(httpParams, DEFAULT_SOCKET_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    HttpProtocolParams.setVersion(httpParams, HttpVersion.HTTP_1_1);</span><br><span class="line"></span><br><span class="line">    ClientConnectionManager cm = createConnectionManager(schemeRegistry, httpParams);</span><br><span class="line">    Utils.asserts(cm != null, &quot;Custom implementation of #createConnectionManager(SchemeRegistry, BasicHttpParams) returned null&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //thread poll</span><br><span class="line">    threadPool = getDefaultThreadPool();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * weakHashMap context:这是不会出现内存泄露</span><br><span class="line">     * synchronizedMap 是建立一个线程安全的map加一个同步锁啊。</span><br><span class="line">     */</span><br><span class="line">    requestMap = Collections.synchronizedMap(new WeakHashMap&lt;Context, List&lt;RequestHandle&gt;&gt;());</span><br><span class="line"></span><br><span class="line">    clientHeaderMap = new HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    httpContext = new SyncBasicHttpContext(new BasicHttpContext());</span><br><span class="line">    // 默认的apache的httpclient</span><br><span class="line">    httpClient = new DefaultHttpClient(cm, httpParams);</span><br><span class="line"></span><br><span class="line">    // 请求拦截器啊</span><br><span class="line">    httpClient.addRequestInterceptor(new HttpRequestInterceptor() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void process(HttpRequest request, HttpContext context) &#123;</span><br><span class="line">            // 预处理,声明浏览器支持的编码类型啊</span><br><span class="line">            if (!request.containsHeader(HEADER_ACCEPT_ENCODING)) &#123; //加上GZIP的头部</span><br><span class="line">                request.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 对于默认的clientHeader进行遍历，比较，添加</span><br><span class="line">            for (String header : clientHeaderMap.keySet()) &#123;</span><br><span class="line">                if (request.containsHeader(header)) &#123;  //如果包含</span><br><span class="line">                    Header overwritten = request.getFirstHeader(header);</span><br><span class="line">                    log.d(LOG_TAG,</span><br><span class="line">                            String.format(&quot;Headers were overwritten! (%s | %s) overwrites (%s | %s)&quot;,</span><br><span class="line">                                    header, clientHeaderMap.get(header),</span><br><span class="line">                                    overwritten.getName(), overwritten.getValue())</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">                    //remove the overwritten header</span><br><span class="line">                    request.removeHeader(overwritten);</span><br><span class="line">                &#125;</span><br><span class="line">                request.addHeader(header, clientHeaderMap.get(header)); //写入clientHeaderMap中的值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // response拦截器,对gzip进行解压缩啊</span><br><span class="line">    httpClient.addResponseInterceptor(new HttpResponseInterceptor() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void process(HttpResponse response, HttpContext context) &#123;</span><br><span class="line">            final HttpEntity entity = response.getEntity(); //</span><br><span class="line">            if (entity == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            final Header encoding = entity.getContentEncoding();</span><br><span class="line">            if (encoding != null) &#123;</span><br><span class="line">                for (HeaderElement element : encoding.getElements()) &#123; //遍历头部信息</span><br><span class="line">                    if (element.getName().equalsIgnoreCase(ENCODING_GZIP)) &#123;</span><br><span class="line">                        response.setEntity(new InflatingEntity(entity)); //InflatingEntity 这是解压gzip的</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 另外一个模块的请求拦截器 ???? 身份认证的</span><br><span class="line">    httpClient.addRequestInterceptor(new HttpRequestInterceptor() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException &#123;</span><br><span class="line">            AuthState authState = (AuthState) context.getAttribute(ClientContext.TARGET_AUTH_STATE);</span><br><span class="line">            CredentialsProvider credsProvider = (CredentialsProvider) context.getAttribute(</span><br><span class="line">                    ClientContext.CREDS_PROVIDER);</span><br><span class="line">            HttpHost targetHost = (HttpHost) context.getAttribute(ExecutionContext.HTTP_TARGET_HOST);</span><br><span class="line"></span><br><span class="line">            if (authState.getAuthScheme() == null) &#123;</span><br><span class="line">                AuthScope authScope = new AuthScope(targetHost.getHostName(), targetHost.getPort());</span><br><span class="line">                Credentials creds = credsProvider.getCredentials(authScope);</span><br><span class="line">                if (creds != null) &#123;</span><br><span class="line">                    authState.setAuthScheme(new BasicScheme());</span><br><span class="line">                    authState.setCredentials(creds);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line"></span><br><span class="line">    // 重试Handler，用于重新发送请求</span><br><span class="line">    httpClient.setHttpRequestRetryHandler(new RetryHandler(DEFAULT_MAX_RETRIES, DEFAULT_RETRY_SLEEP_TIME_MILLIS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;在构造函数中，AsyncHttpClient主要是初始化了threadPool作为发生请求的线程池，httpContext作为发生请求的网络context，还有最为重要的httpClient,它的类型是Apache的DefaultHttpClient，然后设置了设计gzip压缩和身份认证的请求拦截器和回应拦截器，具体逻辑代码中都有注释。<br>&emsp;AsyncHttp中还有一个我认为是整个库精髓所在的函数，如果你理解了这个函数，那么整个库的代码框架和思想其实你就已经知道了。它就是sendRequest(),AsyncHttp的关于网络请求的方法，比如get,post,head，最终都是调用了这个函数。在这个函数中，其他几个比较主要的类都有出现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    *</span><br><span class="line">    * 这是这里的重点啊，创建一个request放在队列中，等待一个thread去执行</span><br><span class="line">    * Puts a new request in queue as a new thread in pool to be executed</span><br><span class="line">    *</span><br><span class="line">    * @param client          HttpClient to be used for request, can differ in single requests</span><br><span class="line">    * @param contentType     MIME body type, for POST and PUT requests, may be null</span><br><span class="line">    * @param context         Context of Android application, to hold the reference of request</span><br><span class="line">    * @param httpContext     HttpContext in which the request will be executed</span><br><span class="line">    * @param responseHandler ResponseHandler or its subclass to put the response into</span><br><span class="line">    * @param uriRequest      instance of HttpUriRequest, which means it must be of HttpDelete,</span><br><span class="line">    *                        HttpPost, HttpGet, HttpPut, etc.</span><br><span class="line">    * @return RequestHandle of future request process</span><br><span class="line">    */</span><br><span class="line">   protected RequestHandle sendRequest(DefaultHttpClient client, HttpContext httpContext, HttpUriRequest uriRequest, String contentType, ResponseHandlerInterface responseHandler, Context context) &#123;</span><br><span class="line">       if (uriRequest == null) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;HttpUriRequest must not be null&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (responseHandler == null) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;ResponseHandler must not be null&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (responseHandler.getUseSynchronousMode() &amp;&amp; !responseHandler.getUsePoolThread()) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;Synchronous ResponseHandler used in AsyncHttpClient. You should create your response handler in a looper thread or use SyncHttpClient instead.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (contentType != null) &#123;</span><br><span class="line">           if (uriRequest instanceof HttpEntityEnclosingRequestBase &amp;&amp; ((HttpEntityEnclosingRequestBase) uriRequest).getEntity() != null &amp;&amp; uriRequest.containsHeader(HEADER_CONTENT_TYPE)) &#123;</span><br><span class="line">               log.w(LOG_TAG, &quot;Passed contentType will be ignored because HttpEntity sets content type&quot;);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               uriRequest.setHeader(HEADER_CONTENT_TYPE, contentType);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       responseHandler.setRequestHeaders(uriRequest.getAllHeaders());</span><br><span class="line">       responseHandler.setRequestURI(uriRequest.getURI());</span><br><span class="line"></span><br><span class="line">       // runnable</span><br><span class="line">       AsyncHttpRequest request = newAsyncHttpRequest(client, httpContext, uriRequest, contentType, responseHandler, context);</span><br><span class="line"></span><br><span class="line">       threadPool.submit(request);</span><br><span class="line"></span><br><span class="line">       // Handler 持有Request的弱引用，可以对其执行操作</span><br><span class="line">       RequestHandle requestHandle = new RequestHandle(request);</span><br><span class="line"></span><br><span class="line">       if (context != null) &#123;  //如果此时context为不为空</span><br><span class="line">           List&lt;RequestHandle&gt; requestList;</span><br><span class="line">           // Add request to request map</span><br><span class="line">           synchronized (requestMap) &#123;  // 需要添加到context作为键的List中去</span><br><span class="line">               requestList = requestMap.get(context);</span><br><span class="line">               if (requestList == null) &#123;</span><br><span class="line">                   requestList = Collections.synchronizedList(new LinkedList&lt;RequestHandle&gt;());</span><br><span class="line">                   requestMap.put(context, requestList);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           requestList.add(requestHandle);</span><br><span class="line"></span><br><span class="line">           // 每次发送请求的时候进行一轮runnable删除</span><br><span class="line">           Iterator&lt;RequestHandle&gt; iterator = requestList.iterator();</span><br><span class="line">           while (iterator.hasNext()) &#123;</span><br><span class="line">               if (iterator.next().shouldBeGarbageCollected()) &#123;</span><br><span class="line">                   iterator.remove();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return requestHandle; //返回句柄啊</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;我们可以看到在函数中</p>
<ul>
<li>使用传入的参数和对象本身的成员变量来构造了一个AsynHttpRequest(本身继承Runnable,之后详细介绍),将其放入threadPool中</li>
<li>然后生成RequestHandler对象来持有这个请求(用户可以通过RequestHandler对请求进行各类操作，比如取消),需要注意的是这个Handler并不是android的Handler，而是供用户操纵Request的句柄类</li>
<li>然后更新requestMap,这是一个android Context作为主键的map，主要是记录各个Context的网络请求，需要注意的是这里使用的是<a href="http://mikewang.blog.51cto.com/3826268/880775/" target="_blank" rel="external">WeakHashMap</a>,防止内存泄露</li>
<li>添加Handler到requestList中，然后遍历requestList删除需要垃圾回收的对象</li>
<li>最后返回requestHandler。</li>
</ul>
<h6 id="AsyncHttpRequest"><a href="#AsyncHttpRequest" class="headerlink" title="AsyncHttpRequest"></a>AsyncHttpRequest</h6><p>&emsp;这个类是Runnable的子类,主要是用来进行发送请求和重试这套逻辑，而且ResponseHandlerInterface中的大多数回调函数都是在此对象中回调的。我们主要看一下它的<code>run()</code>,<code>makeRequest()</code>和 <code>makemakeRequestWithRetries()</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (isCancelled()) &#123;  //如果run的时候是取消状态，那么就关闭了</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Carry out pre-processing for this request only once.</span><br><span class="line">        if (!isRequestPreProcessed) &#123;  //必须进行一次预处理</span><br><span class="line">            isRequestPreProcessed = true;</span><br><span class="line">            onPreProcessRequest(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        responseHandler.sendStartMessage();  // 回调handler，已经开始</span><br><span class="line"></span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 进行带重试的请求</span><br><span class="line">        try &#123;</span><br><span class="line">            makeRequestWithRetries();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            if (!isCancelled()) &#123;</span><br><span class="line">                responseHandler.sendFailureMessage(0, null, null, e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                AsyncHttpClient.log.e(&quot;AsyncHttpRequest&quot;, &quot;makeRequestWithRetries returned error&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        responseHandler.sendFinishMessage();</span><br><span class="line"></span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Carry out post-processing for this request.</span><br><span class="line">        onPostProcessRequest(this);</span><br><span class="line"></span><br><span class="line">        isFinished = true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;可以看出，在run中，根据发送网络请求的不同阶段调用了一系列的回调函数，其中比较重要的是<code>responseHandler.sendFinishMessage()</code>,在这里会回调函数进行解析response；在各个阶段开始前都有调用<code>isCancelled()</code>进行判断是否request被取消了。<br>&emsp;接下来是<code>makeRequest()</code>,在其中就调用了<code>HttpClient.execute(request,context)</code>进行正式的发送请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void makeRequest() throws IOException &#123;</span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Fixes #115</span><br><span class="line">        if (request.getURI().getScheme() == null) &#123;</span><br><span class="line">            // subclass of IOException so processed in the caller</span><br><span class="line">            throw new MalformedURLException(&quot;No valid URI scheme was provided&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (responseHandler instanceof RangeFileAsyncHttpResponseHandler) &#123;</span><br><span class="line">            ((RangeFileAsyncHttpResponseHandler) responseHandler).updateRequestHeaders(request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpResponse response = client.execute(request, context);</span><br><span class="line"></span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Carry out pre-processing for this response.</span><br><span class="line">        responseHandler.onPreProcessResponse(responseHandler, response);</span><br><span class="line"></span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // The response is ready, handle it.</span><br><span class="line">        responseHandler.sendResponseMessage(response);</span><br><span class="line"></span><br><span class="line">        if (isCancelled()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Carry out post-processing for this response.</span><br><span class="line">        responseHandler.onPostProcessResponse(responseHandler, response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="RequestHandler"><a href="#RequestHandler" class="headerlink" title="RequestHandler"></a>RequestHandler</h6><p>&emsp;持有AsyncHttpRequest一个弱引用的句柄类，主要的功能是可以让客户端取消AsyncHttpRequest请求</p>
<h6 id="AsyncHttpResponseHandler"><a href="#AsyncHttpResponseHandler" class="headerlink" title="AsyncHttpResponseHandler"></a>AsyncHttpResponseHandler</h6><p>&emsp;实现ResponseHandlerInterface的一个类，也是我们经常会用到的一个类，在android-async-http中有很多类都实现了ResponseHandlerInterface或者继承了这个类,比如BianryHttpResponseHandler,FileAsyncHttpResponseHandler,每个类都对应不同的网络请求的返回数据资源，有些可能是专门用于文件下载的，有些是解析json的，大家可以自己去了解各个类的作用。<br>&emsp;android-sync-http发送网络请求可以同步也可以异步，而且异步会在相应的thread中进行回调，其中涉及的逻辑就在这些类中。这个类也可以控制发送请求所使用的线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Creates a new AsyncHttpResponseHandler with a user-supplied looper. If</span><br><span class="line">     * the passed looper is null, the looper attached to the current thread will</span><br><span class="line">     * be used.</span><br><span class="line">     *</span><br><span class="line">	 * 如果调用了这个，那么就不是异步，而且是在当前线程中调用了</span><br><span class="line">     * @param looper The looper to work with</span><br><span class="line">     */</span><br><span class="line">    public AsyncHttpResponseHandler(Looper looper) &#123;</span><br><span class="line">        this.looper = looper == null ? Looper.myLooper() : looper;</span><br><span class="line"></span><br><span class="line">        // Use asynchronous mode by default.</span><br><span class="line">        setUseSynchronousMode(false);</span><br><span class="line"></span><br><span class="line">        // Do not use the pool&apos;s thread to fire callbacks by default.</span><br><span class="line">        setUsePoolThread(false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&amp;emsp；大家可以发现构造函数传入了一个Looper,相信对android Handler机制比较了解的同学立即就知道这个库的异步调用是如何在当前线程中进行回调的了吧。这个类实现的回调函数中大多数都是进行<code>sendMessage(obtainMessage(FAILURE_MESSAGE, new Object[]{statusCode, headers, responseBody, throwable}));</code>这样的调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void sendMessage(Message msg) &#123;   // 如果是同步就自己处理，否则交由handler处理</span><br><span class="line">       if (getUseSynchronousMode() || handler == null) &#123;</span><br><span class="line">           handleMessage(msg);</span><br><span class="line">       &#125; else if (!Thread.currentThread().isInterrupted()) &#123; // do not send messages if request has been cancelled</span><br><span class="line">           Utils.asserts(handler != null, &quot;handler should not be null!&quot;);</span><br><span class="line">           handler.sendMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;这就是发生message的函数，发现如果同步模式，那么就调用自己的handleMessage处理，否则交由构造函数中的Looper生成的handler进行处理,其实最终处理的还是这个对象的handlerMessage方法，但是是在另外一个Looper所在的线程中执行的。<br>&amp;emsp；其实这个类中还有两个涉及http response解析的方法也是很重要的，就是<code>sendResponseMesssage(HttpResponse response)</code>和<code>getResponseData(HttpEntity entity)</code>，可是我对http协议不太了解，也害怕说错了，这里就只附上源码吧，上边有我的注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 获得网络请求返回进行处理</span><br><span class="line">    @Override</span><br><span class="line">    public void sendResponseMessage(HttpResponse response) throws IOException &#123;</span><br><span class="line">        // do not process if request has been cancelled</span><br><span class="line">        if (!Thread.currentThread().isInterrupted()) &#123;  //thread isInterrupted means that request is cancelled</span><br><span class="line">            StatusLine status = response.getStatusLine(); // 状态行</span><br><span class="line">            byte[] responseBody; // 回复体</span><br><span class="line">            responseBody = getResponseData(response.getEntity());</span><br><span class="line">            // additional cancellation check as getResponseData() can take non-zero time to process</span><br><span class="line">            if (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                if (status.getStatusCode() &gt;= 300) &#123;</span><br><span class="line">                    sendFailureMessage(status.getStatusCode(), response.getAllHeaders(), responseBody, new HttpResponseException(status.getStatusCode(), status.getReasonPhrase()));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    sendSuccessMessage(status.getStatusCode(), response.getAllHeaders(), responseBody);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns byte array of response HttpEntity contents</span><br><span class="line">	 * 解析http的response</span><br><span class="line">     *</span><br><span class="line">     * @param entity can be null</span><br><span class="line">     * @return response entity body or null</span><br><span class="line">     * @throws java.io.IOException if reading entity or creating byte array failed</span><br><span class="line">     */</span><br><span class="line">    byte[] getResponseData(HttpEntity entity) throws IOException &#123;</span><br><span class="line">        byte[] responseBody = null;</span><br><span class="line">        if (entity != null) &#123;</span><br><span class="line">            InputStream instream = entity.getContent(); // 获得输入流</span><br><span class="line">            if (instream != null) &#123;</span><br><span class="line">                long contentLength = entity.getContentLength(); // 获得size</span><br><span class="line">                if (contentLength &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                    throw new IllegalArgumentException(&quot;HTTP entity too large to be buffered in memory&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                int buffersize = (contentLength &lt;= 0) ? BUFFER_SIZE : (int) contentLength; // contentLength有可能为负数吗</span><br><span class="line">                try &#123;</span><br><span class="line">                    ByteArrayBuffer buffer = new ByteArrayBuffer(buffersize); // byte array的buffer类</span><br><span class="line">                    try &#123;</span><br><span class="line">                        byte[] tmp = new byte[BUFFER_SIZE];</span><br><span class="line">                        long count = 0;</span><br><span class="line">                        int l;</span><br><span class="line">                        // do not send messages if request has been cancelled</span><br><span class="line">                        while ((l = instream.read(tmp)) != -1 &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                            count += l;</span><br><span class="line">                            buffer.append(tmp, 0, l);</span><br><span class="line">                            sendProgressMessage(count, (contentLength &lt;= 0 ? 1 : contentLength));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        AsyncHttpClient.silentCloseInputStream(instream);</span><br><span class="line">                        AsyncHttpClient.endEntityViaReflection(entity);</span><br><span class="line">                    &#125;</span><br><span class="line">                    responseBody = buffer.toByteArray();</span><br><span class="line">                &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">                    System.gc();</span><br><span class="line">                    throw new IOException(&quot;File too large to fit into available memory&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return responseBody;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;android-async-http 算是源代码量最小的一个网络库了，当然它还有些却缺点，比如没有缓存机制，我看github中已经有人给它加上了缓存，大家也可以自己尝试一下，并且更好的是，这个库可以与其他的第三方库进行集成，大家可以打造属于自己的网络请求+处理数据的框架。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/Network/">Network</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/第三方库/">第三方库</a><a href="/tags/Http/">Http</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/09/27/Android-Async-Http-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/09/27/Android-Async-Http-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/3/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android/" title="Android">Android<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android性能/" title="Android性能">Android性能<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/NetWork/" title="NetWork">NetWork<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/Network/" title="Network">Network<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Python/" title="Python">Python<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/c/" title="c">c<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/python/" title="python">python<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/函数式编程/" title="函数式编程">函数式编程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/思考/" title="思考">思考<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/c/数据结构/" title="数据结构">数据结构<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/杂记/" title="杂记">杂记<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/杂记/" title="杂记">杂记<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/源码/" title="源码">源码<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/源码分析/" title="源码分析">源码分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/杂记/生活/" title="生活">生活<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/综合/" title="综合">综合<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/网络/" title="网络">网络<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/源码/视图/" title="视图">视图<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/计划/" title="计划">计划<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/设计/" title="设计">设计<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/读书笔记/" title="读书笔记">读书笔记<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/随笔/" title="随笔">随笔<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/第三方库/" title="第三方库">第三方库<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/注解/" title="注解">注解<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/TCP-IP/" title="TCP/IP">TCP/IP<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Span/" title="Span">Span<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/OkHttp/" title="OkHttp">OkHttp<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/scroll/" title="scroll">scroll<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/事件传递/" title="事件传递">事件传递<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/View/" title="View">View<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/图像处理/" title="图像处理">图像处理<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/工具/" title="工具">工具<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/反射/" title="反射">反射<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/JSON/" title="JSON">JSON<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GSON/" title="GSON">GSON<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Material-Design/" title="Material Design">Material Design<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/MotionEvent/" title="MotionEvent">MotionEvent<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/http/" title="http">http<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/animation/" title="animation">animation<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/React-Native/" title="React Native">React Native<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Cookie/" title="Cookie">Cookie<sup>1</sup></a></li>
			
		
		</ul>
</div>


  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> Hello ,I&#39;m Homer in NJU. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="remCarpediem">remCarpediem</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-88918565-1', 'ztelur.github.io/');
ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?8a8af29a4307eee9d7c7f8e9321aedae";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260989317'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1260989317' type='text/javascript'%3E%3C/script%3E"));</script>




<!-- baidu search 推送-->
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
