<!DOCTYPE html>
<html lang="Ch">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>程序员历小冰</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta property="og:type" content="website">
<meta property="og:title" content="程序员历小冰">
<meta property="og:url" content="http://remcarpediem.net/page/4/index.html">
<meta property="og:site_name" content="程序员历小冰">
<meta property="og:locale" content="Chinese">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员历小冰">
    

    
        <link rel="alternate" href="/atom.xml" title="程序员历小冰" type="application/atom+xml">
    

    
        <link rel="icon" href="/css/images/avatar.jpeg">
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
    
    
    
        
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f089a91a688633df563c08899e3d893e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    


<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">程序员历小冰</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">主页</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/book">读书</a>
                
                    <a class="main-nav-link" href="/categories/plan">计划</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.jpeg">
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">主页</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/book">读书</a></td>
                
                    <td><a class="main-nav-link" href="/categories/plan">计划</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile" class="profile-fixed">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.jpeg">
            <h2 id="name">历小冰</h2>
            <h3 id="title">后端开发工程师</h3>
            <span id="location"><i class="fa fa-map-marker"></i>中国，南京</span>
            <img id="wechat" src="/css/images/wechat_public.jpg">
            <a id="follow" target="_blank" href="/css/images/wechat_public.jpg">⬆关注公众号⬆</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                93
                <span>posts</span>
            </div>
            <div class="article-info-block">
                63
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/ztelur" target="_blank" title="github" class="tooltip">
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/css/images/wechat.jpeg" target="_blank" title="wechat" class="tooltip">
                            <i class="fa fa-wechat"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="/atom.xml" target="_blank" title="rss" class="tooltip">
                            <i class="fa fa-rss"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-Spring-AOP-一-AOP基本概念" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/69e55fe0/">Spring AOP(一) AOP基本概念</a>
        </h1>
    

                
                    <div class="article-meta">
                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/69e55fe0/">
            <time datetime="2019-02-08T11:15:32.000Z" itemprop="datePublished">2019-02-08</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Spring/">Spring</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/AOP/">AOP</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;Spring框架自诞生之日就拯救我等程序员于水火之中，它有两大法宝，一个是IoC控制反转，另一个便是AOP面向切面编程。今日我们就来破一下它的AOP法宝，以便以后也能自由使出一手AOP大法。</p>
<p>&emsp;AOP全名Aspect-oriented programming面向切面编程大法，它有很多兄弟，分别是经常见的面向对象编程，朴素的面向过程编程和神秘的函数式编程等。所谓AOP的具体解释，以及和OOP的区别不清楚的同学可以自行去了解。</p>
<p>&emsp;AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理。本文就主要讲解AOP的基本术语，然后用一个例子让大家彻底搞懂这些名词，最后介绍一下AOP的两种代理方式：</p>
<ul>
<li>以AspectJ为代表的静态代理。</li>
<li>以Spring AOP为代表的动态代理。</li>
</ul>
<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><h4 id="1-切面-Aspect"><a href="#1-切面-Aspect" class="headerlink" title="(1)切面(Aspect)"></a>(1)切面(Aspect)</h4><p>&emsp;切面是一个横切关注点的模块化，一个切面能够包含同一个类型的不同增强方法，比如说事务处理和日志处理可以理解为两个切面。切面由切入点和通知组成，它既包含了横切逻辑的定义，也包括了切入点的定义。 Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">@Component
@Aspect
public class LogAspect {
}
</code></pre>
<p>&emsp;<strong><em>可以简单地认为, 使用 @Aspect 注解的类就是切面</em></strong></p>
<h4 id="2-目标对象-Target"><a href="#2-目标对象-Target" class="headerlink" title="(2) 目标对象(Target)"></a>(2) 目标对象(Target)</h4><p>&emsp;目标对象指将要被增强的对象，即包含主业务逻辑的类对象。或者说是被一个或者多个切面所通知的对象。</p>
<h4 id="3-连接点-JoinPoint"><a href="#3-连接点-JoinPoint" class="headerlink" title="(3) 连接点(JoinPoint)"></a>(3) 连接点(JoinPoint)</h4><p>&emsp;程序执行过程中明确的点，如方法的调用或特定的异常被抛出。连接点由两个信息确定：</p>
<ul>
<li>方法(表示程序执行点，即在哪个目标方法)</li>
<li>相对点(表示方位，即目标方法的什么位置，比如调用前，后等)</li>
</ul>
<p>&emsp;简单来说，连接点就是被拦截到的程序执行点，因为Spring只支持方法类型的连接点，所以在Spring中连接点就是被拦截到的方法。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">@Before(&quot;pointcut()&quot;)
public void log(JoinPoint joinPoint) { &#x2F;&#x2F;这个JoinPoint参数就是连接点
}
</code></pre></p>
<h4 id="4-切入点-PointCut"><a href="#4-切入点-PointCut" class="headerlink" title="(4) 切入点(PointCut)"></a>(4) 切入点(PointCut)</h4><p>&emsp;切入点是对连接点进行拦截的条件定义。切入点表达式如何和连接点匹配是AOP的核心，Spring缺省使用AspectJ切入点语法。<br>&emsp;一般认为，所有的方法都可以认为是连接点，但是我们并不希望在所有的方法上都添加通知，而切入点的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配连接点，给满足规则的连接点添加通知。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">@Pointcut(&quot;execution(* com.remcarpediem.test.aop.service..*(..))&quot;)
public void pointcut() {
}
</code></pre>
<p>&emsp;上边切入点的匹配规则是<code>com.remcarpediem.test.aop.service</code>包下的所有类的所有函数。</p>
<h4 id="5-通知-Advice"><a href="#5-通知-Advice" class="headerlink" title="(5) 通知(Advice)"></a>(5) 通知(Advice)</h4><p>&emsp;通知是指拦截到连接点之后要执行的代码，包括了“around”、“before”和“after”等不同类型的通知。Spring AOP框架以拦截器来实现通知模型，并维护一个以连接点为中心的拦截器链。 </p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; @Before说明这是一个前置通知，log函数中是要前置执行的代码，JoinPoint是连接点，
@Before(&quot;pointcut()&quot;)
public void log(JoinPoint joinPoint) { 
}
</code></pre>
<h4 id="6-织入-Weaving"><a href="#6-织入-Weaving" class="headerlink" title="(6) 织入(Weaving)"></a>(6) 织入(Weaving)</h4><p>&emsp;织入是将切面和业务逻辑对象连接起来, 并创建通知代理的过程。织入可以在编译时，类加载时和运行时完成。在编译时进行织入就是静态代理，而在运行时进行织入则是动态代理。</p>
<h4 id="7-增强器-Adviser"><a href="#7-增强器-Adviser" class="headerlink" title="(7) 增强器(Adviser)"></a>(7) 增强器(Adviser)</h4><p>&emsp;Advisor是切面的另外一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。Advisor由切入点和Advice组成。<br>&emsp;Advisor这个概念来自于Spring对AOP的支撑，在AspectJ中是没有等价的概念的。Advisor就像是一个小的自包含的切面，这个切面只有一个通知。切面自身通过一个Bean表示，并且必须实现一个默认接口。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; AbstractPointcutAdvisor是默认接口
public class LogAdvisor extends AbstractPointcutAdvisor {
    private Advice advice; &#x2F;&#x2F; Advice
    private Pointcut pointcut; &#x2F;&#x2F; 切入点

    @PostConstruct
    public void init() {
        &#x2F;&#x2F; AnnotationMatchingPointcut是依据修饰类和方法的注解进行拦截的切入点。
        this.pointcut = new AnnotationMatchingPointcut((Class) null, Log.class);
        &#x2F;&#x2F; 通知
        this.advice = new LogMethodInterceptor();
    }
}
</code></pre>
<h4 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h4><p>&emsp;看完了上面的理论部分知识, 我相信还是会有不少朋友感觉AOP 的概念还是很模糊, 对 AOP 的术语理解的还不是很透彻。现在我们就找一个具体的案例来说明一下。<br>&emsp;简单来讲，整个 aspect 可以描述为: <strong><em>满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作</em></strong>。我们来看下边这个例子。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">@Component
@Aspect &#x2F;&#x2F; 切面
public class LogAspect {
    private final static Logger LOGGER = LoggerFactory.getLogger(LogAspect.class.getName());
     &#x2F;&#x2F; 切入点，表达式是指com.remcarpediem.test.aop.service
     &#x2F;&#x2F; 包下的所有类的所有方法
    @Pointcut(&quot;execution(* com.remcarpediem.test.aop.service..*(..))&quot;)
    public void aspect() {}
    &#x2F;&#x2F; 通知，在符合aspect切入点的方法前插入如下代码，并且将连接点作为参数传递
    @Before(&quot;aspect()&quot;)
    public void log(JoinPoint joinPoint) { &#x2F;&#x2F;连接点作为参数传入
        if (LOGGER.isInfoEnabled()) {
            &#x2F;&#x2F; 获得类名，方法名，参数和参数名称。
            Signature signature = joinPoint.getSignature();
            String className = joinPoint.getTarget().getClass().getName();
            String methodName = joinPoint.getSignature().getName();
            Object[] arguments = joinPoint.getArgs();
            MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();

            String[] argumentNames = methodSignature.getParameterNames();

            StringBuilder sb = new StringBuilder(className + &quot;.&quot; + methodName + &quot;(&quot;);

            for (int i = 0; i&lt; arguments.length; i++) {
                Object argument = arguments[i];
                sb.append(argumentNames[i] + &quot;-&gt;&quot;);
                sb.append(argument != null ? argument.toString() : &quot;null &quot;);
            }
            sb.append(&quot;)&quot;);

            LOGGER.info(sb.toString());
        }
    }
}
</code></pre></p>
<p>&emsp;上边这段代码是一个简单的日志相关的切面，依次定义了切入点和通知，而连接点作为log的参数传入进来，进行一定的操作，比如说获取连接点函数的名称，参数等。</p>
<h3 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h3><p>&emsp;所谓静态代理就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强。ApsectJ是静态代理的实现之一，也是最为流行的。静态代理由于在编译时就生成了代理类，效率相比动态代理要高一些。AspectJ可以单独使用，也可以和Spring结合使用。</p>
<h3 id="动态代理模式"><a href="#动态代理模式" class="headerlink" title="动态代理模式"></a>动态代理模式</h3><p>&emsp;与静态代理不同，动态代理就是说AOP框架不会去修改编译时生成的字节码，而是在运行时在内存中生成一个AOP代理对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<p>&emsp;Spring AOP中的动态代理主要有两种方式：JDK动态代理和CGLIB动态代理。</p>
<p>&emsp;JDK代理通过反射来处理被代理的类，并且要求被代理类必须实现一个接口。核心类是 InvocationHandler接口 和 Proxy类。<br>&emsp;而当目标类没有实现接口时，Spring AOP框架会使用CGLIB来动态代理目标类。<br>&emsp;CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。核心类是 MethodInterceptor 接口和Enhancer 类</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-c854d59f8fb95c4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两种动态代理的区别"></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;AOP的基础知识都比较枯燥，本人也不擅长概念性的文章，不过下一篇文章就是AOP源码分析了，希望大家可以继续关注。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-7d960275042f309d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>

        
        </div>
        <footer class="article-footer">
            <!-- id 将作为查询条件 -->
            <span id="/article/69e55fe0/" class="leancloud_visitors" data-flag-title="Spring AOP(一) AOP基本概念">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">1000</i>
            </span>
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/69e55fe0/" data-id="ckauf70yq004bwi66o1kxlbnm" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-AbstractQueuedSynchronizer超详细原理解析-1" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/d2edd1b8/">AbstractQueuedSynchronizer超详细原理解析</a>
        </h1>
    

                
                    <div class="article-meta">
                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/d2edd1b8/">
            <time datetime="2019-01-24T12:31:40.000Z" itemprop="datePublished">2019-01-24</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/并发/">并发</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;今天我们来研究学习一下<code>AbstractQueuedSynchronizer</code>类的相关原理，<code>java.util.concurrent</code>包中很多类都依赖于这个类所提供队列式同步器，比如说常用的<code>ReentranLock</code>，<code>Semaphore</code>和<code>CountDownLatch</code>等。<br>&emsp;为了方便理解，我们以一段使用<code>ReentranLock</code>的代码为例，讲解<code>ReentranLock</code>每个方法中有关<code>AQS</code>的使用。</p>
<h3 id="ReentranLock示例"><a href="#ReentranLock示例" class="headerlink" title="ReentranLock示例"></a>ReentranLock示例</h3><p>&emsp;我们都知道<code>ReentranLock</code>的加锁行为和<code>Synchronized</code>类似，都是可重入的锁，但是二者的实现方式确实完全不同的，我们之后也会讲解<code>Synchronized</code>的原理。<strong><em>除此之外，Synchronized的阻塞无法被中断，而ReentrantLock则提供了可中断的阻塞</em></strong>。下面的代码是<code>ReentranLock</code>的函数，我们就以此为顺序，依次讲解这些函数背后的实现原理。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">ReentrantLock lock = new ReentrantLock();
lock.lock();
lock.unlock();
</code></pre>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>&emsp;<code>ReentranLock</code>分为公平锁和非公平锁，二者的区别就在获取锁机会是否和排队顺序相关。我们都知道，如果锁被另一个线程持有，那么申请锁的其他线程会被挂起等待，加入等待队列。理论上，先调用<code>lock</code>函数被挂起等待的线程应该排在等待队列的前端，后调用的就排在后边。如果此时，锁被释放，需要通知等待线程再次尝试获取锁，公平锁会让最先进入队列的线程获得锁。而非公平锁则会唤醒所有线程，让它们再次尝试获取锁，所以可能会导致后来的线程先获得了锁，则就是非公平。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre>
<p>&emsp;我们会发现<code>FairSync</code>和<code>NonfairSync</code>都继承了<code>Sync</code>类，而<code>Sync</code>的父类就是<code>AbstractQueuedSynchronizer</code>(后续简称<code>AQS</code>)。但是<code>AQS</code>的构造函数是空的,并没有任何操作。<br>&emsp;之后的源码分析，如果没有特别说明，就是指公平锁。</p>
<h3 id="lock操作"><a href="#lock操作" class="headerlink" title="lock操作"></a>lock操作</h3><p>&emsp;<code>ReentranLock</code>的<code>lock</code>函数如下所示，直接调用了<code>sync</code>的<code>lock</code>函数。也就是调用了<code>FairSync</code>的<code>lock</code>函数。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">    &#x2F;&#x2F;ReentranLock
    public void lock() {
        sync.lock();
    }
    &#x2F;&#x2F;FairSync
    final void lock() {
        &#x2F;&#x2F;调用了AQS的acquire函数,这是关键函数之一
        acquire(1);
    }
</code></pre></p>
<p>&emsp;我们接下来就正式开始<code>AQS</code>相关的源码分析了，<code>acquire</code>函数的作用是获取同一时间段内只能被一个线程获取的量，这个量就是抽象化的锁概念。我们先分析代码，你慢慢就会明白其中的含义。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public final void acquire(int arg) {
	&#x2F;&#x2F; tryAcquire先尝试获取&quot;锁&quot;,获取了就不进入后续流程
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        &#x2F;&#x2F;addWaiter是给当前线程创建一个节点,并将其加入等待队列
        &#x2F;&#x2F;acquireQueued是当线程已经加入等待队列之后继续尝试获取锁.
        selfInterrupt();
}
</code></pre></p>
<p>&emsp;<code>tryAcquire</code>，<code>addWaiter</code>和<code>acquireQueued</code>都是十分重要的函数，我们接下来依次学习一下这些函数，理解它们的作用。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F;AQS类中的变量.
private volatile int state;
&#x2F;&#x2F;这是FairSync的实现,AQS中未实现,子类按照自己的需要实现该函数
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    &#x2F;&#x2F;获取AQS中的state变量,代表抽象概念的锁.
    int c = getState();
    if (c == 0) { &#x2F;&#x2F;值为0,那么当前独占性变量还未被线程占有
        &#x2F;&#x2F;如果当前阻塞队列上没有先来的线程在等待,UnfairSync这里的实现就不一致
        if (!hasQueuedPredecessors() &amp;&amp; 
            compareAndSetState(0, acquires)) {
            &#x2F;&#x2F;成功cas,那么代表当前线程获得该变量的所有权,也就是说成功获得锁
            setExclusiveOwnerThread(current);
            &#x2F;&#x2F; setExclusiveOwnerThread将本线程设置为独占性变量所有者线程
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        &#x2F;&#x2F;如果该线程已经获取了独占性变量的所有权,那么根据重入性
        &#x2F;&#x2F;原理,将state值进行加1,表示多次lock
        &#x2F;&#x2F;由于已经获得锁,该段代码只会被一个线程同时执行,所以不需要
        &#x2F;&#x2F;进行任何并行处理
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    &#x2F;&#x2F;上述情况都不符合,说明获取锁失败
    return false;
}
</code></pre>
<p>&emsp;由上述代码我们可以发现，<code>tryAcquire</code>就是尝试获取那个线程独占的变量<code>state</code>。state的值表示其状态：如果是0，那么当前还没有线程独占此变量；否在就是已经有线程独占了这个变量，也就是代表已经有线程获得了锁。但是这个时候要再进行一次判断，看是否是当前线程自己获得的这个锁，如果是，就增加state的值。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-90472c418cd5dd47.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ReentranLock获得锁"></p>
<p>&emsp;这里有几点需要说明一下，首先是<code>compareAndSetState</code>函数，这是使用CAS操作来设置<code>state</code>的值，而且state值设置了<code>volatile</code>修饰符，通过这两点来确保修改state的值不会出现多线程问题。然后是公平锁和非公平锁的区别问题，在<code>UnfairSync</code>的<code>nonfairTryAcquire</code>函数中不会在相同的位置上调用<code>hasQueuedPredecessors</code>来判断当前是否已经有线程在排队等待获得锁。</p>
<p>&emsp;如果<code>tryAcquire</code>返回<code>true</code>，那么就是获取锁成功；如果返回false，那么就是未获得锁，需要加入阻塞等待队列。我们下面就来看一下<code>addWaiter</code>的相关操作。</p>
<h3 id="等待锁的阻塞队列"><a href="#等待锁的阻塞队列" class="headerlink" title="等待锁的阻塞队列"></a>等待锁的阻塞队列</h3><p>&emsp;将保存当前线程信息的节点加入到等待队列的相关函数中涉及到了无锁队列的相关算法，由于在<code>AQS</code>中只是将节点添加到队尾，使用到的无锁算法也相对简单。真正的无锁队列的算法我们等到分析<code>ConcurrentSkippedListMap</code>时在进行讲解。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    &#x2F;&#x2F;先使用快速入列法来尝试一下,如果失败,则进行更加完备的入列算法.
    &#x2F;&#x2F;只有在必要的情况下才会使用更加复杂耗时的算法，也就是乐观的态度
    Node pred = tail; &#x2F;&#x2F;列尾指针
    if (pred != null) {
        node.prev = pred; &#x2F;&#x2F;步骤1:该节点的前趋指针指向tail
        if (compareAndSetTail(pred, node)){ &#x2F;&#x2F;步骤二:cas将尾指针指向该节点
            pred.next = node;&#x2F;&#x2F;步骤三:如果成果,让旧列尾节点的next指针指向该节点.
            return node;
        }
    }
    &#x2F;&#x2F;cas失败,或在pred == null时调用enq
    enq(node);
    return node;
}
private Node enq(final Node node) {
    for (;;) { &#x2F;&#x2F;cas无锁算法的标准for循环,不停的尝试
        Node t = tail;
        if (t == null) { &#x2F;&#x2F;初始化
            if (compareAndSetHead(new Node())) 
              &#x2F;&#x2F;需要注意的是head是一个哨兵的作用,并不代表某个要获取锁的线程节点
                tail = head;
        } else {
            &#x2F;&#x2F;和addWaiter中一致,不过有了外侧的无限循环,不停的尝试,自旋锁
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre></p>
<p>&emsp;通过调用<code>addWaiter</code>函数，<code>AQS</code>将当前线程加入到了等待队列，但是还没有阻塞当前线程的执行，接下来我们就来分析一下<code>acquireQueued</code>函数。</p>
<h3 id="等待队列节点的操作"><a href="#等待队列节点的操作" class="headerlink" title="等待队列节点的操作"></a>等待队列节点的操作</h3><p>&emsp;由于进入阻塞状态的操作会降低执行效率，所以，<code>AQS</code>会尽力避免试图获取独占性变量的线程进入阻塞状态。所以，当线程加入等待队列之后，<code>acquireQueued</code>会执行一个for循环，每次都判断当前节点是否应该获得这个变量(在队首了)。如果不应该获取或在再次尝试获取失败，那么就调用<code>shouldParkAfterFailedAcquire</code>判断是否应该进入阻塞状态。如果当前节点之前的节点已经进入阻塞状态了，那么就可以判定当前节点不可能获取到锁，为了防止CPU不停的执行for循环，消耗CPU资源，调用<code>parkAndCheckInterrupt</code>函数来进入阻塞状态。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) { &#x2F;&#x2F;一直执行,直到获取锁,返回.
            final Node p = node.predecessor(); 
            &#x2F;&#x2F;node的前驱是head,就说明,node是将要获取锁的下一个节点.
            if (p == head &amp;&amp; tryAcquire(arg)) { &#x2F;&#x2F;所以再次尝试获取独占性变量
                setHead(node); &#x2F;&#x2F;如果成果,那么就将自己设置为head
                p.next = null; &#x2F;&#x2F; help GC
                failed = false;
                return interrupted;
                &#x2F;&#x2F;此时,还没有进入阻塞状态,所以直接返回false,表示不需要中断调用selfInterrupt函数
            }
            &#x2F;&#x2F;判断是否要进入阻塞状态.如果`shouldParkAfterFailedAcquire`
            &#x2F;&#x2F;返回true,表示需要进入阻塞
            &#x2F;&#x2F;调用parkAndCheckInterrupt；否则表示还可以再次尝试获取锁,继续进行for循环
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                &#x2F;&#x2F;调用parkAndCheckInterrupt进行阻塞,然后返回是否为中断状态
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL) &#x2F;&#x2F;前一个节点在等待独占性变量释放的通知,所以,当前节点可以阻塞
        return true;
    if (ws &gt; 0) { &#x2F;&#x2F;前一个节点处于取消获取独占性变量的状态,所以,可以跳过去
        &#x2F;&#x2F;返回false
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {
        &#x2F;&#x2F;将上一个节点的状态设置为signal,返回false,
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this); &#x2F;&#x2F;将AQS对象自己传入
    return Thread.interrupted();
}
</code></pre></p>
<h3 id="阻塞和中断"><a href="#阻塞和中断" class="headerlink" title="阻塞和中断"></a>阻塞和中断</h3><p>&emsp;由上述分析，我们知道了<code>AQS</code>通过调用<code>LockSupport</code>的<code>park</code>方法来执行阻塞当前进程的操作。其实，这里的阻塞就是线程不再执行的含义，通过调用这个函数，线程进入阻塞状态，上述的<code>lock</code>操作也就阻塞了，等待中断或在独占性变量被释放。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public static void park(Object blocker) {
    Thread t = Thread.currentThread();
    setBlocker(t, blocker);&#x2F;&#x2F;设置阻塞对象,用来记录线程被谁阻塞的,用于线程监控和分析工具来定位
    UNSAFE.park(false, 0L);&#x2F;&#x2F;让当前线程不再被线程调度,就是当前线程不再执行.
    setBlocker(t, null);
}
</code></pre></p>
<p>&emsp;关于中断的相关知识，我们以后再说，就继续沿着<code>AQS</code>的主线，看一下释放独占性变量的相关操作吧。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-73c6a9c196876ee7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ReentrantLock未获得阻塞,加入队列"></p>
<h3 id="unlock操作"><a href="#unlock操作" class="headerlink" title="unlock操作"></a>unlock操作</h3><p>&emsp;与<code>lock</code>操作类似，<code>unlock</code>操作调用了<code>AQS</code>的<code>relase</code>方法，参数和调用<code>acquire</code>时一样，都是1。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public final boolean release(int arg) {
    if (tryRelease(arg)) { 
    &#x2F;&#x2F;释放独占性变量,起始就是将status的值减1,因为acquire时是加1
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);&#x2F;&#x2F;唤醒head的后继节点
        return true;
    }
    return false;
}
</code></pre></p>
<p>&emsp;由上述代码可知，release就是先调用<code>tryRelease</code>来释放独占性变量。如果成功，那么就看一下是否有等待锁的阻塞线程，如果有，就调用<code>unparkSuccessor</code>来唤醒他们。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">protected final boolean tryRelease(int releases) {
    &#x2F;&#x2F;由于只有一个线程可以获得独占先变量,所以,所有操作不需要考虑多线程
    int c = getState() - releases; 
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) { &#x2F;&#x2F;如果等于0,那么说明锁应该被释放了,否则表示当前线程有多次lock操作.
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre>
<p>&emsp;我们可以看到<code>tryRelease</code>中的逻辑也体现了可重入锁的概念，只有等到<code>state</code>的值为0时，才代表锁真正被释放了。所以独占性变量<code>state</code>的值就代表锁的有无。当<code>state=0</code>时，表示锁未被占有，否在表示当前锁已经被占有。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">private void unparkSuccessor(Node node) {
    .....
     &#x2F;&#x2F;一般来说,需要唤醒的线程就是head的下一个节点,但是如果它获取锁的操作被取消,或在节点为null时
     &#x2F;&#x2F;就直接继续往后遍历,找到第一个未取消的后继节点.
    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
</code></pre>
<p>&emsp;调用了<code>unpark</code>方法后，进行<code>lock</code>操作被阻塞的线程就恢复到运行状态,就会再次执行<code>acquireQueued</code>中的无限for循环中的操作，再次尝试获取锁。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-83eeeb528d9bc58f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ReentrantLock释放锁并通知阻塞线程恢复执行"></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;有关<code>AQS</code>和<code>ReentrantLock</code>的分析就差不多结束了。不得不说，我第一次看到AQS的实现时真是震惊，以前都认为<code>Synchronized</code>和<code>ReentrantLock</code>的实现原理是一致的，都是依靠java虚拟机的功能实现的。没有想到还有<code>AQS</code>这样一个背后大Boss在提供帮助啊。学习了这个类的原理，我们对JUC的很多类的分析就简单了很多。此外，<code>AQS</code>涉及的<code>CAS</code>操作和无锁队列的算法也为我们学习其他无锁算法提供了基础。<strong><em>知识的海洋是无限的啊！</em></strong></p>

        
        </div>
        <footer class="article-footer">
            <!-- id 将作为查询条件 -->
            <span id="/article/d2edd1b8/" class="leancloud_visitors" data-flag-title="AbstractQueuedSynchronizer超详细原理解析">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">1000</i>
            </span>
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/d2edd1b8/" data-id="ckauf70x10009wi66gwyoacx7" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-LongAdder解析-1" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/d4b1972e/">LongAdder原理完全解析</a>
        </h1>
    

                
                    <div class="article-meta">
                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/d4b1972e/">
            <time datetime="2019-01-23T15:10:42.000Z" itemprop="datePublished">2019-01-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/并发/">并发</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/cas/">cas</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;对<code>LongAdder</code>的最初了解是从Coolshell上的一篇文章中获得的，但是一直都没有深入的了解过其实现，只知道它相较于<code>AtomicLong</code>来说，更加适合写多读少的并发情景。今天，我们就研究一下<code>LongAdder</code>的原理，探究一下它如此高效的原因。</p>
<h3 id="基本原理和思想"><a href="#基本原理和思想" class="headerlink" title="基本原理和思想"></a>基本原理和思想</h3><p>&emsp;Java有很多并发控制机制，比如说以AQS为基础的锁或者以CAS为原理的自旋锁。不了解AQS的朋友可以阅读我之前的<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483716&amp;idx=1&amp;sn=22e5160b1fb1068b262d1b0f4fcfc0a0&amp;chksm=fc04c524cb734c327b823acd2cc3ea3ef8620ab2c6c0c1dc1ac6545904f1c3259afd4f2e7450&amp;token=757268630&amp;lang=zh_CN#rd" target="_blank" rel="noopener">AQS源码解析文章</a>。一般来说，CAS适合轻量级的并发操作，也就是并发量并不多，而且等待时间不长的情况，否则就应该使用普通锁，进入阻塞状态，避免CPU空转。</p>
<p>&emsp;所以，如果你有一个Long类型的值会被多线程修改，那么使用CAS进行并发控制比较好，但是如果你是需要锁住一些资源，然后进行数据库操作，那么还是使用阻塞锁比较好。</p>
<p>&emsp;第一种情况下，我们一般都使用<code>AtomicLong</code>。<code>AtomicLong</code>是通过无限循环不停的采取CAS的方法去设置内部的value，直到成功为止。那么当并发数比较多或出现更新热点时，就会导致CAS的失败机率变高，重试次数更多，越多的线程重试，CAS失败的机率越高，形成恶性循环，从而降低了效率。</p>
<p>&emsp;而LongAdder的原理就是降低对value更新的并发数，也就是将对单一value的变更压力分散到多个value值上，降低单个value的“热度”。</p>
<p>&emsp;我们知道<code>LongAdder</code>的大致原理之后，再来详细的了解一下它的具体实现，其中也有很多值得借鉴的并发编程的技巧。</p>
<h3 id="LongAdder的成员变量"><a href="#LongAdder的成员变量" class="headerlink" title="LongAdder的成员变量"></a>LongAdder的成员变量</h3><p>&emsp;<code>LongAdder</code>是<code>Striped64</code>的子类，其有三个比较重要的成员函数，在之后的函数分析中需要使用到，这里先说明一下。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; CPU的数量
static final int NCPU = Runtime.getRuntime().availableProcessors();
&#x2F;&#x2F; Cell对象的数组，长度一般是2的指数
transient volatile Cell[] cells;
&#x2F;&#x2F; 基础value值，当并发较低时，只累加该值
transient volatile long base;
&#x2F;&#x2F; 创建或者扩容Cells数组时使用的自旋锁变量
transient volatile int cellsBusy;
</code></pre>
<p>&emsp;<code>cells</code>是<code>LongAdder</code>的父类<code>Striped64</code>中的<code>Cell</code>数组类型的成员变量。每个<code>Cell</code>对象中都包含一个value值，并提供对这个value值的CAS操作。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">static final class Cell {
    volatile long value;
    Cell(long x) { value = x; }
    final boolean cas(long cmp, long val) {
        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
    }
}
</code></pre></p>
<h3 id="Add操作"><a href="#Add操作" class="headerlink" title="Add操作"></a>Add操作</h3><p>&emsp;我们首先来看一下<code>LongAdder</code>的<code>add</code>函数，其会多次尝试CAS操作将值进行累加，如果成功了就直接返回，失败则继续执行。代码比较复杂，而且涉及的情况比较多，我们就以梳理历次尝试CAS操作为主线，讲清楚这些CAS操作的前提条件和场景。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public void add(long x) {
    Cell[] as; long b, v; int m; Cell a;
    &#x2F;&#x2F; 当cells数组为null时，会进行第一次cas操作尝试。
    if ((as = cells) != null || !casBase(b = base, b + x)) {
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) &lt; 0 ||
            (a = as[getProbe() &amp; m]) == null || 
            !(uncontended = a.cas(v = a.value, v + x)))
            &#x2F;&#x2F; 当cells数组不为null，并且通过getProbe() &amp; m
            &#x2F;&#x2F; 定位的Cell对象不为null时进行第二次CAS操作。
            &#x2F;&#x2F; 如果执行不成功，则进入longAccumulate函数。
            longAccumulate(x, null, uncontended); 
    }
}
</code></pre>
<p>&emsp;当并发量较少时，cell数组尚未初始化，所以只调用<code>casBase</code>函数，对base变量进行CAS累加。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-39fea917eb75cd7e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一个CAS操作"></p>
<p>&emsp;我们来看一下<code>casBase</code>函数相关的源码吧。我们可以认为变量<code>base</code>就是第一个value值，也是基础value变量。先调用casBase函数来cas一下base变量，如果成功了，就不需要在进行下面比较复杂的算法，<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">final boolean casBase(long cmp, long val) {
    return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);
}
</code></pre></p>
<p>&emsp;当并发量逐渐提高时，<code>casBase</code>函数会失败。如果cells数组为null或为空,就直接调用<code>longAccumulate</code>方法。因为cells为null或在为空，说明cells未初始化，所以调用<code>longAccumulate</code>进行初始化。否则继续判断。<br>&emsp;如果cells中已经初始化，就继续进行后续判断。我们先来理解一下<code>getProbe() &amp; m</code>的这个操作吧，可以把这个操作当作一次计算”hash”值，然后将cells中这个位置的Cell对象赋值给变量a。如果变量a不为null，那么就调用该对象的cas方法去设置其value值。如果a为null，或在cas赋值发生冲突，那么调用<code>longAccumulate</code>方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-8433413840b2a94b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二个CAS操作"></p>
<h3 id="LongAccumulate方法"><a href="#LongAccumulate方法" class="headerlink" title="LongAccumulate方法"></a>LongAccumulate方法</h3><p>&emsp;<code>longAccumulate</code>函数比较复杂，带有我的注释的代码已经贴在了文章后边，这里我们就只讲一下其中比较关键的一些技巧和思想。</p>
<p>&emsp;首先，我们都知道只有当对<code>base</code>的cas操作失败之后，<code>LongAdder</code>才引入<code>Cell</code>数组．所以在<code>longAccumulate</code>中就是对<code>Cell</code>数组进行操作，分别涉及了数组的初始化，扩容和设置某个位置的Cell对象等操作。</p>
<p>&emsp;在这段代码中，关于<code>cellBusy</code>的cas操作构成了一个SpinLock，这就是经典的SpinLock的编程技巧，大家可以学习一下。</p>
<p>&emsp;我们先来看一下<code>longAccumulate</code>的主体代码，首先是一个无限for循环，然后根据cells数组的状态来判断是要进行cells数组的初始化，还是进行对象添加或者扩容。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">final void longAccumulate(long x, LongBinaryOperator fn,
                             boolean wasUncontended) {
       int h;
       if ((h = getProbe()) == 0) { 
           &#x2F;&#x2F;获取PROBE变量，探针变量，与当前运行的线程相关，不同线程不同
           ThreadLocalRandom.current(); 
       &#x2F;&#x2F;初始化PROBE变量，和getProbe都使用Unsafe类提供的原子性操作。
           h = getProbe();
           wasUncontended = true;
       }
       boolean collide = false;
       for (;;) { &#x2F;&#x2F;cas经典无限循环，不断尝试
           Cell[] as; Cell a; int n; long v;
           if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) { 
           &#x2F;&#x2F; cells不为null,并且数组size大于0,表示cells已经初始化了
           &#x2F;&#x2F; 初始化Cell对象并设置到数组中或者进行数组扩容
           }
           else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) {
           &#x2F;&#x2F;cells数组未初始化，获得cellsBusy lock,进行cells数组的初始化
           &#x2F;&#x2F; cells数组初始化操作
           }
          &#x2F;&#x2F;如果初始化数组失败了，那就再次尝试一下直接cas base变量，
          &#x2F;&#x2F; 如果成功了就直接返回，这是最后一个进行CAS操作的地方。
           else if (casBase(v = base, ((fn == null) ? v + x :
                                       fn.applyAsLong(v, x))))
               break;
       }
   }
</code></pre>
<p>&emsp;进行Cell数组代码如下所示，它首先调用<code>casCellsBusy</code>函数获取了<code>cellsBusy</code>‘锁’，然后进行数组的初始化操作，最后将<code>cellBusy</code>‘锁’释放掉。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">&#x2F;&#x2F; 注意在进入这段代码之前已经casCellsBusy获得cellsBusy这个锁变量了。
boolean init = false;
try {
    if (cells == as) {
        Cell[] rs = new Cell[2];
        rs[h &amp; 1] = new Cell(x); &#x2F;&#x2F;设置x的值为cell对象的value值
        cells = rs;
        init = true;
    }
} finally {
    cellsBusy = 0;
}
if (init)
    break;
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-71b68d5e008eca77.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第三个CAS操作"></p>
<p>&emsp;如果Cell数组已经初始化过了，那么就进行Cell数组的设置或者扩容。这部分代码有一系列的if else的判断，如果前一个条件不成立，才会进入下一条判断。</p>
<p>&emsp;首先，当Cell数组中对应位置的cell对象为null时，表明该位置的Cell对象需要进行初始化，所以使用<code>casCellsBusy</code>函数获取’锁’，然后初始化Cell对象，并且设置进cells数组，最后释放掉’锁’。</p>
<p>&emsp;当Cell数组中对应位置的cell对象不为null，则直接调用其cas操作进行累加。</p>
<p>&emsp;当上述操作都失败后，认为多个线程在对同一个位置的Cell对象进行操作，这个Cell对象是一个“热点”，所以Cell数组需要进行扩容，将热点分散。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">if ((a = as[(n - 1) &amp; h]) == null) { &#x2F;&#x2F;通过与操作计算出来需要操作的Cell对象的坐标
    if (cellsBusy == 0) { &#x2F;&#x2F;volatile 变量，用来实现spinLock,来在初始化和resize cells数组时使用。
    &#x2F;&#x2F;当cellsBusy为0时，表示当前可以对cells数组进行操作。 
        Cell r = new Cell(x);&#x2F;&#x2F;将x值直接赋值给Cell对象
        if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {&#x2F;&#x2F;如果这个时候cellsBusy还是0
        &#x2F;&#x2F;就cas将其设置为非０，如果成功了就是获得了spinLock的锁．可以对cells数组进行操作．
        &#x2F;&#x2F;如果失败了，就会再次执行一次循环
            boolean created = false;
            try {
                Cell[] rs; int m, j;
                &#x2F;&#x2F;判断cells是否已经初始化，并且要操作的位置上没有cell对象．
                if ((rs = cells) != null &amp;&amp;
                    (m = rs.length) &gt; 0 &amp;&amp;
                    rs[j = (m - 1) &amp; h] == null) {
                    rs[j] = r;　&#x2F;&#x2F;将之前创建的值为x的cell对象赋值到cells数组的响应位置．
                    created = true;
                }
            } finally {
                &#x2F;&#x2F;经典的spinLock编程技巧，先获得锁，然后try finally将锁释放掉
                &#x2F;&#x2F;将cellBusy设置为0就是释放锁．
                cellsBusy = 0;
            }
            if (created)
                break;　&#x2F;&#x2F;如果创建成功了，就是使用x创建了新的cell对象，也就是新创建了一个分担热点的value
            continue; 
        }
    }
    collide = false; &#x2F;&#x2F;未发生碰撞
}
else if (!wasUncontended)&#x2F;&#x2F;是否已经发生过一次cas操作失败
    wasUncontended = true; &#x2F;&#x2F;设置成true,以便第二次进入下一个else if 判断
else if (a.cas(v = a.value, ((fn == null) ? v + x :
                            fn.applyAsLong(v, x))))
    　&#x2F;&#x2F;fn是操作类型，如果是空，就是相加，所以让a这个cell对象中的value值和x相加，然后在cas设置，如果成果
    &#x2F;&#x2F;就直接返回
    break;
else if (n &gt;= NCPU || cells != as)
　　&#x2F;&#x2F;如果cells数组的大小大于系统的可获得处理器数量或在as不再和cells相等．
    collide = false;
else if (!collide)
    collide = true;
else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) {
　　&#x2F;&#x2F;再次获得cellsBusy这个spinLock,对数组进行resize
    try {
        if (cells == as) {&#x2F;&#x2F;要再次检测as是否等于cells以免其他线程已经对cells进行了操作．
            Cell[] rs = new Cell[n &lt;&lt; 1]; &#x2F;&#x2F;扩容一倍
            for (int i = 0; i &lt; n; ++i)
                rs[i] = as[i];
            cells = rs;&#x2F;&#x2F;赋予cells一个新的数组对象
        }
    } finally {
        cellsBusy = 0;
    }
    collide = false;
    continue;
}
h = advanceProbe(h);&#x2F;&#x2F;由于使用当前探针变量无法操作成功，所以重新设置一个,再次尝试
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-7bd9e13169f41c0f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第四个CAS操作"></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;本篇文章写的不是很好，我写完之后又看了一遍coolshell上的关于<code>LongAdder</code>的文章，感觉自己没有人家写的那么简洁明了。我对代码细节的注释和投入太多了。其实很多代码大家都可以看懂，并不需要大量的代码片段加注释。以后要注意一下。之后会接着研究一下JUC包中的其他类，希望大家多多关注。</p>

        
        </div>
        <footer class="article-footer">
            <!-- id 将作为查询条件 -->
            <span id="/article/d4b1972e/" class="leancloud_visitors" data-flag-title="LongAdder原理完全解析">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">1000</i>
            </span>
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/d4b1972e/" data-id="ckauf70xx0025wi66kuucebeu" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-MySQL探秘-八-InnoDB的事务" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/6edb90fb/">MySQL探秘(八):InnoDB的事务</a>
        </h1>
    

                
                    <div class="article-meta">
                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/6edb90fb/">
            <time datetime="2018-12-10T13:45:39.000Z" itemprop="datePublished">2018-12-10</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
    </div>

                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;事务是数据库最为重要的机制之一，凡是使用过数据库的人，都了解数据库的事务机制，也对ACID四个基本特性如数家珍。但是聊起事务或者ACID的底层实现原理，往往言之不详，不明所以。所以，今天我们就一起来分析和探讨InnoDB的事务机制，希望能建立起对事务底层实现原理的具体了解。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-2e908e18a2de4210.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事务的四大特性"></p>
<p>&emsp;数据库事务具有ACID四大特性。ACID是以下4个词的缩写：</p>
<ul>
<li>原子性(atomicity) ：事务最小工作单元，要么全成功，要么全失败 。</li>
<li>一致性(consistency)： 事务开始和结束后，数据库的完整性不会被破坏 。</li>
<li>隔离性(isolation) ：不同事务之间互不影响，四种隔离级别为RU（读未提交）、RC（读已提交）、RR（可重复读）、SERIALIZABLE （串行化）。</li>
<li>持久性(durability) ：事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失 。</li>
</ul>
<p>&emsp;下面，我们就以一个具体实例来介绍数据库事务的原理，并介绍InnoDB是如何实现ACID四大特性的。</p>
<h3 id="示例介绍"><a href="#示例介绍" class="headerlink" title="示例介绍"></a>示例介绍</h3><p>&emsp;我们首先来看一下具体的示例。大家可以自己亲自试验一下，这样理解和记忆都会更加深刻。<br>&emsp;首先，使用如下的SQL语句创建两张表，分别是goods和trade，代表货物和交易。并向goods表中插入一条记录，id为1的货物数量为10。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">CREATE TABLE goods (id INT, num INT, PRIMARY KEY(id));
CREATE TABLE trade (id INT, goods_id INT, user_id INT, PRIMARY KEY(id));
INSERT INTO goods VALUES(1, 10);
</code></pre>
<p>&emsp;然后打开终端，连接数据库，开启会话一，先用BEGIN显示开启一个事务。会话一先将goods表中id为1的货物的数量减一，然后向trade表中添加一笔交易的记录，最后使用COMMIT显示提交事务。<br>&emsp;而会话二则先查询goods表中id为1的货物数量，然后向trade表中添加一笔交易记录，接着更新goods表中id为1的货物的数量，最后使用ROLLBACK进行事务的回滚。其中，两个会话中执行的具体语句和先后顺序如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-e1cb53add98d666d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例具体语句和执行顺序"></p>
<p>&emsp;这个示例可以体现数据库事务的很多特性，我们一一来介绍。首先会话一的操作2更新了id为1的货物的数量，但是会话二的操作5读出来的数量仍然是10，这体现了事务的隔离性，使用InnoDB的<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483698&amp;idx=1&amp;sn=3654042755c7ea0922e5d5b462930946&amp;chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制机制</a>实现。<br>&emsp;会话二的操作7也要更新同种货物的数量，此时因为会话一的操作2已经更新了该货物的数量，InnoDB已经锁住了该记录的行锁，所以操作7会被阻塞，直到会话一COMMIT。但是会话一的操作4和会话二的操作7都是向trade表中插入记录，后者却不会因为前者而阻塞，因为二者插入的不是同一行记录。锁机制是一种常见的并发控制机制，它和多版本控制机制一起实现了InnoDB事务的隔离性，关于InnoDB锁相关的具体内容可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483694&amp;idx=1&amp;sn=671ad369f67441c7d1572110066d5695&amp;chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483702&amp;idx=1&amp;sn=669fb9f413db0cc744bdb5b9ec8f725e&amp;chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>。</p>
<p>&emsp;会话一事务最终使用COMMIT提交了事务而会话二事务则使用ROLLBACK回滚了整个事务，这体现了事务的原子性。即事务的一系列操作要么全部执行(COMMIT)，要么就全部不执行(ROLLBACK)，不存在只执行一部分的情况。InnoDB使用事务日志系统来实现事务的原子性。这里有的同学就会问了，如果中途连接断开或者Server Crash会怎么样。能怎么样，直接自动回滚呗。</p>
<p>&emsp;一旦会话一使用COMMIT操作提交事务成功后，那么数据一定会被写入到数据库中并持久的存储起来，这体现了事务的持久性。InnoDB使用<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483683&amp;idx=1&amp;sn=5225ab3481c38bb57297a36df8e62bce&amp;chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">redo log机制</a>来实现事务的持久性。</p>
<p>&emsp;而事务的一致性比较难以理解，简单的讲在事务开始时，此时数据库有一种状态，这个状态是所有的MySQL对象处于一致的状态，例如数据库完整性约束正确，日志状态一致等。当事务提交后，这时数据库又有了一个新的状态，不同的数据，不同的索引，不同的日志等。但此时，约束，数据，索引，日志等MySQL各种状态还是要保持一致性。 也就是说数据库从一个一致性的状态，变到另一个一致性的状态。事务执行后，并没有破坏数据库的完整性约束。</p>
<p>&emsp;下面我们就来详细讲解一下上述示例涉及的事务的ACID特性的具体实现原理。<strong>总结来说，事务的隔离性由多版本控制机制和锁实现，而原子性、一致性和持久性通过InnoDB的redo log、undo log和Force Log at Commit机制来实现</strong>。</p>
<h3 id="原子性，持久性和一致性"><a href="#原子性，持久性和一致性" class="headerlink" title="原子性，持久性和一致性"></a>原子性，持久性和一致性</h3><p>&emsp;原子性，持久性和一致性主要是通过redo log、undo log和Force Log at Commit机制机制来完成的。redo log用于在崩溃时恢复数据，undo log用于对事务的影响进行撤销，也可以用于多版本控制。而Force Log at Commit机制保证事务提交后redo log日志都已经持久化。<br>&emsp;开启一个事务后，用户可以使用COMMIT来提交，也可以用ROLLBACK来回滚。其中COMMIT或者ROLLBACK执行成功之后，数据一定是会被全部保存或者全部回滚到最初状态的，这也体现了事务的原子性。但是也会有很多的异常情况，比如说事务执行中途连接断开，或者是执行COMMIT或者ROLLBACK时发生错误，Server Crash等，此时数据库会自动进行回滚或者重启之后进行恢复。</p>
<p>&emsp;我们先来看一下redo log的原理，redo log顾名思义，就是重做日志，每次数据库的SQL操作导致的数据变化它都会记录一下，<strong>具体来说，redo log是物理日志，记录的是数据库页的物理修改操作</strong>。如果数据发生了丢失，数据库可以根据redo log进行数据恢复。</p>
<p>&emsp;InnoDB通过Force Log at Commit机制实现事务的持久性，即当事务COMMIT时，必须先将该事务的所有日志都写入到redo log文件进行持久化之后，COMMIT操作才算完成。<br>&emsp;当事务的各种SQL操作执行时，即会在缓冲区中修改数据，也会将对应的redo log写入它所属的缓存。当事务执行COMMIT时，与该事务相关的redo log缓冲必须都全部刷新到磁盘中之后COMMIT才算执行成功。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-99cd9e5402f46d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据库日志和数据落盘机制"></p>
<p>&emsp;redo log写入磁盘时，必须进行一次操作系统的fsync操作，防止redo log只是写入了操作系统的磁盘缓存中。参数innodb_flush_log_at_trx_commit可以控制redo log日志刷新到磁盘的策略，它的具体作用可以查阅<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483683&amp;idx=1&amp;sn=5225ab3481c38bb57297a36df8e62bce&amp;chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB的磁盘文件及落盘机制</a></p>
<p>&emsp;redo log全部写入磁盘后事务就算COMMIT成功了，但是此时事务修改的数据还在内存的缓冲区中，称其为脏页，这些数据会依据检查点(CheckPoint)机制择时刷新到磁盘中，然后删除相应的redo log，但是如果在这个过程中数据库Crash了，那么数据库重启时，会依据redo log file将那些还在内存中未更新到磁盘上的数据进行恢复。</p>
<p>&emsp;数据库为了提高性能，数据页在内存修改后并不是每次都会刷到磁盘上。而是引入checkpoint机制，择时将数据页落盘，checkpoint记录之前的数据页保证一定落盘了，这样相关的redo log就没有用了(由于InnoDB redo log file循环使用，这时这部分日志就可以被覆盖)，checkpoint之后的数据页有可能落盘，也有可能没有落盘，所以checkpoint之后的redo log file在崩溃恢复的时候还是需要被使用的。InnoDB会依据脏页的刷新情况，定期推进checkpoint，从而减少数据库崩溃恢复的时间。检查点的信息在第一个日志文件的头部。</p>
<p>&emsp;数据库崩溃重启后需要从redo log中把未落盘的脏页数据恢复出来，重新写入磁盘，保证用户的数据不丢失。当然，在崩溃恢复中还需要回滚没有提交的事务。由于回滚操作需要undo日志的支持，undo日志的完整性和可靠性需要redo日志来保证，所以崩溃恢复先做redo恢复数据，然后做undo回滚。</p>
<p>&emsp;在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-6a680cf9597332b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据和回滚日志的逻辑存储结构.jpg"></p>
<p>&emsp;undo log的存储不同于redo log，它存放在数据库内部的一个特殊的段(segment)中，这个段称为回滚段。回滚段位于共享表空间中。undo段中的以undo page为更小的组织单位。undo page和存储数据库数据和索引的页类似。因为redo log是物理日志，记录的是数据库页的物理修改操作。所以undo log的写入也会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。如上图所示，表空间中有回滚段和叶节点段和非叶节点段，而三者都有对应的页结构。</p>
<p>&emsp;我们再来总结一下数据库事务的整个流程，如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-c46ad59604b75f65.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事务的相关流程"></p>
<p>&emsp;事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页，然后redo log按照时间或者空间等条件进行落盘，undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了。此时，事务还未COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进行数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使用undo log进行事务回滚。事务执行COMMIT操作时，会将本事务相关的所有redo log都进行落盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发生了崩溃，则只使用redo log恢复数据。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>&emsp;InnoDB事务的隔离性主要通过多版本控制机制和锁机制实现，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483698&amp;idx=1&amp;sn=3654042755c7ea0922e5d5b462930946&amp;chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">多版本控制</a>，<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483694&amp;idx=1&amp;sn=671ad369f67441c7d1572110066d5695&amp;chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB锁的类型和状态查询</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483702&amp;idx=1&amp;sn=669fb9f413db0cc744bdb5b9ec8f725e&amp;chksm=fc04c556cb734c40b3c90a55868619b8ca1f3e1f8763be2d6e7f0568d7c992409937c33b7e10&amp;token=1535405475&amp;lang=zh_CN#rd" target="_blank" rel="noopener">InnoDB行锁算法</a>三篇文章。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>&emsp;本来想一篇文章将MySQL的事务机制讲明白，写完自己读了一遍，还是发现内容有些晦涩难懂，复杂的知识本来就是很难讲明白的，夫夷以近，则游者众；险以远，则至者少，希望读者以本文作为一篇指引性的文章，自己再去更加深入的地方去探秘。不过，能将复杂知识讲解的通俗简单也是一项很大的本领，文字和讲解能力还是需要提示的。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483664&amp;idx=1&amp;sn=a4aea45edf13b367ee17539eaff4874b&amp;chksm=fc04c570cb734c66447aec4344288025bfe6ba7d715af31dc6d60d65411cd90a05d9b02e749d&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Mysql探索(一):B-Tree索引
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483669&amp;idx=1&amp;sn=de5770a2c732a688b6377b4201bf1577&amp;chksm=fc04c575cb734c63fb5da0a871c5447c0cbbaea2a0a39d3896058b546e3d3a85575f575faf4b&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">数据库内部存储结构探索
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483673&amp;idx=1&amp;sn=cba5118dd4705035c40089a9e59305a9&amp;chksm=fc04c579cb734c6fbc0e67006493d5727ed62262ac243ec74ad6c088cb4e3bcd53dfad73caaf&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(二)：SQL语句执行过程详解
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483676&amp;idx=1&amp;sn=b82135c479c806d2b97d026e143f346a&amp;chksm=fc04c57ccb734c6a530b209b3d78de96c30291228e2296179565cc367107df9bc05bcc325c1c&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(三):InnoDB的内存结构和特性
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483683&amp;idx=1&amp;sn=5225ab3481c38bb57297a36df8e62bce&amp;chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(四):InnoDB的磁盘文件及落盘机制
</a></li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483694&amp;idx=1&amp;sn=671ad369f67441c7d1572110066d5695&amp;chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(五):InnoDB锁的类型和状态查询
</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483698&amp;idx=1&amp;sn=3654042755c7ea0922e5d5b462930946&amp;chksm=fc04c552cb734c443f771eb2075cd4d4ce85df85105805667cc4cf51a67ceed2f9ebdf1a8cde&amp;token=731065842&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(六):InnoDB一致性非锁定读
</a></p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/623378-7d960275042f309d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://mysql.taobao.org/monthly/2017/12/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB 事务系统</a></li>
<li><a href="http://mysql.taobao.org/monthly/2015/06/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB 崩溃恢复过程
</a></li>
</ul>

        
        </div>
        <footer class="article-footer">
            <!-- id 将作为查询条件 -->
            <span id="/article/6edb90fb/" class="leancloud_visitors" data-flag-title="MySQL探秘(八):InnoDB的事务">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">1000</i>
            </span>
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/6edb90fb/" data-id="ckauf70y1002gwi66znbgqny6" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-MySQL探秘-六-InnoDB一致性非锁定读" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/c63e3cd7/">MySQL探秘(六):InnoDB一致性非锁定读</a>
        </h1>
    

                
                    <div class="article-meta">
                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/c63e3cd7/">
            <time datetime="2018-11-18T13:45:39.000Z" itemprop="datePublished">2018-11-18</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
    </div>

                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVVC)读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6%E7%AE%80%E5%8D%95%E7%9A%84MVVC.jpg" alt="一致性非锁定读示意图"></p>
<p>&emsp;上图直观地展现了InnoDB一致性非锁定读的机制。之所以称其为非锁定读，是因为不需要等待行上排他锁的释放。快照数据是指该行的之前版本的数据，每行记录可能有多个版本，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVVC)。InnoDB是通过undo log来实现MVVC。undo log本身用来在事务中回滚数据，因此快照数据本身是没有额外开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p>
<p>&emsp;一致性非锁定读是InnoDB默认的读取方式，即读取不会占用和等待行上的锁。但是并不是在每个事务隔离级别下都是采用此种方式。此外，即使都是使用一致性非锁定读，但是对于快照数据的定义也各不相同。</p>
<p>&emsp;在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。然而，对于快照数据的定义却不同。在READ COMMITTED事务隔离级别下，一致性非锁定读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，则读取事务开始时的行数据版本。</p>
<p>&emsp;我们下面举个例子来详细说明一下上述的情况。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike"># session A
mysql&gt; BEGIN;
mysql&gt; SELECT * FROM test WHERE id = 1;
</code></pre></p>
<p>&emsp;我们首先在会话A中显示地开启一个事务，然后读取test表中的id为1的数据，但是事务并没有结束。于此同时，用户在开启另一个会话B，这样可以模拟并发的操作，然后对会话B做出如下的操作：</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike"># session B
mysql&gt; BEGIN;
mysql&gt; UPDATE test SET id = 3 WHERE id = 1;
</code></pre>
<p>&emsp;在会话B的事务中，将test表中id为1的记录修改为id=3，但是事务同样也没有提交，这样id=1的行其实加了一个排他锁。由于InnoDB在READ COMMITTED和REPEATABLE READ事务隔离级别下使用一致性非锁定读，这时如果会话A再次读取id为1的记录，仍然能够读取到相同的数据。此时，READ COMMITTED和REPEATABLE READ事务隔离级别没有任何区别。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6%E4%BC%9A%E8%AF%9DA%E5%92%8C%E4%BC%9A%E8%AF%9DB.jpg" alt="会话A和会话B示意图"></p>
<p>&emsp;如上图所示，当会话B提交事务后，会话A再次运行<code>SELECT * FROM test WHERE id = 1</code>的SQL语句时，两个事务隔离级别下得到的结果就不一样了。<br>&emsp;对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本，如果行被锁定了，则读取该行版本的最新一个快照。因为会话B的事务已经提交，所以在该隔离级别下上述SQL语句的结果集是空的。<br>&emsp;对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据，因此，在该隔离级别下，上述SQL语句仍然会获得相同的数据。</p>
<h4 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h4><p>&emsp;我们首先来看一下wiki上对MVVC的定义：</p>
<blockquote>
<p>Multiversion concurrency control (MCC or MVCC), is a concurrency control<br>method commonly used by database management systems to provide<br>concurrent access to the database and in programming languages to<br>implement transactional memory.</p>
</blockquote>
<p>&emsp;由定义可知，MVVC是用于数据库提供并发访问控制的并发控制技术。<br>数据库的并发控制机制有很多，最为常见的就是锁机制。锁机制一般会给竞争资源加锁，阻塞读或者写操作来解决事务之间的竞争条件，最终保证事务的可串行化。而MVVC则引入了另外一种并发控制，它让读写操作互不阻塞，每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回，由此解决了事务的竞争条件。<br>&emsp;考虑一个现实场景。管理者要查询所有用户的存款总额，假设除了用户A和用户B之外，其他用户的存款总额都为0，A、B用户各有存款1000，所以所有用户的存款总额为2000。但是在查询过程中，用户A会向用户B进行转账操作。转账操作和查询总额操作的时序图如下图所示。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6MVVC%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF.jpg" alt="转账和查询的时序图"></p>
<p>&emsp;如果没有任何的并发控制机制，查询总额事务先读取了用户A的账户存款，然后转账事务改变了用户A和用户B的账户存款，最后查询总额事务继续读取了转账后的用户B的账号存款，导致最终统计的存款总额多了100元，发生错误。</p>
<p>&emsp;使用锁机制可以解决上述的问题。查询总额事务会对读取的行加锁，等到操作结束后再释放所有行上的锁。因为用户A的存款被锁，导致转账操作被阻塞，直到查询总额事务提交并将所有锁都释放。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6%E8%BD%AC%E8%B4%A6%E4%BD%BF%E7%94%A8%E9%94%81.jpg" alt="使用锁机制"><br>&emsp;但是这时可能会引入新的问题，当转账操作是从用户B向用户A进行转账时会导致死锁。转账事务会先锁住用户B的数据，等待用户A数据上的锁，但是查询总额的事务却先锁住了用户A数据，等待用户B的数据上的锁。</p>
<p>&emsp;使用MVVC机制也可以解决这个问题。查询总额事务先读取了用户A的账户存款，然后转账事务会修改用户A和用户B账户存款，查询总额事务读取用户B存款时不会读取转账事务修改后的数据，而是读取本事务开始时的数据副本(在REPEATABLE READ隔离等级下)。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6%E8%BD%AC%E8%B4%A6%E4%BD%BF%E7%94%A8MVVC.jpg" alt="使用MVVC机制"></p>
<p>&emsp;MVCC使得数据库读不会对数据加锁，普通的SELECT请求不会加锁，提高了数据库的并发处理能力。借助MVCC，数据库可以实现READ COMMITTED，REPEATABLE READ等隔离级别，用户可以查看当前数据的前一个或者前几个历史版本，保证了ACID中的I特性（隔离性)</p>
<h4 id="InnoDB的MVVC实现"><a href="#InnoDB的MVVC实现" class="headerlink" title="InnoDB的MVVC实现"></a>InnoDB的MVVC实现</h4><p>&emsp;多版本并发控制仅仅是一种技术概念，并没有统一的实现标准， 其的核心理念就是数据快照，不同的事务访问不同版本的数据快照，从而实现不同的事务隔离级别。虽然字面上是说具有多个版本的数据快照，但这并不意味着数据库必须拷贝数据，保存多份数据文件，这样会浪费大量的存储空间。InnoDB通过事务的undo日志巧妙地实现了多版本的数据快照。<br>&emsp;数据库的事务有时需要进行回滚操作，这时就需要对之前的操作进行undo。因此，在对数据进行修改时，InnoDB会产生undo log。当事务需要进行回滚时，InnoDB可以利用这些undo log将数据回滚到修改之前的样子。<br>&emsp;根据行为的不同 undo log 分为两种 insert undo log和update undo log。<br>&emsp;insert undo log 是在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对于其它事务此记录是不可见的，所以 insert undo log 可以在事务提交后直接删除而不需要进行 purge 操作。<br>&emsp;update undo log 是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，为了提供 MVCC机制，因此 update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。<br>&emsp;为了保证事务并发操作时，在写各自的undo log时不产生冲突，InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际上是一种 Undo 文件组织方式。<br>&emsp;InnoDB行记录有三个隐藏字段：分别对应该行的rowid、事务号db_trx_id和回滚指针db_roll_ptr，其中db_trx_id表示最近修改的事务的id，db_roll_ptr指向回滚段中的undo log。如下图所示。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6innodb%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%88%9D.jpg" alt="初始状态"></p>
<p>&emsp;当事务2使用UPDATE语句修改该行数据时，会首先使用排他锁锁定改行，将该行当前的值复制到undo log中，然后再真正地修改当前行的值，最后填写事务ID，使用回滚指针指向undo log中修改前的行。如下图所示。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6innodb%E5%AE%9E%E7%8E%B02.jpg" alt="第一次修改"></p>
<p>&emsp;当事务3进行修改与事务2的处理过程类似，如下图所示。</p>
<p><img src="http://pie6tw55i.bkt.clouddn.com/2018-mysql-6innodb%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A13.jpg" alt="第二次修改"></p>
<p>&emsp;REPEATABLE READ隔离级别下事务开始后使用MVVC机制进行读取时，会将当时活动的事务id记录下来，记录到Read View中。READ COMMITTED隔离级别下则是每次读取时都创建一个新的Read View。<br>&emsp;Read View是InnoDB中用于判断记录可见性的数据结构，记录了一些用于判断可见性的属性。</p>
<ul>
<li>low_limit_id：某行记录的db_trx_id &lt; 该值，则该行对于当前Read View是一定可见的</li>
<li>up_limit_id：某行记录的db_trx_id &gt;= 该值，则该行对于当前read view是一定不可见的</li>
<li>low_limit_no：用于purge操作的判断</li>
<li>rw_trx_ids：读写事务数组</li>
</ul>
<p>&emsp;Read View创建后，事务再次进行读操作时比较记录的db_trx_id和Read View中的low_limit_id，up_limit_id和读写事务数组来判断可见性。</p>
<p>&emsp;如果该行中的db_trx_id等于当前事务id，说明是事务内部发生的更改，直接返回该行数据。否则的话，如果db_trx_id小于up_limit_id，说明是事务开始前的修改，则该记录对当前Read View是可见的，直接返回该行数据。</p>
<p>&emsp;如果db_trx_id大于或者等于low_limit_id，则该记录对于该Read View一定是不可见的。如果db_trx_id位于[up_limit_id, low_limit_id)范围内，需要在活跃读写事务数组(rw_trx_ids)中查找db_trx_id是否存在，如果存在，记录对于当前Read View是不可见的。<br>&emsp;如果记录对于Read View不可见，需要通过记录的DB_ROLL_PTR指针遍历undo log，构造对当前Read View可见版本数据。<br>&emsp;简单来说，Read View记录读开始时及其之后，所有的活动事务，这些事务所做的修改对于Read View是不可见的。除此之外，所有其他的小于创建Read View的事务号的所有记录均可见。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>&emsp;我们后续还会学习InnoDB的锁的相关的知识，请大家持续关注。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483664&amp;idx=1&amp;sn=a4aea45edf13b367ee17539eaff4874b&amp;chksm=fc04c570cb734c66447aec4344288025bfe6ba7d715af31dc6d60d65411cd90a05d9b02e749d&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Mysql探索(一):B-Tree索引
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483669&amp;idx=1&amp;sn=de5770a2c732a688b6377b4201bf1577&amp;chksm=fc04c575cb734c63fb5da0a871c5447c0cbbaea2a0a39d3896058b546e3d3a85575f575faf4b&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">数据库内部存储结构探索
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483673&amp;idx=1&amp;sn=cba5118dd4705035c40089a9e59305a9&amp;chksm=fc04c579cb734c6fbc0e67006493d5727ed62262ac243ec74ad6c088cb4e3bcd53dfad73caaf&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(二)：SQL语句执行过程详解
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483676&amp;idx=1&amp;sn=b82135c479c806d2b97d026e143f346a&amp;chksm=fc04c57ccb734c6a530b209b3d78de96c30291228e2296179565cc367107df9bc05bcc325c1c&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(三):InnoDB的内存结构和特性
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483683&amp;idx=1&amp;sn=5225ab3481c38bb57297a36df8e62bce&amp;chksm=fc04c543cb734c556574f9e5331ab70f0c8239d70197f70015f58d4ac3f5c4d0b1260f0478e3&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(四):InnoDB的磁盘文件及落盘机制
</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDYwMDMzNQ==&amp;mid=2247483694&amp;idx=1&amp;sn=671ad369f67441c7d1572110066d5695&amp;chksm=fc04c54ecb734c58101f8ff020914f4cccaf6660742a6723b431066ca05d5e71365dfd8d4556&amp;token=451486072&amp;lang=zh_CN#rd" target="_blank" rel="noopener">MySQL探秘(五):InnoDB锁的类型和状态查询
</a></li>
</ul>
<p><img src="http://pie6tw55i.bkt.clouddn.com/qrcode_for_gh_bcc90a2a52c5_344.jpg" alt=""></p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="http://mysql.taobao.org/monthly/2018/03/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2018/03/01/</a></li>
<li><a href="https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/" target="_blank" rel="noopener">https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/</a></li>
<li><a href="http://hedengcheng.com/?p=148" target="_blank" rel="noopener">http://hedengcheng.com/?p=148</a></li>
<li>《唐成－2016PG大会-数据库多版本实现内幕.pdf》</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <!-- id 将作为查询条件 -->
            <span id="/article/c63e3cd7/" class="leancloud_visitors" data-flag-title="MySQL探秘(六):InnoDB一致性非锁定读">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">1000</i>
            </span>
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/c63e3cd7/" data-id="ckauf70y4002nwi66za8e26kn" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-2018年-计划目录" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/e7ec8ed3/">2018年,计划目录</a>
        </h1>
    

                
                    <div class="article-meta">
                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/e7ec8ed3/">
            <time datetime="2018-03-26T12:34:31.000Z" itemprop="datePublished">2018-03-26</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/plan/">plan</a>
    </div>

                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;和<a href="http://ztelur.github.io/2017/05/03/2017%E5%B9%B4%EF%BC%8C%E8%AE%A1%E5%88%92%E7%9B%AE%E5%BD%95/" target="_blank" rel="noopener">17年计划</a>一样，建立一个计划目录，记录一下18年的计划和实现情况,进行不定时的更新。</p>
<h2 id="计划列表"><a href="#计划列表" class="headerlink" title="计划列表"></a>计划列表</h2><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><ul>
<li>测试用例自动化生成技术研究<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3></li>
<li>计算机程序的构造和解释<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2018-3-26日"><a href="#2018-3-26日" class="headerlink" title="2018.3.26日"></a>2018.3.26日</h3><h4 id="测试用例自动化生成技术研究"><a href="#测试用例自动化生成技术研究" class="headerlink" title="测试用例自动化生成技术研究"></a>测试用例自动化生成技术研究</h4>&emsp;依据代码逻辑自动生成junit代码。用于追求覆盖率的junit代码自动生成<h4 id="计算机程序的构造和解释"><a href="#计算机程序的构造和解释" class="headerlink" title="计算机程序的构造和解释"></a>计算机程序的构造和解释</h4>&emsp;再次挑战这本书，希望能坚持下去。</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <!-- id 将作为查询条件 -->
            <span id="/article/e7ec8ed3/" class="leancloud_visitors" data-flag-title="2018年,计划目录">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">1000</i>
            </span>
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/e7ec8ed3/" data-id="ckauf70wz0007wi66nsxizx8e" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Spring-Cloud-Stream-一-：Spring基础知识" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/2317aa7e/">Spring Cloud Stream(一)：Spring基础知识</a>
        </h1>
    

                
                    <div class="article-meta">
                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/2317aa7e/">
            <time datetime="2017-10-10T13:51:45.000Z" itemprop="datePublished">2017-10-10</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Spring/">Spring</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Spring-Boot/">Spring Boot</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;我研究和阅读<code>Spring Cloud Stream</code>源码已经有一个多月了，但是由于自己的Spring基础知识不是很充足，所以导致很多地方都没有融会贯通，并且相关的文章一直无从下手。于是我先整理了当时阅读代码时的知识点记录，算是源码分析之前的基础知识储备吧，整理的有些杂乱，希望大家理解。<br>&emsp;本文涉及的Spring知识如下：</p>
<ul>
<li>Spring Boot的<code>@Import</code>用法和原理,与<code>Configuration</code>和<code>ImportBeanDefinitionRegistrar</code>相关</li>
<li>Bean初始化各个周期的回调，比如<code>InitializingBean</code>,<code>BeanPostProcessor</code>,<code>SmartInitializingSingleton</code></li>
<li><code>FactoryBean</code>和<code>MethodInterceptor</code></li>
<li><code>Aware</code>系列回调</li>
<li><code>Lifecycle</code>和<code>SmartLifecycle</code>和<code>DefaultLifecycleProcessor</code></li>
</ul>
<h4 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h4><p> <code>BeanDefinitionRegistryPostProcessor</code>实现了<code>BeanFactoryPostProcessor</code>接口，是Spring框架的<code>BeanDefinitionRegistry</code>的后处理器，用来注册额外的<code>BeanDefinition</code>。<code>postProcessBeanDefinitionRegistry</code>方法会在所有的<code>BeanDefinition</code>已经被加载了，但是所有的<code>Bean</code>还没有被创建前调用。<code>BeanDefinitionRegistryPostProcessor</code>经常被用来注册<code>BeanFactoryPostProcessor</code>的<code>BeanDefinition</code>。</p>
<h4 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h4><p> <code>@Import</code>注解用来支持在<code>Configuration</code>类中引入其他的配置类，包括<code>Configuration</code>类，<code>ImportSelector</code>和<code>ImportBeanDefinitionRegistrar</code>的实现类。<code>ImportBeanDefinitionRegistrar</code>在<code>ConfigurationClassPostProcessor</code>处理<code>Configuration</code>类期间被调用，用来生成该<code>Configuration</code>类所需要的<code>BeanDefinition</code>。而<code>ConfigurationClassPostProcessor</code>正实现了<code>BeanDefinitionRegistryPostProcessor</code>接口。下面我们就来看一下其<code>processConfigBeanDefinitions</code>方法到底是如何处理<code>Configuration</code>类的。</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
		List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
		String[] candidateNames = registry.getBeanDefinitionNames();
        &#x2F;&#x2F;第一步：先把所有Configuration的beanDefinition找到。
		for (String beanName : candidateNames) {
			BeanDefinition beanDef = registry.getBeanDefinition(beanName);
			&#x2F;&#x2F;利用AnnotationMetadata是否有@Configuration这个注解。需要注意的是
            &#x2F;&#x2F;Configuration是一个元注解，它是可以使用在其他注解上的，被这些注解注释的类也被认为是Configuration
            if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
				configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
			}
		}
		&#x2F;&#x2F;第二步：通过Order注解的值来排序，定义了Configuration的先后顺序
		configCandidates.sort((bd1, bd2) -&gt; {
			int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
			int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
			return (i1 &lt; i2) ? -1 : (i1 &gt; i2) ? 1 : 0;
		});
        &#x2F;&#x2F;..... 此处有省略
		ConfigurationClassParser parser = new ConfigurationClassParser(
				this.metadataReaderFactory, this.problemReporter, this.environment,
				this.resourceLoader, this.componentScanBeanNameGenerator, registry);

		Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
		Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
		do {
            &#x2F;&#x2F;第三步：通过BeanDefinition来读取ConfigurationClass
			parser.parse(candidates);
			parser.validate();

			Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
			configClasses.removeAll(alreadyParsed);

			if (this.reader == null) {
				this.reader = new ConfigurationClassBeanDefinitionReader(
						registry, this.sourceExtractor, this.resourceLoader, this.environment,
						this.importBeanNameGenerator, parser.getImportRegistry());
			}
            &#x2F;&#x2F;第四步：重点，通过ConfigurationClass来获得BeanDefinition
			this.reader.loadBeanDefinitions(configClasses);
			alreadyParsed.addAll(configClasses);

			candidates.clear();
            &#x2F;&#x2F;第五步：由于在loadBeanDefinitions过程中会向registry中添加BeanDefinition,所以这里需要把新的Definition
            &#x2F;&#x2F;在重新检测一遍，先看是否是Configuration类，如果是的那么还要再进行一次处理。
			if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
                &#x2F;&#x2F;.....此处有省略，大致逻辑就是通过registry多出的BeanDefinition获得新的candidateNames
				candidateNames = newCandidateNames;
			}
		}
		while (!candidates.isEmpty());
        &#x2F;&#x2F;.....此处有省略
	}
</code></pre>
<p> 接着我们直接到<code>ConfigurationClassBeanDefinitionReader</code>类中查看<code>loadBeanDefinition</code>函数的实现。它会调用<code>loadBeanDefinitionsForConfigurationClass</code>函数。在该函数中会处理所有和<code>Configuration</code>相关的<code>BeanDefinition</code>,其中就会调用<code>loadBeanDefinitionsFromRegistrars</code>来通过<code>ImportBeanDefinitionRegistrar</code>加载<code>BeanDefinition</code>。<br> 看到这里，大家可能会有个疑问，多个<code>Configuration</code>和多个<code>ImportBeanDefinitionRegistrar</code>存在的情况下，它们之间的对应关系是如何确定的呢？<br> <code>ConfigurationClassParser</code>的parse方法会将Configuration类相关的配置信息全部解析出来。我们可以看其<code>doProcessConfigurationClass</code>方法的源码。通过<code>@Import</code>注解将<code>Configuration</code>类和相应的<code>ImportBeanDefinitionRegistrar</code>联系在一起。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)
			throws IOException {
        &#x2F;&#x2F;首先处理内部成员类的情况
		processMemberClasses(configClass, sourceClass);

		&#x2F;&#x2F; 处理 @PropertySource 注解
		for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), PropertySources.class,
				org.springframework.context.annotation.PropertySource.class)) {
			if (this.environment instanceof ConfigurableEnvironment) {
				processPropertySource(propertySource);
            }
		}

		&#x2F;&#x2F; 处理 @ComponentScan 注解
		Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(
				sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);
		if (!componentScans.isEmpty() &amp;&amp;
				!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {
			for (AnnotationAttributes componentScan : componentScans) {
				&#x2F;&#x2F; The config class is annotated with @ComponentScan -&gt; perform the scan immediately
				Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =
						this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
				&#x2F;&#x2F; Check the set of scanned definitions for any further config classes and parse recursively if needed
				for (BeanDefinitionHolder holder : scannedBeanDefinitions) {
					if (ConfigurationClassUtils.checkConfigurationClassCandidate(
							holder.getBeanDefinition(), this.metadataReaderFactory)) {
						parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());
					}
				}
			}
		}

		&#x2F;&#x2F; 处理 @Import 注解
		processImports(configClass, sourceClass, getImports(sourceClass), true);

		&#x2F;&#x2F; 处理 @ImportResource 注解
		if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {
			AnnotationAttributes importResource =
					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
			String[] resources = importResource.getStringArray(&quot;locations&quot;);
			Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);
			for (String resource : resources) {
				String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);
				configClass.addImportedResource(resolvedResource, readerClass);
			}
		}

		&#x2F;&#x2F; 处理configuration中的 @Bean 函数
		Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
		for (MethodMetadata methodMetadata : beanMethods) {
			configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
		}
        &#x2F;&#x2F;......有省略
		return null;
	}
</code></pre></p>
<h4 id="InitializingBean，FactoryBean，MethodInterceptor"><a href="#InitializingBean，FactoryBean，MethodInterceptor" class="headerlink" title="InitializingBean，FactoryBean，MethodInterceptor"></a>InitializingBean，FactoryBean，MethodInterceptor</h4><p> Spring Cloud Stream的<code>BindableProxyFactory</code>类实现了上述接口。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">BindableProxyFactory implements MethodInterceptor, FactoryBean&lt;Object&gt;, Bindable, InitializingBean
</code></pre></p>
<p> 其中，<code>InitializingBean</code>接口有一个<code>afterPropertiesSet</code>方法，该方法在<code>bean</code>所有的属性都被赋值后调用。bean的属性被初始化是在初始化的时候做的，与<code>BeanPostProcessor</code>结合来看，<code>afterPropertiesSet</code>方法在<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>之间被调用。<br> Spring中有两个类型的Bean,普通Bean和工厂Bean。FactoryBean有三个接口，分别是:</p>
<ul>
<li>Object getObject():返回FactoryBean创建的对象实例。</li>
<li>boolean isSingleton():表示FactoryBean返回的对象实例是否为单例。</li>
<li>Class getObjectType():返回FactoryBean返回的对象类型。<br> 我们可以看一下<code>BindableProxyFactory</code>的相关实现，这里会和<code>MethodInterceptor</code>配合。<code>MethodInterceptor</code>是AOP相关的接口，用于在调用对象接口时进行切片注入或在直接实现接口。
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">
@Override
	public synchronized Object getObject() throws Exception {
        &#x2F;&#x2F;使用AOP的ProxyFactory类，由于该类本身也是先了MethodInterceptor接口
        &#x2F;&#x2F;所以这样配合使用，直接返回ProxyFactory类。
		if (this.proxy == null) {
			ProxyFactory factory = new ProxyFactory(this.type, this);
			this.proxy = factory.getProxy();
		}
		return this.proxy;
	}

	@Override
	public Class&lt;?&gt; getObjectType() {
		return this.type;
	}

	@Override
	public boolean isSingleton() {
		return true;
	}
</code></pre>
</li>
</ul>
<h4 id="BeanPostProcessor，ApplicationContextAware，BeanFactoryAware，SmartInitializingSingleton"><a href="#BeanPostProcessor，ApplicationContextAware，BeanFactoryAware，SmartInitializingSingleton" class="headerlink" title="BeanPostProcessor，ApplicationContextAware，BeanFactoryAware，SmartInitializingSingleton"></a>BeanPostProcessor，ApplicationContextAware，BeanFactoryAware，SmartInitializingSingleton</h4><p> Spring Cloud Stream的<code>StreamListenerAnnotationBeanPostProcessor</code>实现了如下接口<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public class StreamListenerAnnotationBeanPostProcessor
		implements BeanPostProcessor, ApplicationContextAware, BeanFactoryAware, SmartInitializingSingleton,
		InitializingBean
</code></pre></p>
<p> <code>BeanPostProcessor</code>是<code>bean</code>的后处理器，通过它我们可以在<code>Bean</code>初始化前后进行处理。它的<code>postProcessBeforeInitialization</code>方法在<code>Bean</code>初始化之前被调用，而<code>postProcessAfterInitialization</code>在<code>Bean</code>初始化后被调用。相关原理涉及到Spring创建Bean的流程，这个之后有时间再研究吧。</p>
<h4 id="Aware系列接口"><a href="#Aware系列接口" class="headerlink" title="Aware系列接口"></a>Aware系列接口</h4><p> Spring中提供了一些<code>Aware</code>相关的接口，像是<code>BeanFactoryAware</code>,<code>ApplicationContextAware</code>等。当一个类实现了这些接口之后，<code>Aware</code>接口的Bean在初始化之后，可以取得相应的资源的实例。比如<code>StreamListenerAnnotationBeanPostProcessor</code>对象就实现了<code>ApplicationContextAware</code>和<code>BeanFactoryAware</code>接口来获取<code>ConfigurableApplicationContext</code>与<code>BeanFactory</code>实例。</p>
<h4 id="SmartInitializingSingleton"><a href="#SmartInitializingSingleton" class="headerlink" title="SmartInitializingSingleton"></a>SmartInitializingSingleton</h4><p> 当所有的singleton的bean都初始化完成之后才会调用这个接口<br>的<code>afterSingletonsInstantiated</code>函数</p>
<h4 id="SmartLifecycle"><a href="#SmartLifecycle" class="headerlink" title="SmartLifecycle"></a>SmartLifecycle</h4><p> 之前介绍的接口都是在Bean的生命周期内的某个阶段中被调用，如果我们希望在容器本身的生命周期事件上做一些事情该怎麽办呢？Spring容器提供了<code>Lifecycle</code>接口。当<code>ApplicationContext</code>接口启动或在关闭时，它会调用本容器内所有的Lifecycle接口。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public interface Lifecycle {
    &#x2F;&#x2F;启动该组件
	void start();
    &#x2F;&#x2F;停止组件
	void stop();
    &#x2F;&#x2F;查看组件是否正在运行
	boolean isRunning();

}
</code></pre></p>
<p> 如果两个对象有依赖关系，希望某一个bean先初始化完成，完成一些工作之后，再初始化另一个bean。在这个场景下，可以使用<code>SmartLifecycle</code>接口，该接口的<code>getPhase</code>方法返回一个整型数字，表明执行顺序。如果其<code>getPhase()</code>方法返回<code>Integer.MIN_VALUE</code>,那么该对象最先启动，最后停止；如果返回<code>Integer.MAX_VALUE</code>,那么该对象最后启动，最先停止。在<code>Spring</code>容器里，有<code>DefaultLifecycleProcessor</code>这个类来处理所有的<code>Lifecycle</code>的bean。在<code>AbstractApplicationContext</code>的<code>finishRefresh</code>函数中会调用到该processer的<code>onRefresh函数</code>，从其调用其本身的<code>startBeans</code>函数。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">private void startBeans(boolean autoStartupOnly) {
		Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();
		Map&lt;Integer, LifecycleGroup&gt; phases = new HashMap&lt;Integer, LifecycleGroup&gt;();
        &#x2F;&#x2F;遍历所有的Lifecycle,按照phase分成不同的LifecycleGroup
		for (Map.Entry&lt;String, ? extends Lifecycle&gt; entry : lifecycleBeans.entrySet()) {
			Lifecycle bean = entry.getValue();
			if (!autoStartupOnly || (bean instanceof SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) {
				int phase = getPhase(bean);
				LifecycleGroup group = phases.get(phase);
				if (group == null) {
					group = new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);
					phases.put(phase, group);
				}
				group.add(entry.getKey(), bean);
			}
		}
		if (!phases.isEmpty()) {
            &#x2F;&#x2F;按照phase排序，然后启动
			List&lt;Integer&gt; keys = new ArrayList&lt;Integer&gt;(phases.keySet());
			Collections.sort(keys);
			for (Integer key : keys) {
				phases.get(key).start();
			}
		}
	}
</code></pre></p>

        
        </div>
        <footer class="article-footer">
            <!-- id 将作为查询条件 -->
            <span id="/article/2317aa7e/" class="leancloud_visitors" data-flag-title="Spring Cloud Stream(一)：Spring基础知识">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">1000</i>
            </span>
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/2317aa7e/" data-id="ckauf70yw004nwi666lxd3iu3" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Spring-Boot-一-Spring-Boot-starter自定义" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/81d689c6/">Spring Boot (一): Spring Boot starter自定义</a>
        </h1>
    

                
                    <div class="article-meta">
                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/81d689c6/">
            <time datetime="2017-09-10T12:25:35.000Z" itemprop="datePublished">2017-09-10</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Spring/">Spring</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Spring-Boot/">Spring Boot</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 前些日子在公司接触了<code>spring boot</code>和<code>spring cloud</code>,有感于其大大简化了spring的配置过程，十分方便使用者快速构建项目，而且拥有丰富的starter供开发者使用。但是由于其自动化配置的原因，往往导致出现问题，新手无法快速定位问题。这里我就来总结一下spring boot 自定义starter的过程,相信大家看完这篇文章之后，能够对<code>spring boot starter</code>的运行原理有了基本的认识。<br> 为了节约你的时间，本篇文章的主要内容有：</p>
<ul>
<li>spring boot starter的自定义</li>
<li>spring boot auto-configuration的两种方式,spring.factories和注解</li>
<li>Conditional注解的使用</li>
</ul>
<h3 id="引入pom依赖"><a href="#引入pom依赖" class="headerlink" title="引入pom依赖"></a>引入pom依赖</h3><p> 相信接触过spring boot的开发者都会被其丰富的starter所吸引，如果你想给项目添加redis支持，你就可以直接引用<code>spring-boot-starter-redis</code>，如果你想使项目微服务化，你可以直接使用<code>spring-cloud-starter-eureka</code>。这些都是spring boot所提供的便利开发者的组件，大家也可以自定义自己的starter并开源出去供开发者使用。<br> 创建自己的starter项目需要maven依赖是如下所示:<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;spring-boot-autoconfigure&lt;&#x2F;artifactId&gt;
            &lt;version&gt;1.4.4.RELEASE&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;
            &lt;version&gt;1.4.4.RELEASE&lt;&#x2F;version&gt;
        &lt;&#x2F;dependency&gt;
</code></pre></p>
<h4 id="核心配置类StorageAutoConfigure"><a href="#核心配置类StorageAutoConfigure" class="headerlink" title="核心配置类StorageAutoConfigure"></a>核心配置类StorageAutoConfigure</h4><p> 构建starter的关键是编写一个装配类，这个类可以提供该starter核心bean。这里我们的starter提供一个类似<code>redis</code>的键值存储功能的bean，我们叫它为<code>StorageService</code>。负责对这个bean进行自动化装配的类叫做<code>StorageAutoConfigure</code>。保存application.properties配置信息的类叫做<code>StorageServiceProperties</code>。这三种类像是铁三角一样，你可以在很多的<code>spring-boot-starter</code>中看到他们的身影。<br> 我们首先来看<code>StorageAutoConfigure</code>的定义。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">@Configuration
@ConditionalOnClass(StorageService.class)
@EnableConfigurationProperties(StorageServiceProperties.class)
public class StorageAutoConfigure {
    @Autowired
    private StorageServiceProperties properties;

    @Bean
    @ConditionalOnMissingBean(StorageService.class)
    @ConditionalOnProperty(prefix = &quot;storage.service&quot;, value = &quot;enabled&quot;, havingValue = &quot;true&quot;)
    StorageService exampleService() {
        return new StorageService(properties);
    }
}
</code></pre></p>
<p> 我们首先讲一下源码中注解的作用。</p>
<ul>
<li><code>@Configuration</code>,被该注解注释的类会提供一个或则多个<code>@bean</code>修饰的方法并且会被spring容器处理来生成<code>bean definitions</code>。</li>
<li><code>@bean</code>注解是必须修饰函数的，该函数可以提供一个<code>bean</code>。而且该函数的函数名必须和bean的名称一致，除了首字母不需要大写。</li>
<li><code>@ConditionalOnClass</code>注解是条件判断的注解，表示对应的类在classpath目录下存在时，才会去解析对应的配置文件。</li>
<li><code>@EnableConfigurationProperties</code>注解给出了该配置类所需要的配置信息类，也就是<code>StorageServiceProperties</code>类，这样spring容器才会去读取配置信息到<code>StorageServiceProperties</code>对象中。</li>
<li><code>@ConditionalOnMissingBean</code>注解也是条件判断的注解，表示如果不存在对应的bean条件才成立，这里就表示如果已经有<code>StorageService</code>的bean了，那么就不再进行该bean的生成。这个注解十分重要，涉及到默认配置和用户自定义配置的原理。也就是说用户可以自定义一个<code>StorageService</code>的bean,这样的话，spring容器就不需要再初始化这个默认的bean了。</li>
<li><code>ConditionalOnProperty</code>注解是条件判断的注解，表示如果配置文件中的响应配置项数值为true,才会对该bean进行初始化。</li>
</ul>
<p> 看到这里，大家大概都明白了<code>StorageAutoConfigure</code>的作用了吧，spring容器会读取相应的配置信息到<code>StorageServiceProperties</code>中，然后依据调节判断初始化StorageService这个bean。集成了该<code>starter</code>的项目就可以直接使用<code>StorageService</code>来存储键值信息了。</p>
<h4 id="配置信息类StorageServiceProperties"><a href="#配置信息类StorageServiceProperties" class="headerlink" title="配置信息类StorageServiceProperties"></a>配置信息类StorageServiceProperties</h4><p> 存储配置信息的类<code>StorageServiceProperties</code>很简单，源码如下所示:<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">@ConfigurationProperties(&quot;storage.service&quot;)
public class StorageServiceProperties {
    private String username;
    private String password;
    private String url;
    
    ......
    &#x2F;&#x2F;一系列的getter和setter函数
}
</code></pre></p>
<p> <code>@ConfigurationProperties</code>注解就是让spring容器知道该配置类的配置项前缀是什么，上述的源码给出的配置信息项有<code>storage.service.username</code>,<code>storage.service.password</code>和<code>storage.service.url</code>，类似于数据库的host和用户名密码。这些配置信息都会由spring容器从<code>application.properties</code>文件中读取出来设置到该类中。</p>
<h4 id="starter提供功能的StorageService"><a href="#starter提供功能的StorageService" class="headerlink" title="starter提供功能的StorageService"></a>starter提供功能的StorageService</h4><p> <code>StorageService</code>类是提供整个starter的核心功能的类，也就是提供键值存储的功能。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">public class StorageService {
    private Logger logger = LoggerFactory.getLogger(StorageService.class);
    private String url;
    private String username;
    private String password;
    private HashMap&lt;String, Object&gt; storage = new HashMap&lt;String, Object&gt;();
    public StorageService(StorageServiceProperties properties) {
        super();
        this.url = properties.getUrl();
        this.username = properties.getUsername();
        this.password = properties.getPassword();
        logger.debug(&quot;init storage with url &quot; + url + &quot; name: &quot; + username + &quot; password: &quot; + password);
    }


    public void put(String key, Object val) {
        storage.put(key, val);
    }

    public Object  get(String key) {
        return storage.get(key);
    }
}
</code></pre></p>
<h4 id="注解配置和spring-factories"><a href="#注解配置和spring-factories" class="headerlink" title="注解配置和spring.factories"></a>注解配置和spring.factories</h4><p>&emsp;自定义的<code>starter</code>有两种方式来通知spring容器导入自己的auto-configuration类，也就是本文当中的<code>StorageAutoConfigure</code>类。<br>&emsp;一般都是在<code>starter</code>项目的<code>resources/META-INF</code>文件夹下的spring.factories文件中加入需要自动化配置类的全限定名称。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">org.springframework.boot.autoconfigure.EnableAutoConfiguration=starter.StorageAutoConfigure
</code></pre></p>
<p>&emsp;<code>spring boot</code>项目中的<code>EnableAutoConfigurationImportSelector</code>会自动去每个jar的相应文件下查看spring.factories文件内容，并将其中的类加载出来在auto-configuration过程中进行配置。而<code>EnableAutoConfigurationImportSelector</code>在<code>@EnableAutoConfiguration</code>注解中被<code>import</code>。<br>&emsp;第一种方法只要是引入该starter，那么spring.factories中的auto-configuration类就会被装载，但是如果你希望有更加灵活的方式，那么就使用自定义注解来引入装配类。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Import(StorageAutoConfigure.class)
@Documented
public @interface EnableStorage {
}
</code></pre></p>
<p>&emsp;有了这个注解，你可以在你引入该starter的项目中使用该注解，通过<code>@import</code>注解，spring容器会自动加载<code>StorageAutoConfigure</code>并自动化进行配置。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>&emsp;上述只是关于spring boot starter最为简单的定制和原理分析，后续我准备研究一下<code>spring cloud stream</code>的源码，主要是因为工作上一直在使用这个框架。请大家继续关注。</p>

        
        </div>
        <footer class="article-footer">
            <!-- id 将作为查询条件 -->
            <span id="/article/81d689c6/" class="leancloud_visitors" data-flag-title="Spring Boot (一): Spring Boot starter自定义">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">1000</i>
            </span>
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/81d689c6/" data-id="ckauf70yx004pwi66rq6sio5q" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Raft算法" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/1df31392/">Raft算法</a>
        </h1>
    

                
                    <div class="article-meta">
                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/1df31392/">
            <time datetime="2017-07-25T09:09:09.000Z" itemprop="datePublished">2017-07-25</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/分布式/">分布式</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Raft/">Raft</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p> 前段时间一直在学习mit的分布式课程<a href="http://nil.csail.mit.edu/6.824/2015/index.html" target="_blank" rel="noopener">Distributed Systems</a>，仔细阅读了raft论文，但是中间又跑去搞docker了，所以一直没有整理raft相关的文章，今天就来总结一下。<br>&emsp;文章中没有多少详细的图片，但是大家可以边看文章边看<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">Raft演示动画</a><br> 之前介绍的<a href="http://remcarpediem.com/2017/04/16/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Paxos/" target="_blank" rel="noopener">Paxos</a>算法一直都是分布式一致性协议的标准，但是Paxos难以理解，更难以理解。于是Stanford的教授提出了Raft协议，它是一个为真实世界应用建立的协议，主要注重协议的落地性和可理解性。这里有Raft的<a href="http://nil.csail.mit.edu/6.824/2015/papers/raft-atc14.pdf" target="_blank" rel="noopener">论文</a>，大家有兴趣可以自行阅读一下。<br> Raft是为了managing a replicated log。Raft会首先选举一个leader,然后让这个leader来管理replicated log。Raft将consensus问题(也就是一致性问题)划分成三个相互独立的子问题：  </p>
<ul>
<li>leader election</li>
<li>log replication</li>
<li>safety</li>
</ul>
<h4 id="Raft-basis"><a href="#Raft-basis" class="headerlink" title="Raft basis"></a>Raft basis</h4><p> 任何时间每个server都处于下列三个状态之一：leader,follower,或在candidate之一。在正常状态下，整个集群只会有一个leader并且其他所有server都处于followers状态下。followers是被动的，它们只会对leader的request进行反应。第三个状态candidate是用来选举新的leader的。<br> Raft以Term来划分运行时间，你可以将其理解为任期。Term以连续的整数来命名，每个Term都以一个election开始。在一次选举中，一个或多个candidate试图成为leader。如果一个candidate赢得了election,那么它就成为leader。如果一次election中没有candidate获胜，那么就进行下一个Term,重新进行election。每个Term最多只有一leader，否则进入下一个Term,这样Term就可以作为一个logical clock。<br> Raft服务器通过RPC来交互，只需要两个RPC操作，RequestVote RPCs and AppendEntries RPCs。RequestVote用于选举而AppendEntries用于leader发送请求进行relicate log entries和心跳。</p>
<h4 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h4><p>&emsp;Raft通过心跳机制来触发leader selection。当一个服务器启动时，默认位于followers状态，并且一直持续知道它一直接受到leader的RPC请求。leader会周期性发送心跳给所有的followers。如果follower一段时间内没有接受到心跳，那么就认为当前没有leader应该开始leader selection。<br>&emsp;开始election后，server将其Term进行加一，然后转变成candidate状态，并且给其他所有server发送RequestVote RPC请求来进行vote。这个过程一直持续到：server自己赢得election,其他的server赢得election,或者这个Term期间没有server获胜，进入下一个Term。<br>&emsp;candidate收到半数以上server的vote就赢得了election。每个server在一个Term中只会vote一次。server基于first-come-and-first-serve的规则来进行投票。一旦某个candidate赢得了election, 就变成了leader,并且开始周期性发送心跳。<br>&emsp;当等待投票时，candidate受到了其他candidate发送的AppendEntries PRC请求,如果candiate发现在包含在请求当中的Term数值大于或则等于自己的Term数值，那么该candiate主动退回到follower状态，否在拒绝该请求，继续保持candidate状态。<br>&emsp;当很多server变成candidate状态进行election时，选举失败的可能性就很高了。那么每个candiate会推迟随机时间之后进入下一个Term并进行新的election。以此来避免大量的选举失败的情况发生。</p>
<h4 id="Log-replication"><a href="#Log-replication" class="headerlink" title="Log replication"></a>Log replication</h4><p>&emsp;一旦一个leader被选举成功，它就开始处理client请求。每个client请求都包含一个需要被replicated state machine处理的命令，leader将这些命令当作一个新的entry添加到log中。然后给follower发送AppendEntries RPCs请求来复制这个log entry。当一个entry被safely relicated(在下一小结中会讲解)，leader就会将entry交给state machine进行执行，并且将结果返回。<br>&emsp;当一个log entry可以被安全的交给state machine处理时，我们认为它是committed的。Raft保证所有committed的log entry一定是持久化的，并且一定被state machine执行。Log entry是committed一旦该entry在大多数follower上被replicated。一旦一个entry被committed,那么在它之前的所有log也是committed的。Leader会随时关注最大的committed的log的index,并在AppendEntries RPCs请求中携带该信息，这样follower就能知道哪些entry被committed，它们就会将其提交给自己的state machine来执行。<br>&emsp;当followers crash或则网络丢包时，leader会一直发送AppendEntries RPCs直到所有followers都存储了entry。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017725-raft-raft1.png" alt="log entry的排列"></p>
<p>&emsp;每个Log entry都有其唯一标识，entry中包括了 leader Term，index和要执行的comand。index是指entry在Log中的位置。Raft通过Log Machine Property来维护Log的合理性：</p>
<ul>
<li>如果两个entries在不同的logs中(存储在不同的server上)拥有相同的index和term,那么他们包含相同的command。</li>
<li>如果两个entries在不同的logs中拥有相同的index和term,那么他们之前的entries也都是一致或在内容相同的。<br>&emsp;第一条规定保证leader每个Term中的每个index最多只能创建一个entry。而第二条规定使得followers在处理AppendEntries RPCs请求时要进行一致性检测。leader在AppendEntries请求中带上了自己logs中排在新entry之前的那个entry的index和term,如果follower在自己的logs中找不到该entry,那么就拒绝添加new entry。这样就保证了第二条规定不会被违反。<br>&emsp;正常情况下，leader和followers的logs都是一致的，但是当一系列的leader crash，followers crash和election之后，followers的logs可能会被当前leader的logs多出一些entry,也可能会少一些entry。在Raft中，leader通过强迫followers的logs复制leader的logs来保持一致性。这就意味着follower logs中的冲突的entry会被重写。</li>
</ul>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017725-raft-raft2.png" alt="leader和follower的logs冲突"></p>
<p>&emsp;为了一致化logs,leader的logs需要和follower的logs进行对比，找出它们之间最后一条相同的entry。然后将follower logs中那条entry之后的所有entry删除，并发送leader logs中那条entry之后的entry给follower。这些行为都发生在AppendEntries RPCs的一致性检查过程中。<br>&emsp;leader会每个follower维护一个nextIndex来记录发送给这个follower的下一条log entry的index。nextIndex初始化为leader logs的最后一条entry之后的index。如果follower的logs和leader的logs不一致，那么AppendEntries RPCs的一致性检查就会失败。leader发现自己的请求被follower拒绝了，那么就减少该follower的nextIndex然后再次发送AppendEntries请求。最终nextIndex就会变成二者log中最后一个一致的entry的index。当上述情况发生之后，AppendEntries请求就会成功，就会删除follower中多的entry和添加缺少的entry。</p>
<h4 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h4><p>&emsp;这一小节主要描述在leader election过程中的一些限定。这些限定保证任何一个Term的leader的logs都包含了之前Term中所有committed的entry。这也是所谓的Leader Completeness Property。</p>
<h4 id="Election限制"><a href="#Election限制" class="headerlink" title="Election限制"></a>Election限制</h4><p>&emsp;Raft规定：在election过程中，new leader本身必须有之前Term中所有committed的log entry。也就是说每次election成功的leader必然包含之前所有的committed的log entry。这样保证了log的单向流动，一定是从leader到follower。<br>&emsp;Raft通过election vote过程来保证上述限制。一个candidate必须得到集群中多于半数的server的vote，而每个committed的log entry一定也会存在于多于半数的server的logs中。也就是说在RequestVote RPC中包含了candidate自己logs中最后一个committed的log信息，接受到该请求的server会将其和自己log中最后一个committed的log进行对比，如果自己的log晚于candiate的，那么就同意该candiate成为leader,否在拒绝。这样的话，没有包含所有committed log entry的candidate就一定不会得到超过半数的server的vote。Raft根据entry的term和index来确定每个entry的先后顺序。较大term的log entry比较新，如果log entry的term一致，那就是越大的index约新。</p>
<h5 id="Committing-entries-from-previous-terms"><a href="#Committing-entries-from-previous-terms" class="headerlink" title="Committing entries from previous terms"></a>Committing entries from previous terms</h5><p>&emsp;如果旧的leader在committing an entry时crash了，那么新的leader是否需要重新commit这个entry呢？但是为了简化，Raft重来不会提交之前Term的log entry。没有被committed的log entry就会被重写。</p>
<h5 id="Followers-and-candidate-crashs"><a href="#Followers-and-candidate-crashs" class="headerlink" title="Followers and candidate crashs"></a>Followers and candidate crashs</h5><p>&emsp;如果followers或在candidate在接受到RPC之前crash，leader会一直重试发送RPC。如果是在接受处理之后crash，没有发送回复，leader也是会重复发送RPC,但是因为RPC都是幂等的，所以不会造成额外的影响。</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>&emsp;Raft的应用十分广泛，比如etcd项目就是使用Raft来保证分布式一致性的，之后我也想去研究一下etcd中Raft的实现，毕竟之前都是理论。</p>

        
        </div>
        <footer class="article-footer">
            <!-- id 将作为查询条件 -->
            <span id="/article/1df31392/" class="leancloud_visitors" data-flag-title="Raft算法">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">1000</i>
            </span>
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/1df31392/" data-id="ckauf70yf003jwi6624iguqst" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Kubernetes部署" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/article/51083ebf/">Kubernetes部署</a>
        </h1>
    

                
                    <div class="article-meta">
                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/article/51083ebf/">
            <time datetime="2017-07-23T07:33:52.000Z" itemprop="datePublished">2017-07-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/docker/">docker</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/docker/">docker</a>, <a class="tag-link" href="/tags/kubernetes/">kubernetes</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>&emsp;学习完Docker之后，发现了kubernetes这个容器云框架，于是就自己部署来玩玩。大家也可以按照这个<a href="和我一步步部署 kubernetes 集群">和我一步步部署 kubernetes 集群</a>文章来部署。最近在这里花费了大量的时间，之后希望整理一下相关的原理介绍。</p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017723-kube-kuber1.png" alt="kuber1.png"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/2017723-kube-kube3.png" alt="kube3.png"></p>
<h3 id="问题列表和解决方案"><a href="#问题列表和解决方案" class="headerlink" title="问题列表和解决方案"></a>问题列表和解决方案</h3><ul>
<li>google源找不到解决方案：<br><a href="http://www.jianshu.com/p/4f5066dad9b4" target="_blank" rel="noopener">http://www.jianshu.com/p/4f5066dad9b4</a><br>公钥未安装导致无法安装</li>
<li>Created API client, waiting for the control plane to become ready<br>卡死在这里，阿里云需要使用内网ip地址 你也可以使用journalctl -u kubelet 查看日志<br>ApiServer的debug <a href="https://github.com/kubernetes/kubernetes/wiki/Debugging-FAQ" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/wiki/Debugging-FAQ</a></li>
<li>SSL/TLS协议<br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></li>
<li>etcd cant bind the addr<br><a href="https://github.com/coreos/etcd/issues/4789" target="_blank" rel="noopener">https://github.com/coreos/etcd/issues/4789</a><br>nc -l 10.5.0.9 2380<br>iptables查看端口问题</li>
<li>flanneld<br><a href="https://stackoverflow.com/questions/34439659/flannel-and-docker-dont-start" target="_blank" rel="noopener">https://stackoverflow.com/questions/34439659/flannel-and-docker-dont-start</a><br>flanneld 启动/kubernetes 没有找到<br>//fail to retrieve network config: invalid charactar</li>
<li><p>linux低版本不支持flanneld的vxlan功能，需要换成udp<br>cant register network : oeperation not supported<br><a href="https://github.com/coreos/etcd/issues/3710" target="_blank" rel="noopener">https://github.com/coreos/etcd/issues/3710</a></p>
</li>
<li><p>linux低版本不支持docker<br><a href="http://dockone.io/question/1060" target="_blank" rel="noopener">http://dockone.io/question/1060</a><br>pod-infra-container-image</p>
</li>
<li>dashboard<br><a href="https://github.com/kubernetes/kubernetes/issues/39722" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/39722</a></li>
<li>127.0.3.1:9090 cant connection<br><a href="http://blog.csdn.net/xinghun_4/article/details/50492041" target="_blank" rel="noopener">http://blog.csdn.net/xinghun_4/article/details/50492041</a><br>add route<br><a href="https://github.com/kubernetes/dashboard/issues/672" target="_blank" rel="noopener">https://github.com/kubernetes/dashboard/issues/672</a></li>
</ul>

        
        </div>
        <footer class="article-footer">
            <!-- id 将作为查询条件 -->
            <span id="/article/51083ebf/" class="leancloud_visitors" data-flag-title="Kubernetes部署">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">1000</i>
            </span>
            <div class="share-container">



</div>

    <a data-url="http://remcarpediem.net/article/51083ebf/" data-id="ckauf70xv001zwi66wwr3izw9" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/5a35e6d9/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/article/5a35e6d9/" class="title">MySQL死锁系列-加锁场景分析</a></p>
                            <p class="item-date"><time datetime="2020-05-21T14:25:30.000Z" itemprop="datePublished">2020-05-21</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/e3e7a535/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/article/e3e7a535/" class="title">带你100% 地了解 Redis 6.0 的客户端缓存</a></p>
                            <p class="item-date"><time datetime="2020-05-10T14:04:45.000Z" itemprop="datePublished">2020-05-10</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/a94bd30a/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/article/a94bd30a/" class="title">MySQL的死锁系列- 锁的类型以及加锁原理</a></p>
                            <p class="item-date"><time datetime="2020-03-31T14:06:26.000Z" itemprop="datePublished">2020-03-31</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/d5009955/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/java-persistent/">java persistent</a></p>
                            <p class="item-title"><a href="/article/d5009955/" class="title">Java 数据持久化系列之池化技术</a></p>
                            <p class="item-date"><time datetime="2020-02-02T13:48:17.000Z" itemprop="datePublished">2020-02-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <!-- <div class="item-thumbnail">
                            <a href="/article/75dc863d/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div> -->
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/plan/">plan</a></p>
                            <p class="item-title"><a href="/article/75dc863d/" class="title">2020年，计划目录</a></p>
                            <p class="item-date"><time datetime="2020-01-27T05:00:09.000Z" itemprop="datePublished">2020-01-27</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SICP/">SICP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-persistent/">java persistent</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/plan/">plan</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计/">设计</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">3</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Animation/" style="font-size: 10px;">Animation</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GSON/" style="font-size: 10px;">GSON</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/JUC/" style="font-size: 20px;">JUC</a> <a href="/tags/Jenkins/" style="font-size: 10px;">Jenkins</a> <a href="/tags/Material-Design/" style="font-size: 10px;">Material Design</a> <a href="/tags/MotionEvent/" style="font-size: 10px;">MotionEvent</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 20px;">Netty</a> <a href="/tags/OkHttp/" style="font-size: 15px;">OkHttp</a> <a href="/tags/Raft/" style="font-size: 10px;">Raft</a> <a href="/tags/React-Native/" style="font-size: 10px;">React Native</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/SICP/" style="font-size: 10px;">SICP</a> <a href="/tags/Shader/" style="font-size: 10px;">Shader</a> <a href="/tags/Span/" style="font-size: 15px;">Span</a> <a href="/tags/Spring-Boot/" style="font-size: 15px;">Spring Boot</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/TCP-IP/" style="font-size: 20px;">TCP/IP</a> <a href="/tags/View/" style="font-size: 15px;">View</a> <a href="/tags/View-Architecture/" style="font-size: 10px;">View Architecture</a> <a href="/tags/ViewRoot/" style="font-size: 10px;">ViewRoot</a> <a href="/tags/Window机制/" style="font-size: 10px;">Window机制</a> <a href="/tags/animation/" style="font-size: 10px;">animation</a> <a href="/tags/cas/" style="font-size: 10px;">cas</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/draw/" style="font-size: 10px;">draw</a> <a href="/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/tags/filesystem/" style="font-size: 10px;">filesystem</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/kubernetes/" style="font-size: 10px;">kubernetes</a> <a href="/tags/persistent/" style="font-size: 15px;">persistent</a> <a href="/tags/redis/" style="font-size: 20px;">redis</a> <a href="/tags/scroll/" style="font-size: 15px;">scroll</a> <a href="/tags/spring-cloud/" style="font-size: 10px;">spring-cloud</a> <a href="/tags/事件传递/" style="font-size: 15px;">事件传递</a> <a href="/tags/依赖注入/" style="font-size: 10px;">依赖注入</a> <a href="/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/tags/动态编程/" style="font-size: 10px;">动态编程</a> <a href="/tags/反射/" style="font-size: 10px;">反射</a> <a href="/tags/图像处理/" style="font-size: 10px;">图像处理</a> <a href="/tags/实习/" style="font-size: 10px;">实习</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/工具-Linux/" style="font-size: 10px;">工具, Linux</a> <a href="/tags/市场/" style="font-size: 10px;">市场</a> <a href="/tags/并发/" style="font-size: 10px;">并发</a> <a href="/tags/思维/" style="font-size: 10px;">思维</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/文件系统/" style="font-size: 10px;">文件系统</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/注解/" style="font-size: 20px;">注解</a> <a href="/tags/第三方库/" style="font-size: 15px;">第三方库</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a> <a href="/tags/贪婪算法/" style="font-size: 10px;">贪婪算法</a> <a href="/tags/软件设计/" style="font-size: 10px;">软件设计</a> <a href="/tags/锁/" style="font-size: 10px;">锁</a> <a href="/tags/限流/" style="font-size: 15px;">限流</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://www.blueskykong.com/">aoho blog</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2020 历小冰<br>
            <a href="http://www.miitbeian.gov.cn/">鲁ICP备19003047号</a> 
        </div>
    </div>
</footer>
        
    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
    



<link rel="stylesheet" href="/css/prism.css">
<script type="text/javascript" src="/js/prism.js"></script>
<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>