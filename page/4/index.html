
 <!DOCTYPE HTML>
<html lang="Chinese">
<head>
  <meta charset="UTF-8">
  
    <title>Carpediem</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="remCarpediem">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Carpediem">
<meta property="og:url" content="http://remcarpediem.com/page/4/index.html">
<meta property="og:site_name" content="Carpediem">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Carpediem">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="Carpediem" type="application/atom+xml">
    
    
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Carpediem">Carpediem</a></h1>
				<h2 class="blog-motto">blog of nobody</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:remcarpediem.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/05/2016年，计划目录/" title="2016年，计划目录" itemprop="url">2016年，计划目录</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2016-03-05T01:34:18.000Z" itemprop="datePublished"> Published 2016-03-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;建立一个计划目录，记录一下１６年的计划和实现情况,进行不定时的更新。</p>
<h3 id="计划清单"><a href="#计划清单" class="headerlink" title="计划清单"></a><strong>计划清单</strong></h3><h4 id="英语学习"><a href="#英语学习" class="headerlink" title="英语学习"></a><strong>英语学习</strong></h4><h5 id="ESL-Pod-暂停"><a href="#ESL-Pod-暂停" class="headerlink" title="ESL_Pod [暂停]"></a>ESL_Pod <strong>[暂停]</strong></h5><p>《English as a second language podcast presents – Introduction to the United States》总共100课。还没有开始，从3月5日开始</p>
<h5 id="扇贝"><a href="#扇贝" class="headerlink" title="扇贝　"></a>扇贝　</h5><ul>
<li>单词 :在背英语单词书，5518词，完成进度8.10%　 计划每天５０词，并且阅读两篇文章 </li>
</ul>
<h5 id="新概念英语-从16-4月开始的"><a href="#新概念英语-从16-4月开始的" class="headerlink" title="新概念英语 [从16.4月开始的]"></a>新概念英语 <strong>[从16.4月开始的]</strong></h5><p>每天一篇小文章背诵。</p>
<h4 id="Android学习"><a href="#Android学习" class="headerlink" title="Android学习"></a><strong>Android学习</strong></h4><h5 id="Android-Annotation-Processor学习"><a href="#Android-Annotation-Processor学习" class="headerlink" title="Android Annotation Processor学习"></a>Android Annotation Processor学习</h5><ul>
<li>三篇文章翻译</li>
<li>Butterknife源码分析</li>
<li>javapoet and 其他的一些class文件修改框架  </li>
</ul>
<h5 id="View相关知识学习-完成，16-3-16-4-23"><a href="#View相关知识学习-完成，16-3-16-4-23" class="headerlink" title="View相关知识学习[完成，16.3~16.4.23]"></a>View相关知识学习<strong>[完成，16.3~16.4.23]</strong></h5><ul>
<li>事件传递处理和各种手势处理</li>
<li>View的measure,layout,draw<br>总结:</li>
<li><a href="http://ztelur.github.io/2016/03/27/Android-Scroll%E8%AF%A6%E8%A7%A3-%E4%B8%80-%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" target="_blank" rel="external">《Android Scroll详解(一)：基础知识》</a></li>
<li><a href="http://ztelur.github.io/2016/03/16/Android-MotionEvent%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">《Android MotionEvent详解》</a></li>
<li><a href="http://ztelur.github.io/2016/02/11/%E5%9B%BE%E8%A7%A3Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B9%8BViewGroup%E7%AF%87/" target="_blank" rel="external">《图解Android事件传递之ViewGroup篇》</a></li>
<li><a href="http://ztelur.github.io/2016/02/04/%E5%9B%BE%E8%A7%A3Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B9%8BView%E7%AF%87/" target="_blank" rel="external">《图解Android事件传递之View篇》</a>。</li>
<li><a href="http://ztelur.github.io/2016/04/07/Android-Scroll%E8%AF%A6%E8%A7%A3-%E4%BA%8C-%EF%BC%9AOverScroller%E5%AE%9E%E6%88%98/" target="_blank" rel="external">《Android Scroll详解(二)：OverScroller实战》</a></li>
<li><a href="http://ztelur.github.io/2016/04/17/Android%E8%A7%86%E5%9B%BE%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">《Android视图架构详解》</a></li>
<li><a href="http://ztelur.github.io/2016/04/21/Android-Scroll%E8%AF%A6%E8%A7%A3-%E4%B8%89-%EF%BC%9AAndroid-%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">《Android Scroll详解(三)：Android 绘制过程详解》</a></li>
</ul>
<h5 id="Android动画学习-从16-4-23到5-19-暂时暂停"><a href="#Android动画学习-从16-4-23到5-19-暂时暂停" class="headerlink" title="Android动画学习 从16.4.23到5.19 暂时暂停"></a>Android动画学习 <strong>从16.4.23到5.19 暂时暂停</strong></h5><ul>
<li><a href="https://segmentfault.com/a/1190000004354609" target="_blank" rel="external">指导文章</a></li>
<li><a href="http://ztelur.github.io/2016/05/09/Property-Animation%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3-%E4%B8%80/" target="_blank" rel="external">Property Animation框架详解(一)</a></li>
<li><a href="http://ztelur.github.io/2016/07/15/%E8%87%AA%E5%AE%9A%E4%B9%89Switch%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">自定义Switch过程详解</a><h5 id="Android-Service-进程间通讯-未进行，中断"><a href="#Android-Service-进程间通讯-未进行，中断" class="headerlink" title="Android Service+进程间通讯 未进行，中断"></a>Android Service+进程间通讯 <strong>未进行，中断</strong></h5><h5 id="Android-TomatoGo开发-正在进行从10-1日开始"><a href="#Android-TomatoGo开发-正在进行从10-1日开始" class="headerlink" title="Android TomatoGo开发 正在进行从10.1日开始"></a>Android TomatoGo开发 <strong>正在进行从10.1日开始</strong></h5></li>
</ul>
<h5 id="Android优化学习-正在进行从12-13日开始"><a href="#Android优化学习-正在进行从12-13日开始" class="headerlink" title="Android优化学习　正在进行从12.13日开始"></a>Android优化学习　<strong>正在进行从12.13日开始</strong></h5><ul>
<li>启动优化</li>
<li>内存优化</li>
<li>各类工具使用</li>
<li>基础知识</li>
</ul>
<h4 id="前端-正在进行从12-13日进行"><a href="#前端-正在进行从12-13日进行" class="headerlink" title="前端　正在进行从12.13日进行"></a><strong>前端</strong>　<strong>正在进行从12.13日进行</strong></h4><ul>
<li>《js权威指南》 800页</li>
<li>《css scret》 300页</li>
<li>react 网页代码学习</li>
</ul>
<h5 id="Hexo-自定义主题"><a href="#Hexo-自定义主题" class="headerlink" title="Hexo 自定义主题"></a>Hexo 自定义主题</h5><h4 id="要阅读的书籍"><a href="#要阅读的书籍" class="headerlink" title="要阅读的书籍"></a><strong>要阅读的书籍</strong></h4><h5 id="技术方面书籍"><a href="#技术方面书籍" class="headerlink" title="技术方面书籍"></a>技术方面书籍</h5><ul>
<li>《计算机解释和构造》,开始时间3.30</li>
<li>《Professional javascript for web Developers.3rd》 一天10页左右<h5 id="其他书籍"><a href="#其他书籍" class="headerlink" title="其他书籍"></a>其他书籍</h5></li>
<li>《从美国看世界》,预计时间<strong>2个星期</strong>，<strong>开始时间3月5日</strong>,<strong>弃坑</strong></li>
<li>《穷查理的历书》,预计时间<strong>1个星期</strong>,<strong>开始时间3月14日</strong></li>
<li><p>《美丽新世界》开始世界4.23<br>###<strong>Update 2016.3.14</strong></p>
<h5 id="ESL-Pod"><a href="#ESL-Pod" class="headerlink" title="ESL_Pod"></a>ESL_Pod</h5><p>《English as a second language podcast presents – Introduction to the United States》总共100课。已经完成8课</p>
<h4 id="要阅读的书籍-1"><a href="#要阅读的书籍-1" class="headerlink" title="要阅读的书籍"></a>要阅读的书籍</h4></li>
<li><p>《从美国看世界》：阅读1星期，只读了一半左右，主要讲述美国经济大萧条时期的经济制度，美国政府政策和帝国主义根源等问题，不是很感兴趣</p>
</li>
<li>《计算机解释和构造》开始阅读</li>
<li>《穷查理的历书》开始阅读</li>
<li>《美丽的新世界》完成</li>
<li>《月亮和六便士》完成</li>
<li>《自控力》正在进行从5.1日开始</li>
<li>《金阁寺》<strong>正在进行从12.13日开始</strong></li>
</ul>
<p>###<strong>Update 2016.4.5</strong></p>
<h4 id="要阅读的书籍-2"><a href="#要阅读的书籍-2" class="headerlink" title="要阅读的书籍"></a>要阅读的书籍</h4><ul>
<li>《计算机解释和构造》完成第一章阅读，希望进行一下总结</li>
<li>《异类 不一样的成功启示录》：清明放假一口气看完，主要讲述了“异类”成功的原因。其中的一万小时定律很是吸引人。读后感：<a href="http://ztelur.github.io/2016/04/05/%E3%80%8A%E5%BC%82%E7%B1%BB-%E4%B8%8D%E4%B8%80%E6%A0%B7%E6%88%90%E5%8A%9F%E7%9A%84%E5%90%AF%E7%A4%BA%E5%BD%95%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/" target="_blank" rel="external">《异类-不一样成功的启示录》读后感</a></li>
<li>《自控力》：读一读，感觉最近懒癌又犯了。一周读一章的节奏。</li>
</ul>
<h3 id="Android-学习"><a href="#Android-学习" class="headerlink" title="Android 学习"></a>Android 学习</h3><h5 id="View相关知识学习"><a href="#View相关知识学习" class="headerlink" title="View相关知识学习"></a>View相关知识学习</h5><ul>
<li>事件传递处理和各种手势处理:<a href="http://ztelur.github.io/2016/03/27/Android-Scroll%E8%AF%A6%E8%A7%A3-%E4%B8%80-%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" target="_blank" rel="external">《Android Scroll详解(一)：基础知识》</a>，<br><a href="http://ztelur.github.io/2016/03/16/Android-MotionEvent%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">《Android MotionEvent详解》</a>，<a href="http://ztelur.github.io/2016/02/11/%E5%9B%BE%E8%A7%A3Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B9%8BViewGroup%E7%AF%87/" target="_blank" rel="external">《图解Android事件传递之ViewGroup篇》</a>，<a href="http://ztelur.github.io/2016/02/04/%E5%9B%BE%E8%A7%A3Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B9%8BView%E7%AF%87/" target="_blank" rel="external">《图解Android事件传递之View篇》</a>。</li>
<li>View的measure,layout,draw</li>
</ul>
<h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><h4 id="扇贝-1"><a href="#扇贝-1" class="headerlink" title="扇贝"></a>扇贝</h4><ul>
<li>打卡：90天</li>
<li>单词：2016考研英语词汇大纲 5518词，学习进度13.80%</li>
</ul>
<h3 id="Udpate-2015-4-23"><a href="#Udpate-2015-4-23" class="headerlink" title=" Udpate 2015.4.23"></a><strong> Udpate 2015.4.23</strong></h3><h3 id="要阅读的书籍-3"><a href="#要阅读的书籍-3" class="headerlink" title="要阅读的书籍"></a>要阅读的书籍</h3><ul>
<li>《SICP》第二章，阅读第一章时没有及时做习题，导致很多内容都忘记了，第二章时要立即做习题</li>
<li>《自控力》放弃阅读….不太喜欢读这一类的书籍</li>
<li>《美丽新世界》，之前读过《1984》,然后被推荐了这本书</li>
</ul>
<h3 id="Android学习-1"><a href="#Android学习-1" class="headerlink" title="Android学习"></a>Android学习</h3><h4 id="View相关知识学习-1"><a href="#View相关知识学习-1" class="headerlink" title="View相关知识学习"></a>View相关知识学习</h4><p>学习完结</p>
<ul>
<li><a href="http://ztelur.github.io/2016/04/07/Android-Scroll%E8%AF%A6%E8%A7%A3-%E4%BA%8C-%EF%BC%9AOverScroller%E5%AE%9E%E6%88%98/" target="_blank" rel="external">Android Scroll详解(二)：OverScroller实战</a></li>
<li><a href="http://ztelur.github.io/2016/04/17/Android%E8%A7%86%E5%9B%BE%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">Android视图架构详解</a></li>
<li><a href="http://ztelur.github.io/2016/04/21/Android-Scroll%E8%AF%A6%E8%A7%A3-%E4%B8%89-%EF%BC%9AAndroid-%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">Android Scroll详解(三)：Android 绘制过程详解</a></li>
</ul>
<p>###＃ Android Animation<br>开始学习</p>
<h3 id="英语-1"><a href="#英语-1" class="headerlink" title="英语"></a>英语</h3><h4 id="扇贝-2"><a href="#扇贝-2" class="headerlink" title="扇贝"></a>扇贝</h4><ul>
<li>打卡：108天</li>
<li>单词：2016考研英语词汇大纲 5518词，学习进度17.63%</li>
</ul>
<h4 id="新概念英语"><a href="#新概念英语" class="headerlink" title="新概念英语"></a>新概念英语</h4><p>一天一篇小文章背诵，已经背诵了８篇了。</p>
<h3 id="Udpate-2016-5-19"><a href="#Udpate-2016-5-19" class="headerlink" title=" Udpate 2016.5.19"></a><strong> Udpate 2016.5.19</strong></h3><h3 id="要阅读的书籍-4"><a href="#要阅读的书籍-4" class="headerlink" title="要阅读的书籍"></a>要阅读的书籍</h3><ul>
<li>《SICP》已经看到77页，边做题边看，进度比较慢，但是感觉收获很多。</li>
<li>《美丽的新世界》，《月亮和六便士》都已经看完了，希望写一篇《月亮和六便士》的读后感！！！</li>
<li>正在读《自控力》</li>
</ul>
<h3 id="Android学习-2"><a href="#Android学习-2" class="headerlink" title="Android学习"></a>Android学习</h3><p>####Android Animation<br>暂时只有这一篇总结<br><a href="http://ztelur.github.io/2016/05/09/Property-Animation%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3-%E4%B8%80/" target="_blank" rel="external">Property Animation框架详解(一)</a></p>
<h4 id="Service和进程间通讯"><a href="#Service和进程间通讯" class="headerlink" title="Service和进程间通讯"></a>Service和进程间通讯</h4><p>正在进行</p>
<h3 id="英语-2"><a href="#英语-2" class="headerlink" title="英语"></a>英语</h3><h4 id="扇贝-3"><a href="#扇贝-3" class="headerlink" title="扇贝"></a>扇贝</h4><ul>
<li>打卡：122天</li>
<li>单词：2016考研英语词汇大纲 5518词，学习进度19.84%</li>
</ul>
<h4 id="新概念英语-1"><a href="#新概念英语-1" class="headerlink" title="新概念英语"></a>新概念英语</h4><p>一天一篇小文章背诵，已经背诵了10篇了。</p>
<h4 id="Update-2016-7-6"><a href="#Update-2016-7-6" class="headerlink" title=" Update 2016.7.6"></a><strong> Update 2016.7.6</strong></h4><p>决定转变编程研究方向，学习后端开发。由于Java基础比较好，所以先通过Java web开发来熟悉后端开发，并且学习Python编程。</p>
<h3 id="要阅读的书籍-5"><a href="#要阅读的书籍-5" class="headerlink" title="要阅读的书籍"></a>要阅读的书籍</h3><ul>
<li>《局外人》，《西西弗神话》。加缪短片小说。荒诞！ <strong>已经读完</strong></li>
<li>《Head First Servlet and JSP》  <strong>在读</strong><h3 id="英语-3"><a href="#英语-3" class="headerlink" title="英语"></a>英语</h3><h4 id="扇贝-4"><a href="#扇贝-4" class="headerlink" title="扇贝"></a>扇贝</h4>继续扇贝学习，中间断了半个月啦。</li>
</ul>
<h3 id="Update-2016-8-1"><a href="#Update-2016-8-1" class="headerlink" title=" Update 2016.8.1 "></a><strong> Update 2016.8.1 </strong></h3><h3 id="要阅读的书籍-6"><a href="#要阅读的书籍-6" class="headerlink" title="要阅读的书籍"></a>要阅读的书籍</h3><ul>
<li>《Professional javascript for web Developers.3rd》 一天10页左右</li>
<li>《SICP》暂时停止</li>
</ul>
<h3 id="Android-学习-1"><a href="#Android-学习-1" class="headerlink" title="Android 学习"></a>Android 学习</h3><h4 id="Android-Animation"><a href="#Android-Animation" class="headerlink" title="Android Animation"></a>Android Animation</h4><p>新做一篇<br><a href="http://ztelur.github.io/2016/07/15/%E8%87%AA%E5%AE%9A%E4%B9%89Switch%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">自定义Switch过程详解</a></p>
<h4 id="Span-and-Drawable-框架-开始"><a href="#Span-and-Drawable-框架-开始" class="headerlink" title="Span and Drawable 框架　开始"></a>Span and Drawable 框架　开始</h4><h3 id="英语-4"><a href="#英语-4" class="headerlink" title="英语"></a>英语</h3><h4 id="扇贝-5"><a href="#扇贝-5" class="headerlink" title="扇贝"></a>扇贝</h4><ul>
<li>打卡 150</li>
<li>单词: 进度 23.9%</li>
</ul>
<h3 id="Update-2016-10-1"><a href="#Update-2016-10-1" class="headerlink" title=" Update 2016.10.1 "></a><strong> Update 2016.10.1 </strong></h3><h3 id="要阅读的书籍-7"><a href="#要阅读的书籍-7" class="headerlink" title="要阅读的书籍"></a>要阅读的书籍</h3><ul>
<li>《Professional javascript for web Developers.3rd》 一天10页左右</li>
</ul>
<h3 id="Android-学习-2"><a href="#Android-学习-2" class="headerlink" title="Android 学习"></a>Android 学习</h3><h4 id="TomatoGO应用开发"><a href="#TomatoGO应用开发" class="headerlink" title="TomatoGO应用开发"></a>TomatoGO应用开发</h4><h3 id="英语-5"><a href="#英语-5" class="headerlink" title="英语"></a>英语</h3><h4 id="扇贝-6"><a href="#扇贝-6" class="headerlink" title="扇贝"></a>扇贝</h4><ul>
<li>打卡 170</li>
</ul>
<h3 id="update-2016-12-12"><a href="#update-2016-12-12" class="headerlink" title="update 2016.12.12 "></a><strong>update 2016.12.12 </strong></h3>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/计划/">计划</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/05/2016年，计划目录/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/05/2016年，计划目录/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/02/24/译-使用注解处理器生成代码-2-注解处理器/" title="[译]使用注解处理器生成代码-2 注解处理器" itemprop="url">[译]使用注解处理器生成代码-2 注解处理器</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2016-02-24T14:12:03.000Z" itemprop="datePublished"> Published 2016-02-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p> 原文请看<a href="https://deors.wordpress.com/2011/10/08/annotation-processors/" target="_blank" rel="external">摸我</a><br> 这是有关注解代码生成技术系列博文的第二部分。在第一部分（<a href="https://deors.wordpress.com/2011/09/26/annotation-types/" target="_blank" rel="external">摸我</a>）中，我们介绍了注解的基本概念与用法。<br> 在本篇博文中我们将介绍注解处理器的基本概念和使用运行方法。</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p> 注解功能强大。你可以使用注解来设置各类元数据或者配置信息，语法格式优雅并且功能强大。<br> 从目前我们了解的知识来看，注解比起<code>Javadoc</code>来有很多优势，但是这些好像都不足以委员会将其加入java语言之中。那么，我们可以更好的利用和了解注解吗？当然可以啦：</p>
<ul>
<li>在运行时刻，带有<code>runtime retention policy</code>的注解可以通过反射获得，<code>Class</code>类中的<code>getAnnotation()</code>和<code>getAnnotations()</code>方法可以做到这些。</li>
<li>在编译时刻，注解处理器可以处理在编译时发现的各类注解。</li>
</ul>
<p>####注解处理器API<br> 当注解在Java 5 首次被引入时，注解处理器API还不是很成熟和规范化。处理注解需要一个单独的工具，叫做<code>apt</code>,注解处理工具；还需要<code>Mirror</code> API(com.sun.mirror),用于编写自定义处理器。<br> 从java 6开始，注解处理通过<code>JSR 269(2)</code>被标准化，被集成进标准库并且<code>apt</code>无缝的集成到java编译器javac中。<br> 因为我们只详细讲述Java 6 中的注解处理器相关API,你可以在<a href="http://download.oracle.com/javase/1.5.0/docs/guide/apt/" target="_blank" rel="external">这里</a>和<a href="http://download.oracle.com/javase/1.5.0/docs/guide/apt/mirror/overview-summary.html" target="_blank" rel="external">这里</a>找到关于java 5中注解的更多信息,并在<a href="http://www.javalobby.org/java/forums/t17876.html" target="_blank" rel="external">这里</a>找到一些例子。<br> 自定义注解处理器只是实现了<code>javax.annotation.processing.Processor</code>接口并准从指定的协议。为了我们的便利，自定义处理器一些常用的功能都由<code>javax.annotation.processing.AbstractProcessor</code>这个类给出了抽象实现。<br> 自定义注解处理器可以使用到一下三个注解来配置自己：</p>
<ul>
<li><strong>javax.annotation.processing.SupportedAnnotationTypes</strong>：这个注解用来注册注解处理器要处理的注解类型。有效值为完全限定名（就是带所在包名和路径的类全名）-通配符（此次英语原文为Wildcards,就是？这个符号代表的类型。比如说<code>List&lt;? extends String</code>,想要深入了解，可以看一下<a href="http://stackoverflow.com/questions/18176594/when-to-use-generic-methods-and-when-to-use-wild-card" target="_blank" rel="external">这里</a>）也可以。</li>
<li><strong>javax.annotation.processing.SupportedSourceVersion</strong>:这是用来注册注解处理器要处理的源代码版本。</li>
<li><strong>javax.annotation.processing.SupportedOptions</strong>:这个注解用来注册可能通过命令行传递给处理器的操作选项。<br>(译者语：对于android注解处理器，第一个注解比较有用，另外两个了解就可)<br> 最后，我们提供<code>process()</code>方法的实现。<h4 id="实现我们第一个注解处理器"><a href="#实现我们第一个注解处理器" class="headerlink" title="实现我们第一个注解处理器"></a>实现我们第一个注解处理器</h4> 让我们开始第一个注解处理器的实现。按照之前章节的知识，我们实现了下面这个类来处理第一篇博文中的<code>Complexity</code>注解：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sdc.assets.annotations.processors;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">import</span> …</span><br><span class="line"></span><br><span class="line">   <span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"sdc.assets.annotations.Complexity"</span>)</span><br><span class="line">   <span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_6)</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexityProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">ComplexityProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations,</span><br><span class="line">                              RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> 这个未完全完成的类，尽管没有任何操作，但是注册可以支持处理<code>sdc.assets.annotations.Complexity</code>注解类型。因此，每次java编译器遇到一个被<code>Complexity</code>标记的类都有执行这个处理器，假设这个处理器在那个路径中可以被获得（具体原由之后会看到）。<br> <code>process()</code>方法会受到两个输入参数：</p>
<ul>
<li><strong>Set&lt;? extends TypeElement&gt;</strong>：注解处理需要执行一次或者多次。每次执行时，处理器方法被调用，并且传入了当前要处理的注解类型。</li>
<li><strong>RoundEnvironment</strong>:这个对象提供当前或者上一次注解处理中被注解标注的源文件元素。（简单点说，就是可以获得所有被标注的元素，无论是类，参数，函数还是变量）<br> 除了上述两个参数之外，<code>ProcessingEnvironment</code>对象也可以通过<code>processingEnv</code>实例获得。这个对象可以提供一些关于日志，文件读写的通用工具类；它的一些功能之后会讨论到。<br> 使用<code>RoundEnvironment</code>对象和<code>Element</code>接口的反射相关的函数，我们可以实现一个打印<code>Complexity</code>标注元素名的注解处理器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Element elem :roundEnv.getElementsAnnotatedWith(Complexity.class)) &#123;     </span><br><span class="line">  Complexity complexity = elem.getAnnotation(Complexity.class);     </span><br><span class="line">  String message = <span class="string">"annotation found in "</span> + elem.getSimpleName()                     + <span class="string">" with complexity "</span> + complexity.value();       processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message); </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// no further processing of this annotation type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打包并且注册注解处理器"><a href="#打包并且注册注解处理器" class="headerlink" title="打包并且注册注解处理器"></a>打包并且注册注解处理器</h4><p> 自定义注解处理器的最后一步就是打包并且向java编译器获取其他可以识别处理器的工具进行注册。</p>
<p> 注册处理器的最简单方法就是使用标注java服务机制：</p>
<ul>
<li>把你的注解处理器打包到jar文件中。</li>
<li>把jar文件加入到META-INF/services目录。</li>
<li>把javax.annotation.processing.Processor文件加入到目录。</li>
<li>把处理器的全限定名写入一个文件中，一个处理器名一行。</li>
</ul>
<p> java编译器或者其他工具会搜索这个文件中标记的所有处理器，并且在注解处理过程中使用。<br> 在我们这个例子中，目录结构和文件内容如下：<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/apt-apt1.png" alt="picture1.png"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/apt-apt2.png" alt="picture2.png"><br> 一旦打包完成，我们就准备使用它。<br>(译者语：关于android平台的自动打包和使用，可以参考butterknife的方法，就是使用<a href="https://github.com/google/auto/tree/master/service" target="_blank" rel="external">AutoService</a>,这个详细知识之后我会单独博文讲解)</p>
<h4 id="使用javac运行处理器"><a href="#使用javac运行处理器" class="headerlink" title="使用javac运行处理器"></a>使用javac运行处理器</h4><p> 想象一下你在一个项目中使用了一些自定义注解并且可以使用注解处理器。在java 5中，编译和注解处理是不同的两步，但是在java 6中，两个任务都集成到java编译器工具javac中。<br> 如果你把注解处理器加入到javac的路径中并且他们使用服务机制进行了注册，他们就会被javac执行调用啦。<br> 在我们这个例子中，下边这个命令会编译并且执行注解处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;javac -cp sdc.assets.annotations-1.0-SNAPSHOT.jar;  </span><br><span class="line">sdc.assets.annotations.processors-1.0-SNAPSHOT.jar    </span><br><span class="line">SimpleAnnotationsTest.java</span><br></pre></td></tr></table></figure></p>
<p> 用于处理的java类文件内容如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sdc.startupassets.annotations.base.client; </span><br><span class="line"><span class="keyword">import</span> ... </span><br><span class="line"><span class="meta">@Complexity</span>(ComplexityLevel.VERY_SIMPLE) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAnnotationsTest</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleAnnotationsTest</span><span class="params">()</span> </span><br><span class="line">  </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Complexity</span>() <span class="comment">// this annotation type applies also to methods //   the default value 'ComplexityLevel.MEDIUM' is assumed </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">theMethod</span><span class="params">()</span> </span><br><span class="line">  </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"consoleut"</span>); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 上述执行结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/623378-17ebea47a83ec437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="picture3.png"></p>
<p> 有一些javac的选项可以在一些特殊的情况下使用：</p>
<ul>
<li>-Akey[=value]：用来传递选项值给处理器，处理器只会接收在通过<code>SupportedOptions</code>注解注册的选项。</li>
<li>-proc:{none|only}:默认情况下，javac会运行注解处理并且编译源码。使用<code>proc:none</code>选项，将不执行注解处理；使用<code>proc:only</code>选项将只执行注解处理过程-当你在注解处理器中运行验证或者质量检查工具或者代码审查工具时。</li>
<li>-processorpath path：用来确定注解处理器和它的依赖的位置</li>
<li>-s dir：用来确定通过注解处理生成的源代码放置在哪个文件夹中。这个目录在执行命令行之前必须存在。</li>
<li>-processor class1[,class2,class3…]：用来给出将要执行的注解处理器全限定名，当使用这个选项时，默认的通过服务机制寻找到的注解处理器将被替换，直接使用命令行给出的处理器进行处理。<br>（译者语：下边两个章节因为和主干内容没有太大关系，所以没有翻译，请感兴趣的朋友自行查阅）<h4 id="Eclipse-中运行注解处理器"><a href="#Eclipse-中运行注解处理器" class="headerlink" title="Eclipse 中运行注解处理器"></a>Eclipse 中运行注解处理器</h4><h4 id="Maven中运行注解处理器"><a href="#Maven中运行注解处理器" class="headerlink" title="Maven中运行注解处理器"></a>Maven中运行注解处理器</h4></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/注解/">注解</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/02/24/译-使用注解处理器生成代码-2-注解处理器/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/02/24/译-使用注解处理器生成代码-2-注解处理器/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/02/21/使用注解处理器生成代码-1-注解类型/" title="使用注解处理器生成代码-1 注解类型" itemprop="url">使用注解处理器生成代码-1 注解类型</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2016-02-21T12:18:55.000Z" itemprop="datePublished"> Published 2016-02-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;原文地址如下：<a href="https://deors.wordpress.com/2011/10/08/annotation-processors/" target="_blank" rel="external">摸我</a><br>&emsp;我希望以此篇博文作为基于注解处理器生成代码系列博文的开篇，给大家展示注解处理器有多么强大，并在最后使用这项技术来在编译时刻生成android代码<br>&emsp;在这个系列博文中，我们会：</p>
<ul>
<li>介绍Java语言中的注解</li>
<li>理解注解的基本用法和作用域</li>
<li>了解<code>Annotation Processor</code>基础知识和作用</li>
<li>学习如何在命令行，<code>Eclipse</code>,<code>Maven</code>中运行<code>Annotation Processors</code></li>
<li>学习如何使用<code>Annotation Processors</code>来生成代码</li>
<li>学习如何<code>Apache Velocity</code>模版来生成代码</li>
</ul>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>&emsp;注解首先在第三版<code>Java Language Specification</code>中被提出，并在<code>java 5</code>中被实现。<br>&emsp;使用注解我们可以给源代码添加元数据信息，比如构造或者部署信息，配置属性，编译特性或者代码质量检查。<br>&emsp;不像<code>Javadocs</code>，注解是强类型的，每个注解都对应一个预先定义好的注解类型。除此之外，程序可以在运行时获得注解信息，<code>Javadocs</code>不行。</p>
<h4 id="注解语法"><a href="#注解语法" class="headerlink" title="注解语法"></a>注解语法</h4><p>&emsp;注解通常出现在被注解代码片段之前，单独成行，并且和代码片段有相同的缩进。<br>&emsp;注解可以应用到包，类型（类，接口，枚举，注解类型），变量（对象，局部变量-包括定义在循环结构中的变量），构造函数，方法，和参数。<br>&emsp;注解的最简单形式是不带任何元素，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">theMethod</span><span class="params">()</span> </span>&#123;…&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;在这种情况下，括号可以被省略。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">theMethod</span><span class="params">()</span> </span>&#123;…&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;注解可以包括通过冒号分离的键值对数据，类型可以是基础类型，字符串，枚举，和数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Author</span>(name = <span class="string">"Albert"</span>,</span><br><span class="line">            created = <span class="string">"17/09/2010"</span>,</span><br><span class="line">            revision = <span class="number">3</span>,</span><br><span class="line">            reviewers = &#123;<span class="string">"George"</span>, <span class="string">"Fred"</span>&#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAnnotationsTest</span> </span>&#123;…&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;当注解只有一个元素并且其名字是value，那么它就可以被省略：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkProduct</span>(<span class="string">"WP00000182"</span>)</span><br><span class="line">    <span class="meta">@Complexity</span>(ComplexityLevel.VERY_SIMPLE)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAnnotationsTest</span> </span>&#123;…&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;注解可以定义它的元素的默认值，有默认值的元素可以在注解声明使用时被省略。<br>&emsp;比如，假设注解<code>Author</code>定义了<code>revision</code>（默认为1）和<code>reviewers</code>(默认为空的字符串数组)，下边的两个注释声明是相同的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Author</span>(name = <span class="string">"Albert"</span>,</span><br><span class="line">            created = <span class="string">"17/09/2010"</span>,</span><br><span class="line">            revision = <span class="number">1</span>,</span><br><span class="line">            reviewers = &#123;&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> class <span class="title">SimpleAnnotationsTest</span><span class="params">()</span> </span>&#123;…&#125;</span><br><span class="line">    <span class="meta">@Author</span>(name = <span class="string">"Albert"</span>,        <span class="comment">// defaults are revision 1</span></span><br><span class="line">            created = <span class="string">"17/09/2010"</span>) <span class="comment">// and no reviewers</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> class <span class="title">SimpleAnnotationsTest</span><span class="params">()</span> </span>&#123;…&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="注解的典型使用"><a href="#注解的典型使用" class="headerlink" title="注解的典型使用"></a>注解的典型使用</h4><p>&emsp;有三类注解类型在<code>Java Language Specification</code>中被定义，它们提供给java的编译器使用：</p>
<ul>
<li><strong>@Deprecated</strong>:表明被标记的元素不应该再被使用。当你使用被标记元素时，编译器会给出警告。也可以使用在<code>Javadoc</code>中，解释标记元素不能在使用的原因。</li>
<li><strong>@Override</strong>：表面被标记元素为重载了超类中的元素</li>
<li><strong>@SuppressWarnings</strong>：让编译器忽略标记元素会产生的一些特定警告</li>
</ul>
<p>&emsp;自从注解被引入，很多库和框架都在其最新版本中添加了注解。通过在代码中使用注解，这些库或者框架可以减少或者去除配置文件的使用。<br>&amp;emsp；最有代表性的几个库或框架如下：</p>
<ul>
<li>Java Enterprise Edition and its main components –  Enterprise JavaBeans, Java Persistence API or Web Services API’s.</li>
<li>Spring Framework – used thoroughly for configuration, dependency injection and inversion of control in the core framework and in other Spring projects.</li>
<li>Seam, Weld, Guice.</li>
<li>Apache Struts 2.</li>
</ul>
<h4 id="注解类型"><a href="#注解类型" class="headerlink" title="注解类型"></a>注解类型</h4><p>&emsp;注解类型(<code>Annotation Type</code>)是定义自定义注解的特殊接口（<code>interface</code>）。<br>&emsp;一个注解类型使用<code>@interface</code>来定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Author &#123;</span><br><span class="line">        <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">String <span class="title">created</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">revision</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line">        String[] reviewers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> Complexity &#123;</span><br><span class="line">        <span class="function">ComplexityLevel <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ComplexityLevel.MEDIUM</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> ComplexityLevel &#123;</span><br><span class="line">        VERY_SIMPLE, SIMPLE, MEDIUM, COMPLEX, VERY_COMPLEX;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;注解类型和常规的接口有一些不同的地方：</p>
<ul>
<li>只有基础类型，字符串，枚举，类常量和上述类型的数组允许在注解定义中使用，一般的类和对象不允许使用，双重数组也不允许。</li>
<li>注解元素的定义语法和类方法的语法相似，但是注意，注解元素的定义不包括修饰符和参数。</li>
<li>默认值是使用<code>default</code>关键字定义的，其后的值必须是字面量，数组初始器和枚举值。</li>
</ul>
<p>&emsp;枚举类型可以在注解内部进行定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Complexity &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">enum</span> Level &#123;</span><br><span class="line">            VERY_SIMPLE, SIMPLE, MEDIUM, COMPLEX, VERY_COMPLEX;</span><br><span class="line">        &#125;</span><br><span class="line">    …</span><br></pre></td></tr></table></figure></p>
<h4 id="用来定义注解的注解"><a href="#用来定义注解的注解" class="headerlink" title="用来定义注解的注解"></a>用来定义注解的注解</h4><p>&emsp;JDK中预先定义了一些用来修改自定义注解行为的注解：</p>
<ul>
<li><strong>@Retention</strong>：表明被标记的注解信息会保存多长时间，一些可能的值如下：<code>CLASS</code> (默认选项，注解信息保存到class文件中，但是无法在运行时获得), <code>SOURCE</code> (当class文件被创建时被编译器抛弃) and <code>RUNTIME</code> (在程序运行时可以获得).</li>
<li><p><strong>@Target</strong>:表明注解可以标记元素的类型，可能的值为枚举类型<code>ElementType</code>的值：<code>ANNOTATION_TYPE</code>, <code>CONSTRUCTOR</code>, <code>FIELD</code>, <code>LOCAL_VARIABLE</code>, <code>METHOD</code>, <code>PACKAGE</code>, <code>PARAMETER</code> and <code>TYPE</code>.<br>&emsp;下一篇博文为《注解处理器》，稍后会给出。</p>
<p>—<br>(1) ”The Java Language Specification, Third Edition” is available for free download <a href="http://java.sun.com/docs/books/jls/" target="_blank" rel="external">here</a>.<br>&emsp;Update: new link to relevant JLS section in his new home at Oracle site <a href="http://docs.oracle.com/javase/specs/jls/se5.0/html/interfaces.html#9.7" target="_blank" rel="external">here</a>.</p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/注解/">注解</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/02/21/使用注解处理器生成代码-1-注解类型/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/02/21/使用注解处理器生成代码-1-注解类型/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/02/11/图解Android事件传递之ViewGroup篇/" title="图解Android事件传递之ViewGroup篇" itemprop="url">图解Android事件传递之ViewGroup篇</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2016-02-11T09:21:20.000Z" itemprop="datePublished"> Published 2016-02-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;本篇文章主要讲述ViewGroup中关于触摸事件传递的相关逻辑。主要梳理一下<code>dispatchTouchEvent</code>函数。</p>
<h4 id="一些知识点"><a href="#一些知识点" class="headerlink" title="一些知识点"></a>一些知识点</h4><ul>
<li><code>FLAG_DISALLOW_INTERCEPT</code>，可以使用<code>requestDisallowInterceptTouchEvent</code>来设置<code>ViewGroup</code>的这个标记位，让ViewGroup不拦截事件。</li>
<li><code>ViewGroup</code>只会将触摸事件转发给那些可见并且触摸事件发生在其可视范围内的子<code>View</code></li>
<li>如果一个子<code>View</code>没有接收<code>ACTION_DOWN</code>事件，那么这个事件系列的<code>ACTION_MOVE</code>或者<code>ACTION_UP</code>事件根本不会传递给它</li>
<li>关于<code>ViewGroup</code>拦截与否消费与否的判断，只要记住一点就可以轻易判断：1 <code>ViewGroup</code>是否最终没有消费触摸事件（无论是自己自己消费，还是分发给子view消费），决定之后的触摸事件是否会再转发给它。</li>
</ul>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/201644-toucheventViewGroup.png" alt="dispatchTouchEvent的主流程"><br><img src="http://7xrxif.com1.z0.glb.clouddn.com/201644-toucheventViewGroup%E9%81%8D%E5%8E%86child.png" alt="dispatchTouchEvent中遍历child分发事件的逻辑"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/viewgroup3.png" alt="转换触摸事件并分发的过程-dispatchTransformedTouchEvent"></p>
<p>更详细的源代码请查看<a href="https://github.com/ztelur/AOSP-analysis/tree/master/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92" target="_blank" rel="external">我的github</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/事件传递/">事件传递</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/02/11/图解Android事件传递之ViewGroup篇/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/02/11/图解Android事件传递之ViewGroup篇/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/02/04/图解Android事件传递之View篇/" title="图解Android事件传递之View篇" itemprop="url">图解Android事件传递之View篇</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2016-02-04T09:09:01.000Z" itemprop="datePublished"> Published 2016-02-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;最近放假在家里闲着，想好好研究一下android的事件传递机制。于是便抓来<code>View</code>,<code>ViewGroup</code>这些类的源代码来看；有很多疑惑，又在网上找到了几篇比较好的介绍事件传递机制的文章阅读了一番。然后想着最好把学习到的知识输出一遍，画成视图，写下这篇博文。<br>&emsp;除了图片，我还在源码上进行了注释，提交到了github上去。<a href="https://github.com/ztelur/AOSP-analysis/tree/master/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92" target="_blank" rel="external">我的github</a></p>
<h4 id="View的dispatchTouchEvent"><a href="#View的dispatchTouchEvent" class="headerlink" title="View的dispatchTouchEvent"></a>View的dispatchTouchEvent</h4><p><img src="http://7xrxif.com1.z0.glb.clouddn.com/touch-view1.png" alt="View-dispatchTouchEvent.png"></p>
<h4 id="View的onTouchEvent"><a href="#View的onTouchEvent" class="headerlink" title="View的onTouchEvent"></a>View的onTouchEvent</h4><p><img src="http://7xrxif.com1.z0.glb.clouddn.com/touch-view2.png" alt="View-onTouchEvent1.png"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/touch-view3.png" alt="View-onTouchEvent2.png"></p>
<h4 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h4><ul>
<li><a href="http://wangkuiwu.github.io/2015/01/05/TouchEvent-Sample-02-View/" target="_blank" rel="external">一位大神的博文，他的文章系列都值得看一看</a></li>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/9097463" target="_blank" rel="external">郭大神的博客</a></li>
<li><a href="http://www.infoq.com/cn/articles/android-event-delivery-mechanism" target="_blank" rel="external">很详细但有错误的地方的一篇经典文章</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/事件传递/">事件传递</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/02/04/图解Android事件传递之View篇/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/02/04/图解Android事件传递之View篇/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/02/02/《Redis设计和实现》读书笔记1-简单动态字符串/" title="《Redis设计和实现》读书笔记1-简单动态字符串" itemprop="url">《Redis设计和实现》读书笔记1-简单动态字符串</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2016-02-02T14:38:59.000Z" itemprop="datePublished"> Published 2016-02-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;临近过年，我离开了实习了4个多月的扇贝。临走前，导师赠送给我一本《Redis设计和实现》，于是心血来潮，想读一读这本书，然后仿照书中介绍的原理实现一个小型的数据库。这是redis系列的第一篇博文，希望我可以坚持下去，不要虎头蛇尾。</p>
<h4 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h4><p>&emsp;我们都知道Redis是由纯c代码编写而成的，而c语言中的原生字符串有很多的缺陷，不利于大型工程的使用。于是Redis的作者便自己实现一套字符串数据结构，就是sds.h/sdshdr结构。</p>
<h4 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sdshdr &#123;</span><br><span class="line">  <span class="comment">// 记录sdshdr中数组已经使用的数量</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="comment">// 记录sdshdr中数组未使用的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;<code>sdshdr</code>的定义如代码所示，其中<code>buf</code>属性为一个char类型的数组，数组的前五个字节分别保存着’R’,’e’,’d’,’i’,’s’五个字符，最后一个字符则保存则空字符串’\0’。之所以在数组尾部保存空字符，是为了可以使用一些c语言的字符串函数库中的函数。</p>
<h4 id="SDS与c字符串的区别"><a href="#SDS与c字符串的区别" class="headerlink" title="SDS与c字符串的区别"></a>SDS与c字符串的区别</h4><h5 id="常数时间内获得字符串长度"><a href="#常数时间内获得字符串长度" class="headerlink" title="常数时间内获得字符串长度"></a>常数时间内获得字符串长度</h5><p>&emsp;我们都知道，在c中，字符串就是一个末尾有一个’\0’的一维数组，它并不记录本身的长度。所以，每次想要获取其长度时，都需要遍历整个数组，时间复杂度就为O(n)；而SDS因为本身就有<code>len</code>这个字段，并且在SDS被修改时，会自动改变<code>len</code>字段，所以获得字符串长度的时间复杂度为O(1).</p>
<h5 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h5><p>&emsp;因为c的字符串没有任何安全保证，当我们使用<code>strcat</code>函数来拼接字符串时，如果目标字符串没有被分配足够空间的话，就会造成缓冲区溢出。而在SDS中，当然是每次修改都会进行缓冲区溢出检测，所以不会出现类似问题。</p>
<h5 id="减少修改字符串时带来的内存重新分配次数"><a href="#减少修改字符串时带来的内存重新分配次数" class="headerlink" title="减少修改字符串时带来的内存重新分配次数"></a>减少修改字符串时带来的内存重新分配次数</h5><p>&emsp;这一条应该是使用SDS最大的优势所在啦。因为c语言中的字符串都是无法修改的，所以每次拼接或者裁剪字符串都会导致新的字符串数据结构的生成，从而需要新的内存分配或者释放部分内存。由于内存分配很消耗时间，所以使用c语言的字符串会导致数据库性能低下。<br>&emsp;而SDS会通过空间预分配和惰性空间释放来减少内存分配或者释放的次数。<br>&emsp;内存预分配是指每次需要对SDS进行空间扩展时，程序不仅分配SDS所必须要的空间，还会额外分配一些空间，将其大小赋值给’free’属性。如果需要分配的大小为n，额外分配的空间为e，总共分配空间为t,那么(默认单位为字节)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = n &lt; 1MB ? n:1MB</span><br><span class="line">t = n &lt; 1MB ? n + n + 1 ? n + 1MB + 1</span><br></pre></td></tr></table></figure></p>
<p>&emsp;这样的话，下次再进行字符串拼接时，额外的空间就会被使用上，从而避免额外的一次内存分配。<br>&emsp;而惰性内存回收则是指裁剪字符串时，释放出来的额外空间并不会立刻被回收，而是继续保存，只是修改<code>len</code>和’free’属性，等到字符串再次被修改时使用。</p>
<h5 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h5><p>&emsp;由于c语言字符串以’\0’来判断字符串的结束，所以无法保存一些图片，音频，视频这些可能写入’\0’的二进制数据。</p>
<h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><p>&emsp;书里的内容很简单，希望自己也可以实现一个简单的string类型吧，不过不清楚java中String对象的实现欧，以后可以了解一下。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/c/">c</a>►<a class="article-category-link" href="/categories/c/数据结构/">数据结构</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/string/">string</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/02/02/《Redis设计和实现》读书笔记1-简单动态字符串/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/02/02/《Redis设计和实现》读书笔记1-简单动态字符串/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/01/16/师者的教导/" title="师者的教导" itemprop="url">师者的教导</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2016-01-16T09:48:11.000Z" itemprop="datePublished"> Published 2016-01-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;最近一段时间,我一边在扇贝实习,一边跟着学校里的导师进行本科毕业设计.在公司里,mentor言传身教的教导我写出更简洁和具有统一风格的代码;在学校里,导师耳提面命的教导我如何一步一步的进行科研论设计.虽然很忙碌,但是却收获很多.</p>
<h4 id="做好本职工作是否足够好"><a href="#做好本职工作是否足够好" class="headerlink" title="做好本职工作是否足够好?"></a>做好本职工作是否足够好?</h4><p>&emsp;扇贝公司是一个小厂,没有测试,设计给出的设计图和标注也不时会有些问题.我之前对此也有点不满,认为不给出标注或者色值会拖延开发进度,有时为了调整一个界面的margin,padding或者字号就要花费很长时间.但是mentor却认为这对我来说是一个很好的机会.因为我之前在腾讯实习时,设计给出的界面图很规范,使用dp进行标注,并且会有不同屏幕大小的标注.但是那样就养成了一种毫不思考和关心UI设计,交互设计,只是负责把设计的界面100%的实现出来就可以啦的习惯.但是在扇贝,我们可以和设计进行交流,提出更好的界面设计.为此我特定学习了一个Google力推的Material Design风格.<strong>好的员工,一定不是只做好了本职工作</strong>.我之前总是自以为是的认为快速就实现各类需求就是很好,却完全没有思考需求中设计和产品方面的考虑.</p>
<h4 id="你思维是否有局限性"><a href="#你思维是否有局限性" class="headerlink" title="你思维是否有局限性?"></a>你思维是否有局限性?</h4><p>&emsp;本周公司举行了年会,我们android组的成员和产品组的三个妹子一起表演一段舞蹈.我们可真不是跳舞的料啊,全靠妹子带领.于是我们约定在周六下午去公司再排练一下.mentor也真是把工作上的习惯带到了舞蹈排练中啊.一开始排练,就开始定下接下来半天中每1个小时的安排和任务.不过这样确实很有效果,虽然当时听他一本正经的说每个小时任务时感到十分搞笑.然后第二天时,他又一本正经的来找我,说我们忘记了一件事情.在我正在疑惑时,他说:”我们排练时把会议室的桌子移动啦,然后排练结束后没有把它恢复原位.”.说实话,当时我的心中有一万个草泥马飞奔而过啊.不过后来想一想,mentor这些做事情的思维或者规范确实有很多好处.我们那天下午舞蹈练的就很好,然后在年会中获得表演奖第三名.<strong>做事情都是有通用技巧的,很多时候,你只是没有想到需要使用技巧去做事</strong>.举个例子吧.每天中午吃完饭,我一般都会和同事在公司打乒乓球.我技术很不好,希望多练练,逐渐打好乒乓球.但是好像我除了每天去打乒乓球之外好像再没有做什么额外的事情,没有做那些让我在练习过程中能更好的提高的事情.为什么不找个视频学习一下打乒乓球的技巧,然后再在练习中进行对应的训练呢?这样不比你每次上去胡乱打要好的多吗?生活中这样的例子很多很多.</p>
<h4 id="你的弱项在哪里-怎么办"><a href="#你的弱项在哪里-怎么办" class="headerlink" title="你的弱项在哪里?怎么办?"></a>你的弱项在哪里?怎么办?</h4><p>&emsp;最近学校里的导师带着我在做程序缺陷分析方面的研究,想依此来写一篇本科毕业论文.在这期间,我犯了很多很多错误,现在回想起来还真是不应该.而且老师也善意的支持了我的优点和缺点,认为我多在涉及缺点的方面下功夫.<br>&emsp;首先,我和导师一周见一次面,讨论这一周内项目的进展和下一周的计划.其实,这样的交谈我应该每周都做一次记录的,但是我没有,导致项目进行到一半,再回顾早期讨论的内容,很多细节都不太记得啦.<strong>很多事情,要及时做好记录,回顾,和总结</strong>.这一点也可以用在工作中.每完成一个需求,其实可以做一次总结,把期间学习到的新知识(大概就是你google搜索到的代码逻辑)和犯的错误总结一下.<br>&emsp;然后导师认为我表达能力有问题,经常无法准确表达自己的观点,而且经常让别人无法理解自己话语的含义.所以他让我需要注意一下这方面.他还认为我的动手能力和理解能力都很强,但是表达能力有限,所以经常分配一些写作任务给我(就是把实验目的,计划,方案,原理写成文章的任务),依此来训练我.<strong>知道自己的强项和弱项,并进行提升</strong><br>&emsp;上一周导师和我讨论了写论文的比较重要的步骤或者过程.首先是这个观点或者题目是否有意义,是否值得做;然后是什么样的实现数据可以支持你的观;最后是如何实验来得出数据.<strong>三个过程的重要程度依此降低,如果前边的过程出现问题,那么后边过程所付出的努力就白费啦.</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;十分感谢两位老师的教育和指导.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/杂记/">杂记</a>
</div>


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/01/16/师者的教导/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/01/16/师者的教导/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/01/01/Material-Design-标注图/" title="Material Design 标注图" itemprop="url">Material Design 标注图</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2016-01-01T10:40:33.000Z" itemprop="datePublished"> Published 2016-01-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;最近发现自己在实现产品需求时,在界面元素的细节部分把握不够准确,经常被leader告知需要微调一下界面元素的各类尺寸.虽然导致这个因素的最重要的原因是我场的设计太懒,不给标注,但是作为一个终端工程师,了解并掌握足够的设计相关的知识还是十分必要的,于是最近就开始研究其google的Material Design设计风格.<br>&emsp;本篇文章主要是收集一些MD风格的设计标注图和注意事项,主要内容都来自于<a href="http://www.uisdc.com/comprehensive-material-design-note#" target="_blank" rel="external">重磅教程！帮你全面彻底搞定MATERIAL DESIGN的学习笔记</a>.</p>
<blockquote>
<p>MD风格的精髓在于<br>把物理世界的体验带进屏幕,去掉现实的杂质和随机性,保留保留其最原始纯净的形态、空间关系、变化与过渡，配合虚拟世界的灵活特性，还原最贴近真实的体验，达到简洁与直观的效果</p>
</blockquote>
<p>&emsp;其实以我现在的理解就是:</p>
<ul>
<li>界面元素的层次性</li>
<li>交互时强调带有意义并且具有现实特性的动画</li>
<li>两种纯色作为应用的基本颜色</li>
</ul>
<p>&emsp;这篇只是收藏MD风格中关于一些特定界面元素的标注图以备以后使用</p>
<h4 id="文字排版"><a href="#文字排版" class="headerlink" title="文字排版"></a>文字排版</h4><p>常用字号：</p>
<ul>
<li>12sp 小字提示</li>
<li>14sp（桌面端13sp） 正文/按钮文字</li>
<li>16sp（桌面端15sp） 小标题</li>
<li>20sp Appbar文字</li>
<li>24sp 大标题</li>
<li>34sp/45sp/56sp/112sp 超大号文字</li>
</ul>
<p>&emsp;长篇幅正文，每行建议60字符（英文）左右。短文本，建议每行30字符（英文）左右。</p>
<h4 id="常用尺寸"><a href="#常用尺寸" class="headerlink" title="常用尺寸"></a>常用尺寸</h4><blockquote>
<p>所有可操作元素最小点击区域尺寸：48dp X 48dp。<br>  栅格系统的最小单位是8dp，一切距离、尺寸都应该是8dp的整数倍。以下是一些常见的尺寸与距离：</p>
</blockquote>
<ul>
<li>顶部状态栏高度：24dp</li>
<li>Appbar最小高度：56dp</li>
<li>底部导航栏高度：48dp</li>
<li>悬浮按钮尺寸：56x56dp/40x40dp</li>
<li>用户头像尺寸：64x64dp/40x40dp</li>
<li>小图标点击区域：48x48dp</li>
<li>侧边抽屉到屏幕右边的距离：56dp</li>
<li>卡片间距：8dp</li>
<li>分隔线上下留白：8dp</li>
<li>大多元素的留白距离：16dp</li>
<li>屏幕左右对齐基线：16dp</li>
<li><p>文字左侧对齐基线：72dp<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_a-33.png" alt="enter image description here"></p>
<h4 id="Button-sheets"><a href="#Button-sheets" class="headerlink" title="Button sheets"></a>Button sheets</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_button_sheet_1.png" alt="enter image description here"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_button_sheet_2.png" alt="enter image description here"></p>
<h4 id="Buttons"><a href="#Buttons" class="headerlink" title="Buttons"></a>Buttons</h4><p>&emsp;按钮分为悬浮按钮,凸起按钮和扁平按钮</p>
</li>
<li><p>悬浮按钮的操作都是正向操作</p>
</li>
<li>建议只用一个悬浮按钮</li>
<li>悬浮按钮可以贴在纸片边缘或者接缝处，但不要贴在对话框、侧边抽屉和菜单的边缘</li>
<li>悬浮按钮不能被其他元素盖住，也不能挡住其他按钮</li>
<li>列表滚动至底部时，悬浮按钮应该隐藏，防止它挡住列表项<br>悬浮按钮的位置不能随意摆放，可以贴着左右两边的对齐基线</li>
</ul>
<h4 id="Cards"><a href="#Cards" class="headerlink" title="Cards"></a>Cards</h4><ul>
<li>卡片统一带有2dp的圆角</li>
<li>同时展现多种不同内容</li>
<li>卡片内容之间不需要进行比较</li>
<li>包含了长度不确定的内容，比如评论</li>
<li>包含丰富的内容与操作项，比如赞、滚动条、评论</li>
<li>本该是列表，但文字超过3行</li>
<li><p>本该是网格，但需要展现更多文字<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_cards_1.png" alt="enter image description here"></p>
<h4 id="Dialogs"><a href="#Dialogs" class="headerlink" title="Dialogs"></a>Dialogs</h4></li>
<li><p>注意有些对话框点击周围会消失,但是有些是不会消失的</p>
</li>
<li><p>对话框的四周留白比较大，通常是24dp。<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_dialog_1.png" alt="enter image description here"></p>
<h4 id="Dividers"><a href="#Dividers" class="headerlink" title="Dividers"></a>Dividers</h4></li>
<li><p>列表中有头像、图片等元素时，使用内嵌分隔线，左端与文字对齐。</p>
</li>
<li>没有头像、图标等元素时，需要用通栏分隔线。</li>
<li>谨慎使用分隔线，留白和小标题也能起到分隔作用。能用留白的地方，优先使用留白。分隔线的层级高于留白。</li>
</ul>
<h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><ul>
<li><p>列表由行构成，行内包含瓦片。如果列表项内容文字超过3行，请改用卡片。如果列表项的主要区别在于图片，请改用网格。<br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_list_1.png" alt="enter image description here"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_list_2.png" alt="enter image description here"></p>
<h4 id="Pickers"><a href="#Pickers" class="headerlink" title="Pickers"></a>Pickers</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_pickers_1.png" alt="日期选择器"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_pickers_1.png" alt="时间选择器"></p>
<h4 id="Progress-amp-activity"><a href="#Progress-amp-activity" class="headerlink" title="Progress &amp; activity"></a>Progress &amp; activity</h4></li>
<li><p>进度条分为确定时间和不确定时间,不同的类型,动画效果不同</p>
</li>
<li>进度条可以使用在一些本来就有的元素上,比如悬浮按钮</li>
</ul>
<h4 id="Snackbars"><a href="#Snackbars" class="headerlink" title="Snackbars"></a>Snackbars</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_snackbars_1.png" alt="snackbars尺寸"></p>
<h4 id="Text-fields"><a href="#Text-fields" class="headerlink" title="Text fields"></a>Text fields</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_text_fields_1.png" alt="Text1"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_text_fields_2.png" alt="Text2"><br><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_text_fields_3.png" alt="Text3"></p>
<h4 id="NavigatorBar"><a href="#NavigatorBar" class="headerlink" title="NavigatorBar"></a>NavigatorBar</h4><p><img src="http://7xjsjy.com1.z0.glb.clouddn.com/MD_navigator_1.png" alt="navigator尺寸"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计/">设计</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Material-Design/">Material Design</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/01/01/Material-Design-标注图/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/01/01/Material-Design-标注图/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/12/12/Android文件存储位置简述/" title="Android文件存储位置简述" itemprop="url">Android文件存储位置简述</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-12-12T09:11:54.000Z" itemprop="datePublished"> Published 2015-12-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emsp;最近一段时间,工作和学习方面都比较忙,所以,博客方面有一段时间没有投入时间啦,今天学习了一下android文件存储方面的知识,主要是<code>Internal Storage</code>和<code>External Storage</code>的相关特性.主要知识来自android的官方文档和其他人的博客.</p>
<h4 id="Internal-Storage"><a href="#Internal-Storage" class="headerlink" title="Internal Storage"></a>Internal Storage</h4><p>&emsp;一般来说,你可以直接存储文件在机器的internal storage中,存储在这个位置的文件是私有的,其他应用无法获得.但是当用户卸载你的应用时,文件就被删除啦.</p>
<blockquote>
<p>通过<code>openFileOutput()</code>传入文件的名字和操作模式,就可以获得<code>FileOutputStream</code>,然后就可以<code>write()</code>,然后<code>close</code>啦.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String FILENAME = <span class="string">"hello_file"</span>;</span><br><span class="line">String string = <span class="string">"hello world!"</span>;</span><br><span class="line"></span><br><span class="line">FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);</span><br><span class="line">fos.write(string.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure></p>
<p><code>MODE_PRIVATE</code>模式会创建或者替换同名文件,并让文件变为私有的,其他的一些模式还有<code>MODE_APPEND</code>(追加模式),<code>MODE_WORLD_READABLE</code>(全局可读)和<code>MODE_WORLD_WRITEABLE</code>(全局可写).<br>通过<code>OpenFileInput()</code>函数可以进行文件的读取.</p>
</blockquote>
<p>&emsp;Android的内部存储路径为/data/data/packagename/,加入你的应用名为com.example.test,那么这个路径就为/data/data/com.example.test,这个路径下一般会有files,cache和你自己生成的文件夹.那么如下的操作返回的路径如下</p>
<ul>
<li>Context.getFileDir(),获得/data/data/com.example.test/files这个文件夹的File对象</li>
<li>Context.openFileInput()和Context.openFileOutput,读取的是files文件夹下的文件</li>
<li>Context.fileList(),返回的是files下的所有文件名</li>
<li>Context.deleteFile(),删除files下指定名称的文件</li>
<li>Context.getCacheDir(),该方法返回的是/data/data/com.example.test/cache的File对象.当Android的内部存储容量过低时,android会自动清除缓存文件.</li>
<li>getDir(String name,int mode),返回的是/data/data/com.example.test/下指定名称的文件夹的File对象</li>
</ul>
<h4 id="External-Storage"><a href="#External-Storage" class="headerlink" title="External Storage"></a>External Storage</h4><p>&emsp;所有android设备都会提供外部存储,你可以用来保存文件,但是存储在外部存储的文件是完全公开的,并且可以被用户修改,外部存储可能无法获得,并且存储的文件的安全性很低,会被修改或者删除.<br>&emsp;获得    外部存储的访问权必须需要申请<code>READ_EXTERNAL_STORAGE</code>或者<code>WRITE_EXTERNAL_STORAGE</code>权限,如果申请了写权限,那么相应的读权限也获得啦.如果是Android 6.0,那么权限的申请可能就更加麻烦 :<a href="http://jijiaxin89.com/2015/08/30/Android-s-Runtime-Permission/" target="_blank" rel="external">6.0新的权限管理系统</a><br>&emsp;在使用外部存储设备之前,必须先检查外部存储设备的挂载情况,然后再进行文件操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Checks if external storage is available for read and write */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExternalStorageWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Checks if external storage is available to at least read */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExternalStorageReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state) ||</span><br><span class="line">        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;如果你想存储一些可以和其他应用共享的文件时,一般存储在共享的文件夹中,比如<code>Music/</code>,’Pictures/‘,’Ringtones/‘通过<code>Environment.getExternalStoragePublicDirectory</code>,传递给其文件夹的类型,比如<code>DIRECTORY_MUSIC</code>,<code>DIRECTORY_PICTURES</code>,就可以获得响应文件夹的File对象.<br>&emsp;当你不想其他应用读取你的文件时,你可能需要使用私有文件夹.通过<code>getExternalFilesDir()</code>,并传递给其子文件夹的type,就可以打开响应的文件夹,在4.4之后,读取私有文件夹下的文件,是不需要外部存储设备权限的.<br>&emsp;外部存储设备的路径一般都以/mnt/sdcard开始,如下的一些函数获得路径如下:</p>
<ul>
<li>getExternalCacheDir() 获得/mnt/sdcard/Android/data/com.example.test/cache 文件夹的File对象</li>
<li>getExternalFilesDir(type)获得/mnt/sdcard/Android/data/com.example.test/files文件夹下响应子文件夹的File对象</li>
<li>Environment.getExternalStorageDiretory() 获得的是/mnt/sdcard文件夹的File对象</li>
<li>Environment.getDataDirectory() 获得是的/data文件夹的File对象,需要注意的是,/data/data/Android/就是内部存储文件夹啦.</li>
<li>Environment.getDownloadCacheDirectory() 获得的是/cache文件夹的File对象.</li>
</ul>
<p>参考文章:</p>
<ul>
<li><a href="http://blog.csdn.net/ljh347917444/article/details/16984199" target="_blank" rel="external">android 系统文件路径.sdcard路径.外部路径</a> </li>
<li><a href="http://developer.android.com/intl/zh-cn/guide/topics/data/data-storage.html#filesInternal" target="_blank" rel="external">Android Doc</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/文件系统/">文件系统</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/12/12/Android文件存储位置简述/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/12/12/Android文件存储位置简述/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/18/OkHttp解析系列-重定向和出错重试/" title="OkHttp解析系列-重定向和出错重试" itemprop="url">OkHttp解析系列-重定向和出错重试</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="remCarpediem" target="_blank" itemprop="author">remCarpediem</a>
		
  <p class="article-time">
    <time datetime="2015-11-18T14:00:10.000Z" itemprop="datePublished"> Published 2015-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>&emps;这是OkHttp系列博文的第一篇，之前写过一篇草稿，介绍OkHttp的整体框架，但是感觉涉及的知识太多，无法在一篇中讲述清楚，所以，之后的博文都只关注某一方面的知识，争取文章短小精悍。<br>&emsp;今天主要研究一下OkHttp发送<code>Http</code>请求过程中的重定向和出错重试，主要涉及的源码文件有<code>Call.java``HttpEngine.java</code>。<br>&emsp;我们今天研究<code>Call</code>的<code>Response getResponse(Request request, boolean forWebSocket) throws IOException</code>函数，它是你调用<code>Call.execute()</code>返回<code>Response</code>所调用的核心函数，主要功能是新建一个<code>HttpEngine</code>发送<code>Request</code>然后处理出错重试和重定向问题。</p>
<h4 id="设置Headers"><a href="#设置Headers" class="headerlink" title="设置Headers"></a>设置Headers</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy body metadata to the appropriate request headers.</span></span><br><span class="line">  RequestBody body = request.body();</span><br><span class="line">  <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Request.Builder requestBuilder = request.newBuilder();<span class="comment">//拷贝了内部数据</span></span><br><span class="line"></span><br><span class="line">    MediaType contentType = body.contentType();</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">    <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request = requestBuilder.build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;这是函数的第一部分，主要是将<code>RequestBody</code>的一些元数据拷贝到<code>Header</code>的首部中,主要是<code>Content-Type</code>和<code>Transfer-Encoding</code>。<code>Content-Type</code>相信大家都了解，标示<code>RequestBody</code>的<code>Mime-Type</code>，格式为<code>主类型/子类型</code>，比如<code>text/xml</code>。而<code>Transfer-Encoding</code>是表示一种网络传输的方式，想具体了解的同学可以看一下这个链接<a href="https://imququ.com/post/transfer-encoding-header-in-http.html" target="_blank" rel="external">点我</a>.</p>
<h4 id="出错重试"><a href="#出错重试" class="headerlink" title="出错重试"></a>出错重试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the initial HTTP engine. Retries and redirects need new engine for each attempt.</span></span><br><span class="line">    <span class="comment">// 建立一个初始的http 引擎，每次重试和重定向都需要新的引擎</span></span><br><span class="line">    engine = <span class="keyword">new</span> HttpEngine(client, request, <span class="keyword">false</span>, <span class="keyword">false</span>, forWebSocket, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>; <span class="comment">//连续发送请求</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (canceled) &#123; <span class="comment">//如果被取消啦</span></span><br><span class="line">        engine.releaseConnection();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        engine.sendRequest();</span><br><span class="line">        engine.readResponse();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RequestException e) &#123;</span><br><span class="line">        <span class="comment">// The attempt to interpret the request failed. Give up.</span></span><br><span class="line">        <span class="keyword">throw</span> e.getCause();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        HttpEngine retryEngine = engine.recover(e); <span class="comment">//重试引擎</span></span><br><span class="line">        <span class="keyword">if</span> (retryEngine != <span class="keyword">null</span>) &#123;</span><br><span class="line">          engine = retryEngine;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Give up; recovery is not possible.</span></span><br><span class="line">        <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        HttpEngine retryEngine = engine.recover(e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (retryEngine != <span class="keyword">null</span>) &#123;</span><br><span class="line">          engine = retryEngine;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Give up; recovery is not possible.</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">      .......</span><br></pre></td></tr></table></figure>
<p>&emsp;在这段代码中，<code>OkHttp</code>建立一个<code>HttpEngine</code>对象来负责<code>Http</code>层级的请求的发送和回复的接收，<code>HttpEngine</code>会在之后的博文中详细讲解。然后进入了一个<code>while</code>循环,这个循环其实主要是处理重定向问题的。我们在这一节中主要关注<code>catch</code>中的逻辑，这是用于处理出错重试的逻辑。由于外层有一个<code>while</code>循环，所以在<code>catch</code>中尝试获得<code>retryEngine</code>，如果有就<code>continue</code>,没有就抛出异常。</p>
<h4 id="重定向处理"><a href="#重定向处理" class="headerlink" title="重定向处理"></a>重定向处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Response response = engine.getResponse();</span><br><span class="line">      <span class="comment">// followUp这个是优化http connection的使用率的吗？</span></span><br><span class="line">      Request followUp = engine.followUpRequest();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!forWebSocket) &#123; <span class="comment">//如果没有followup并且不是为了websocket</span></span><br><span class="line">          engine.releaseConnection();<span class="comment">//关闭连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!engine.sameConnection(followUp.httpUrl())) &#123; <span class="comment">//如果followup的httpUrl不是同一个连接,也就是</span></span><br><span class="line">        <span class="comment">//schema，host or port 有一个不同</span></span><br><span class="line">        engine.releaseConnection();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//复用了上一次的connection啊！！！！</span></span><br><span class="line">      Connection connection = engine.close();</span><br><span class="line">      request = followUp;</span><br><span class="line">      <span class="comment">//继续处理，有可能是重定向啦</span></span><br><span class="line">      engine = <span class="keyword">new</span> HttpEngine(client, request, <span class="keyword">false</span>, <span class="keyword">false</span>, forWebSocket, connection, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">          response);</span><br></pre></td></tr></table></figure>
<p>&emsp;这里我们可以看到<code>Http</code>重定向的机制。<code>Request request = engine.followUpRequest()</code>来获得重定向需要发送的<code>Request</code>，如果没有或者重定向次数大于<code>MAX_FOLLOW_UPS</code>就不会重新发送重定向请求。然后判断重定向请求和原请求的HttpUrl是否相同，否则也不会发送重定向请求。然后<code>Connection connection = engine.close()</code>会释放资源并且复用上次的连接，然后新建一个<code>HttpEngine</code>然后继续<code>While</code>循环发送请求。</p>
<h4 id="重定向状态码解析"><a href="#重定向状态码解析" class="headerlink" title="重定向状态码解析"></a>重定向状态码解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">followUpRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (userResponse == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  Proxy selectedProxy = getRoute() != <span class="keyword">null</span></span><br><span class="line">      ? getRoute().getProxy()</span><br><span class="line">      : client.getProxy();</span><br><span class="line">  <span class="keyword">int</span> responseCode = userResponse.code();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (responseCode) &#123;</span><br><span class="line">    <span class="keyword">case</span> HTTP_PROXY_AUTH: <span class="comment">//407 Proxy authentication required 要先经过代理服务器认证</span></span><br><span class="line">      <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// fall-through</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_UNAUTHORIZED: <span class="comment">//401 没有身份认证</span></span><br><span class="line">      <span class="keyword">return</span> OkHeaders.processAuthHeader(client.getAuthenticator(), userResponse, selectedProxy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> HTTP_PERM_REDIRECT:<span class="comment">// 308</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_TEMP_REDIRECT: <span class="comment">//307</span></span><br><span class="line">      <span class="comment">// "If the 307 or 308 status code is received in response to a request other than GET</span></span><br><span class="line">      <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span></span><br><span class="line">      <span class="keyword">if</span> (!userRequest.method().equals(<span class="string">"GET"</span>) &amp;&amp; !userRequest.method().equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="comment">//如果不是get和head 那么就不能自动转发</span></span><br><span class="line">      <span class="comment">// fall-through</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_MULT_CHOICE: <span class="comment">//300</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_MOVED_PERM:<span class="comment">// 301</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_MOVED_TEMP:<span class="comment">//302</span></span><br><span class="line">    <span class="keyword">case</span> HTTP_SEE_OTHER: <span class="comment">//303</span></span><br><span class="line">      <span class="comment">// Does the client allow redirects?</span></span><br><span class="line">      <span class="keyword">if</span> (!client.getFollowRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//如果不允许重定向</span></span><br><span class="line"></span><br><span class="line">      String location = userResponse.header(<span class="string">"Location"</span>);<span class="comment">//从response的头部获得的location</span></span><br><span class="line">      <span class="keyword">if</span> (location == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      HttpUrl url = userRequest.httpUrl().resolve(location);<span class="comment">//使用request的解析location</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Don't follow redirects to unsupported protocols.</span></span><br><span class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If configured, don't follow redirects between SSL and non-SSL.</span></span><br><span class="line">      <span class="keyword">boolean</span> sameScheme = url.scheme().equals(userRequest.httpUrl().scheme());</span><br><span class="line">      <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.getFollowSslRedirects()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Redirects don't include a request body.</span></span><br><span class="line">      Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.permitsRequestBody(userRequest.method())) &#123;</span><br><span class="line">        requestBuilder.method(<span class="string">"GET"</span>, <span class="keyword">null</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Type"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></span><br><span class="line">      <span class="comment">// is potentially annoying to the application layer since they have no</span></span><br><span class="line">      <span class="comment">// way to retain them.</span></span><br><span class="line">      <span class="keyword">if</span> (!sameConnection(url)) &#123;</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Authorization"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> requestBuilder.url(url).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;这一段就是根据回复的状态码生成重定向请求的代码逻辑。</p>
<ul>
<li>HTTP_PROXY_AUTH 407  表示需要经过代理服务器认证 ，这时抛出异常，不进行重定向</li>
<li>HTTP_UNAUTHORIZED 401 身份未认证</li>
<li>HTTP_PERM_REDIRECT 308 HTTP_TEMP_REDIRECT 307 这两种状态码时，只有当请求的<code>method</code>不为<code>GET</code>和<code>HEAD</code>时不进行重定向，否则按照下边一列状态码的方式处理</li>
<li>HTTP_MULT_CHOICE  300 HTTP_MOVED_PERM 301 HTTP_MOVED_TEMP 302 HTTP_SEE_OTHER 303 当是这些状态码时，先判断是否运行重定向，然后获得<code>Response</code>中的<code>Location</code>首部的值，然后用<code>HttpUrl</code>去解析，如果是<code>host</code>不同，那么去掉所有的认证首部，这是为了安全。<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4>&emsp;今天所总结的只是<code>Http</code>的重定向部分和<code>OkHttp</code>中的关于重定向的逻辑部分。之后会陆陆续续的继续总结关于<code>Http</code>的知识。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/NetWork/">NetWork</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/OkHttp/">OkHttp</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/18/OkHttp解析系列-重定向和出错重试/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/18/OkHttp解析系列-重定向和出错重试/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/3/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android/" title="Android">Android<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android性能/" title="Android性能">Android性能<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/NIO/" title="NIO">NIO<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/NetWork/" title="NetWork">NetWork<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/Network/" title="Network">Network<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Python/" title="Python">Python<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/c/" title="c">c<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/python/" title="python">python<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/函数式编程/" title="函数式编程">函数式编程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/分布式/" title="分布式">分布式<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/并发/" title="并发">并发<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/思考/" title="思考">思考<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/c/数据结构/" title="数据结构">数据结构<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/杂记/" title="杂记">杂记<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/杂记/" title="杂记">杂记<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/源码/" title="源码">源码<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android/源码分析/" title="源码分析">源码分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/杂记/生活/" title="生活">生活<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/综合/" title="综合">综合<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/网络/" title="网络">网络<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/源码/视图/" title="视图">视图<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/计划/" title="计划">计划<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/设计/" title="设计">设计<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/读书笔记/" title="读书笔记">读书笔记<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/随笔/" title="随笔">随笔<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/第三方库/" title="第三方库">第三方库<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/JUC/" title="JUC">JUC<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/注解/" title="注解">注解<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Netty/" title="Netty">Netty<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/scroll/" title="scroll">scroll<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/TCP-IP/" title="TCP/IP">TCP/IP<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/OkHttp/" title="OkHttp">OkHttp<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Span/" title="Span">Span<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/事件传递/" title="事件传递">事件传递<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/View/" title="View">View<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/反射/" title="反射">反射<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/JSON/" title="JSON">JSON<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GSON/" title="GSON">GSON<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Material-Design/" title="Material Design">Material Design<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/MotionEvent/" title="MotionEvent">MotionEvent<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/epoll/" title="epoll">epoll<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/市场/" title="市场">市场<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/animation/" title="animation">animation<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/工具/" title="工具">工具<sup>1</sup></a></li>
			
		
		</ul>
</div>


  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> Hello ,I&#39;m Homer in NJU. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="remCarpediem">remCarpediem</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-88918565-1', 'ztelur.github.io/');
ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?8a8af29a4307eee9d7c7f8e9321aedae";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260989317'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1260989317' type='text/javascript'%3E%3C/script%3E"));</script>




<!-- baidu search 推送-->
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
