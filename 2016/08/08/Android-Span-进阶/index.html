<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">

<head>
  <meta charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <title>Android  Span 进阶 | 程序员历小冰</title>
  <meta name="description" content="remcarpediem" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="&amp;emsp;在上篇文章《Android Span 架构介绍》，我们讲述了Android Span的基本概念和用法，这篇文章我们就来扩展一下我们对Android Span的了解，这一定会使你感到惊奇的，惊叹Android Span竟然还能完成这些的效果，让你在Android自定义View和动画方面有更加深刻的理解，可能会帮助你你想出更加简洁的实现方式。&amp;emsp;本篇文章主要讲述一下两个方面的内容:">
<meta name="keywords" content="Span">
<meta property="og:type" content="article">
<meta property="og:title" content="Android  Span 进阶">
<meta property="og:url" content="http://remcarpediem.net/2016/08/08/Android-Span-进阶/index.html">
<meta property="og:site_name" content="程序员历小冰">
<meta property="og:description" content="&amp;emsp;在上篇文章《Android Span 架构介绍》，我们讲述了Android Span的基本概念和用法，这篇文章我们就来扩展一下我们对Android Span的了解，这一定会使你感到惊奇的，惊叹Android Span竟然还能完成这些的效果，让你在Android自定义View和动画方面有更加深刻的理解，可能会帮助你你想出更加简洁的实现方式。&amp;emsp;本篇文章主要讲述一下两个方面的内容:">
<meta property="og:locale" content="Chinese">
<meta property="og:image" content="http://7xrxif.com1.z0.glb.clouddn.com/20160808-Span-FireWorkSpan.gif">
<meta property="og:image" content="http://7xrxif.com1.z0.glb.clouddn.com/20160808-Span-MutiableForegroundSpan.gif">
<meta property="og:image" content="http://7xrxif.com1.z0.glb.clouddn.com/20160808-Span-BuddleSpan.png">
<meta property="og:image" content="http://7xrxif.com1.z0.glb.clouddn.com/20160808-Span-RectSpan.png">
<meta property="og:updated_time" content="2018-11-18T13:40:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android  Span 进阶">
<meta name="twitter:description" content="&amp;emsp;在上篇文章《Android Span 架构介绍》，我们讲述了Android Span的基本概念和用法，这篇文章我们就来扩展一下我们对Android Span的了解，这一定会使你感到惊奇的，惊叹Android Span竟然还能完成这些的效果，让你在Android自定义View和动画方面有更加深刻的理解，可能会帮助你你想出更加简洁的实现方式。&amp;emsp;本篇文章主要讲述一下两个方面的内容:">
<meta name="twitter:image" content="http://7xrxif.com1.z0.glb.clouddn.com/20160808-Span-FireWorkSpan.gif">
  <!-- build:css css/screen.css -->

  <link rel="stylesheet" href="/css/screen.css">
  <link rel="stylesheet" href="/css/prism.css">
  
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  
  <!-- endbuild -->
  
  <!-- build:css fancybox/jquery.fancybox.css -->
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <!-- endbuild -->
  
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
  <meta name="generator" content="程序员历小冰">
  
  
  
<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css"></head>


<body class="post-template">

  <div class="nav">
  <h3 class="nav-title">Home</h3>
  <a href="#" class="nav-close">
    <span class="hidden">Close</span>
  </a>
  <ul>
    <li class="nav-home" role="presentation"><a href="/">Home</a></li>
    <!-- <li class="nav-about {% if page.current == 'about' %} nav-current{% endif %}" role="presentation"><a href="{{ site.baseurl }}about">About</a></li>
    <li class="nav-author {% if page.current == 'author' %} nav-current{% endif %}" role="presentation"><a href="{{ site.baseurl }}author/casper">Author</a></li> -->
    <li class="nav-ios" role="presentation"><a href="/archives">Archives</a></li>
  </ul>
  <a class="subscribe-button icon-feed" href="{{ site.baseurl }}feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>

  <div class="site-wrapper">
  <header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        <a class="back-button icon-arrow-left" href="/">Home</a>
        <!-- <a class="subscribe-button icon-feed" href="/atom.xml">Subscribe</a> -->
        <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
    </nav>
    
    <a class="scroll-down icon-arrow-left" href="#content" data-offset="-45"><span class="hidden">Scroll Down</span></a>
</header>

  

<main id="content" class="content" role="main">
  <article class="post" itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting">
    <header class="post-header">
      <h1 class="post-title" itemprop="name">Android  Span 进阶</h1>
      <section class="post-meta">
  <time datetime="2016-08-08T13:25:54.000Z" itemprop="datePublished" class="post-date">
      2016-08-08
  </time>
  
  
  
  <a href="/tags/Span/">Span</a>
  
  
</section>

    </header>
    <section class="post-content" itemprop="description articleBody">
      

      <!-- 
      <section class="post-updated">
  Last updated on <time datetime="2018-11-18T13:40:01.000Z" itemprop="dateModified">
      2018-11-18
  </time>
</section>

       -->
      <p>&emsp;在上篇文章<a href="http://blog.csdn.net/u012422440/article/details/52133037" target="_blank" rel="noopener">《Android Span 架构介绍》</a>，我们讲述了Android Span的基本概念和用法，这篇文章我们就来扩展一下我们对Android Span的了解，这一定会使你感到惊奇的，惊叹Android Span竟然还能完成这些的效果，让你在Android自定义View和动画方面有更加深刻的理解，可能会帮助你你想出更加简洁的实现方式。<br>&emsp;本篇文章主要讲述一下两个方面的内容:</p>
<ul>
<li>自定义Android Span</li>
<li>使用Android Span实现动画</li>
</ul>
<p>&emsp;先贴一下本篇文章实现的自定义Span和动画的效果图<br><img src="http://7xrxif.com1.z0.glb.clouddn.com/20160808-Span-FireWorkSpan.gif" alt="demo"></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/20160808-Span-MutiableForegroundSpan.gif" alt="demo"></p>
<h4 id="自定义Span"><a href="#自定义Span" class="headerlink" title="自定义Span"></a>自定义Span</h4><p>&emsp;我们都知道，自定义View有两种方式，一种是继承特定的视图类,比如你希望修改<code>TextView</code>的行为，所以继承了<code>TextView</code>;另一种就是直接继承<code>View</code>或者<code>ViewGroup</code>,这样可以实现全新的视图和行为。如同自定义View一样，你有两种自定义Span的方法，一种直接继承特定类型的Span类，比如<code>ForegroundColorSpan</code>等，这样你可以在这些类的基础上进行修改；另一种就是继承<code>ReplaceSpan</code>这样的抽象类或者实现<code>LetterLineBackgroundSpan</code>这样的接口，你只要实现它给出的接口，就可以实现新的效果。<br>&emsp;我们先来讲解第一种方式。直接继承现有的<code>Span</code>。文章开头时展示的<code>ActionBar</code>动画就是通过继承<code>ForegroundSpan</code>来实现的。<br>&emsp;我们主要重载了<code>updateDrawsState</code>和<code>getForegroundColor</code>,这样就可以通过改变<code>setAlpha</code>函数来改变颜色，让字体从透明(alpha为0)到某个特定颜色。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public class MutableForegroundColorSpan extends ForegroundColorSpan {
    private int mAlpha = 255;
    private int mForegroundColor;
    public MutableForegroundColorSpan(int alpha,int color) {
        super(color);
        mAlpha = alpha;
        mForegroundColor = color;
    }
    @Override
    public void updateDrawState(TextPaint ds) {
        ds.setColor(getForegroundColor());
    }
    public void setAlpha(int alpha) {
        mAlpha = alpha;
    }
    public void setForegroundColor(int foregroundColor) {
        mForegroundColor = foregroundColor;
    }
    public float getAlpha() {
        return mAlpha;
    }
    @Override
    public int getForegroundColor() {
        return Color.argb(mAlpha,Color.red(mForegroundColor),Color.green(mForegroundColor),Color.blue(mForegroundColor));
    }
}
</code></pre></p>
<p>&emsp;第二种方法是继承<code>Span</code>架构中的抽象类或者是实现特定接口。需要注意的是，在上一篇文章中说的<code>CharacterStyle</code>,<code>ParagraphStyle</code>.<code>UpdateAppearance</code>和<code>UpdateLayout</code>都是没有函数的，所以，我们无法直接继承或者实现它们。除了第一篇文章中所介绍的那些<code>Span</code>可以使用第一种方法进行继承。我们一般都继承或者实现<code>MetricAffectingSpan</code>,<code>ReplacementSpan</code>或者<code>LineBackgroundSpan</code>。<br>&emsp;比如我们想给每个字都添加一个不同颜色的背景，我们就可以继承<code>ReplacementSpan</code></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/20160808-Span-BuddleSpan.png" alt="demo"></p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public class BubbleSpan extends ReplacementSpan {
    private Paint mPaint;
    static Random random = new Random();
    private int mWidth = -1;
    private RectF mRectF = new RectF();

    private int[] mColors = new int[20];

    public BubbleSpan() {
        initPaint();
        initColors();
    }

    private void initPaint() {
        mPaint = new Paint();
        mPaint.setColor(Color.rgb(random.nextInt(255), random.nextInt(255), random.nextInt(255)));
        mPaint.setAntiAlias(true);
    }

    private void initColors() {
        for(int index = 0 ; index &lt; mColors.length ; index++) {
            mColors[index] = Color.rgb(random.nextInt(255), random.nextInt(255), random.nextInt(255));
        }
    }

    @Override
    public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) {
        &#x2F;&#x2F;return text with relative to the Paint
		mWidth = (int) paint.measureText(text, start, end);
        return mWidth;
    }

    @Override
    public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) {
        float charx = x;
        for(int i = start ; i&lt;end; i++) {
            String charAt = extractText(text, i, i + 1);
            float charWidth = paint.measureText(charAt);
            mRectF.set(charx, top, charx += charWidth, bottom);
            mPaint.setColor(mColors[i % mColors.length]);
            &#x2F;&#x2F;根据每个字的位置绘制背景
            canvas.drawOval(mRectF, mPaint);
        }
        &#x2F;&#x2F;绘制字体，如果不掉用这个函数，就不会显示字体啦。
        canvas.drawText(text, start, end, x, y, paint);
    }

    private String extractText(CharSequence text, int start, int end) {
        return text.subSequence(start, end).toString();
    }
}
</code></pre>
<p>&emsp;我们可以看到，我们要实现两个函数:<code>getSize</code>和<code>draw</code>。<code>getSize</code>是获得字体的长度的，所以一般都是直接使用<code>paint.measureText</code>,然后<code>draw</code>中进行绘制，你可以在这里把每个字的背景绘制出来，而且你必须也要把字体给绘制出来。如果你只想绘制背景，不想涉及字体的绘制，那么就可以直接实现<code>LineBackgroundSpan</code>接口。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public class RectSpan extends ReplacementSpan {
    private final Paint mPaint;
    private int mWidth;

    public RectSpan() {
        mPaint = new Paint();
        mPaint.setStyle(Paint.Style.STROKE);
        mPaint.setColor(Color.BLUE);
        mPaint.setAntiAlias(true);
    }

    @Override
    public int getSize(Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) {
        &#x2F;&#x2F;return text with relative to the Paint
        mWidth = (int) paint.measureText(text, start, end);
        return mWidth;
    }

    @Override
    public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) {
        &#x2F;&#x2F;只绘制了外围矩形，没有绘制文字。
        canvas.drawRect(x, top, x + mWidth, bottom, mPaint);
    }
}
</code></pre></p>
<p><img src="http://7xrxif.com1.z0.glb.clouddn.com/20160808-Span-RectSpan.png" alt="demo"></p>
<h4 id="通过Span实现动画"><a href="#通过Span实现动画" class="headerlink" title="通过Span实现动画"></a>通过Span实现动画</h4><p>&emsp;在上一节中，我们已经实现了<code>MutableForegroundColorSpan</code>类，那么如何使用它来实现动画呢？这里我们就要使用到<code>ObjectAnimator</code>和<code>Property&lt;T1,T2&gt;</code>。我们首先定义<code>MutableForegroundColorSpan</code>使用的<code>property</code>。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">private static final Property&lt;MutableForegroundColorSpan, Integer&gt; MUTABLE_FOREGROUND_COLOR_SPAN_PROPERTY =
        new Property&lt;MutableForegroundColorSpan, Integer&gt;(Integer.class, &quot;MUTABLE_FOREGROUND_COLOR_SPAN_FC_PROPERTY&quot;) {

        @Override
                public void set(MutableForegroundColorSpan alphaForegroundColorSpanGroup, Integer value) {
                        alphaForegroundColorSpanGroup.setForegroundColor(value);
                }

        @Override
                public Integer get(MutableForegroundColorSpan span) {
                        return span.getForegroundColor();
                }
};
</code></pre></p>
<p>&emsp;然后我们就可以使用<code>ObjectAnimator</code>对<code>MutableForegroundColorSpan</code>实现属性动画了。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">MutableForegroundColorSpan span = new MutableForegroundColorSpan(255, Color.BLUE);
final SpannableString spannableString = new SpannableString(CONTENT);
spannableString.setSpan(span, 0,4, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
ObjectAnimator objectAnimator = ObjectAnimator.ofInt(span, MUTABLE_FOREGROUND_COLOR_SPAN_PROPERTY, Color.BLACK, Color.RED);
objectAnimator.setEvaluator(new ArgbEvaluator());
objectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
        &#x2F;&#x2F;refresh
                mTvTextView.setText(spannableString);
        }       
});
objectAnimator.setInterpolator(mSmoothInterpolator);
objectAnimator.setDuration(600);
objectAnimator.start();
</code></pre></p>
<p>&emsp;这里还只是单独一个<code>Span</code>实例的动画效果，你可以对多个Span实例进行属性动画，从而实现更加复杂的动画效果。就比如文章开始时的文字逐渐显示的动画效果。<br>&emsp;我们可以给每个字都设置一个<code>MutableForegroundColorSpan</code>实例,并将这些实例都添加到一个对象中，然后在属性动画过程中，乱序设置每个实例的<code>alpha</code>的值，从而达到文字逐渐显现的动画。<br>
<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-clike">public class FireWorkGroup {
    private final float mProgress;
    private final ArrayList&lt;MutableForegroundColorSpan&gt; mSpans;
    private final ArrayList&lt;Integer&gt; mSpanIndexes;

    public FireWorkGroup() {
        mProgress = 0;
        mSpans  = new ArrayList&lt;&gt;();
        mSpanIndexes = new ArrayList&lt;&gt;();
    }

    public void addSpan(MutableForegroundColorSpan span) {
        span.setAlpha(0);
        mSpanIndexes.add(mSpans.size());
        mSpans.add(span);
    }
    public void init() {
        Collections.shuffle(mSpans);
    }
    public void setProgress(float progress) {
        int size = mSpans.size();
        float total  = 1.0f * size * progress;
        for (int index = 0 ; index &lt; size ; index++) {
            MutableForegroundColorSpan span = mSpans.get(index);
            if (total &gt; 1.0f) {
                span.setAlpha(255);
                total -= 1.0f;
            } else {
                span.setAlpha((int)(total * 255));
                total = 0.0f;
            }
        }
    }
    public float getProgress() {
        return mProgress;
    }
    public static final Property&lt;FireWorkGroup, Float&gt; FIREWORKS_GROUP_PROGRESS_PROPERTY =
            new Property&lt;FireWorkGroup, Float&gt;(Float.class, &quot;FIREWORKS_GROUP_PROGRESS_PROPERTY&quot;) {

                @Override
                public void set(FireWorkGroup spanGroup, Float value) {
                    spanGroup.setProgress(value);
                }

                @Override
                public Float get(FireWorkGroup spanGroup) {
                    return spanGroup.getProgress();
                }
            };
}
</code></pre></p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>&emsp;上述的这些动画都是我在第一篇文章提到的那篇博文中实现过的效果，我在学习过程中又发现了一个实现了很多<code>TextView</code>相关动画的开源项目<a href="https://github.com/hanks-zyh/HTextView" target="_blank" rel="noopener">HTextView</a>。所以接下来的任务就是想使用<code>Span</code>机制去实现这个项目中的一些动画效果。希望大家继续支持我的文章，并积极指出文中的错误。<br>&emsp;!!!源码都在<a href="https://github.com/ztelur/AndroidSpan" target="_blank" rel="noopener">我的github</a>里。</p>

      <h3>关于图片和转载</h3>

      <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png"></a><br>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。

      转载时请注明原文链接，图片在使用时请保留图片中的全部内容，可适当缩放并在引用处附上图片所在的文章链接。

      <h3>关于评论和留言</h3>

      如果对本文 <a href="http://remcarpediem.net/2016/08/08/Android-Span-进阶/">Android  Span 进阶</a> 的内容有疑问，请在下面的评论系统中留言，谢谢。

      <blockquote>
        <p>原文链接：<a href="http://remcarpediem.net/2016/08/08/Android-Span-进阶/">Android  Span 进阶</a></p>

        <p>Follow: <a href="https://github.com/ztelur">Ztelur · GitHub</a></p>
      </blockquote>

    </section>
    <footer class="post-footer">
     
        <figure class="author-image">
          <a class="img" href="https://github.com/ztelur" style="background-image: url(https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1543337069412&di=609213db44c3240a091b26f82707da85&imgtype=0&src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farchive%2F65b2fd9d9a84c14f4a712ed0d71b0fbb67dcbf2d.jpg)"><span class="hidden">历小冰's Picture</span></a>
        </figure>
     
      <section class="author">
        <h4><a href="https://github.com/ztelur">历小冰</a></h4>
        
        <p> 君子不器</p>
         
        <div class="author-meta">
          <span class="author-location icon-location"> NanJing</span> 
          <span class="author-link icon-link"><a href="http://remcarpediem.net"> 程序员历小冰</a></span> 
        </div>
</section>
      <!--<section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" href="http://twitter.com/share?url=http://remcarpediem.net/2016/08/08/Android-Span-进阶/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://remcarpediem.net/2016/08/08/Android-Span-进阶/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=http://remcarpediem.net/2016/08/08/Android-Span-进阶/" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section>-->
      
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<script>
    const gitalk = new Gitalk({
    clientID: 'ece2d2cd7c5f768a4c22',
    clientSecret: '1ad562557353b888b4b622239d45150c5df6d5ee',
    repo: 'blog-comments',
    owner: 'ztelur',
    admin: ['ztelur'],
    // labels: ['Gitalk', 'gitment'].concat(["{{ page.tags | join: '","'}}"]),
    // id: location.origin + location.pathname,
    id: md5("http://remcarpediem.net/2016/08/08/Android-Span-进阶/"),
    // facebook-like distraction free mode
    distractionFreeMode: false
});

gitalk.render('gitalk-container')
</script>

    </footer>
  </article>
</main>
<aside class="read-next">
 
    
    <a class="read-next-story no-cover" href="/2016/08/05/Android-Span-架构介绍/">
      <section class="post">
        <h2>Android Span 架构介绍</h2>
        <p>
            
              &emsp;前几天在微博上看到一个人评论Android Span机制相当强大，有必要细心研究一下，于是就google了一下，发现了一篇很好的文章Spans, a Powerful Concept.，然后以这篇文章为基础研究了一下Android Span的用法。于是决定写几篇文章来总结一下。
Android Span 介绍&emsp;对于Span，大家首先想起的应用场景就是同一个TextView中显示不同颜色的字体。对于这种需求，我们会用 ......
            
          </p>
      </section>
    </a>
    
  


  
    
    <a class="read-next-story no-cover" href="/2016/08/26/Android-图像处理-一-Shader/">
      <section class="post">
        <h2>Android 图像处理(一) : Shader</h2>
        <p>
            
              &emsp;之前一段时间，我都在研究Android自定义View的相关知识，随着逐渐的深入，渐渐了解到了一些Android图像处理的知识，主要是Bitmap,Canvas,Shader,Matric,ColorFilter和Xfermode的使用。所以准备写一系列文章介绍一下这些方面的知识。
图像处理相关概念介绍&emsp;要想了解Shader的概念，首先要了解Android图像处理中几个比较重要的概念：bitmap,canvas,dr ......
            
          </p>
      </section>
    </a>
    
  
</aside>


  <footer class="site-footer clearfix">
 <section class="copyright"><a href="/">程序员历小冰</a> &copy; 2015 &bull; All rights reserved.</section>
 <section class="poweredby">Proudly published with <a class="icon-ghost" href="http://zespia.tw/hexo/"> Hexo</a></section>
</footer>

  </div>
  <script type="text/javascript" src="/js/jquery-2.0.3.min.js"></script>
<script>window.jQuery || document.write('<script src="js/jquery-2.0.3.min.js"><\/script>')</script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/prism.js"></script>
<script type="text/javascript" src="/js/toc.js"></script>

<script type="text/javascript">
(function($){
  var $postContent = $(".post-content");
  $postContent.fitVids();
})(jQuery);
</script>

<script type="text/javascript" src="/js/index.js"></script>

<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    var wrapAll = function(q) {
      $(q).each( function() {
        var $img = $(this),
            href = $img.attr('src');
        $img.wrap('<a rel="fancybox" href="' + href + '" title="' + $img.attr('alt') + '" class="link"></a>');
      });
    };
    wrapAll('.post-content img');
    wrapAll('.post-excerpt img');
    $('[rel="fancybox"]').fancybox();
  })(jQuery);
</script>





<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f089a91a688633df563c08899e3d893e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>



</body>
</html>
